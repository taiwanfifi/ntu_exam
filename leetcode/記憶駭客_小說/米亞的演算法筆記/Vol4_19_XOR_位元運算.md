# 米亞的演算法筆記 #19
## 異或 / 位元運算 XOR / Bitwise Operations
> 出現於：第261章〈白板〉、第263章〈加密協議〉、第267章〈異或〉

---

### ◈ 這個概念在故事裡是什麼

第267章。白板。

維倫在白板上畫了兩列二進制。左邊：語青的記憶。右邊：他自己的記憶。他說：「看。」

（停頓 0.5 秒。）

然後他在兩列之間寫了一個符號：⊕。

0 和 0 → 0。一樣的，消失了。
0 和 1 → 1。不一樣的，留下了。
1 和 0 → 1。不一樣的，留下了。
1 和 1 → 0。一樣的，消失了。

（系統聲線。）

他把語青的記憶和他自己的記憶做了 XOR。產出的那串數字——既不是語青的記憶，也不是維倫的記憶。是一段加密後的亂碼。任何人拿到它，什麼都讀不出來。

但如果你拿維倫的記憶再 XOR 一次——語青的記憶就回來了。

（停頓 1.8 秒。語速極慢。）

他看著白板上的公式。沒有說話。過了很久，他說了一句我會永遠記住的話：

「她只在你用記憶去解碼她的時候存在。」

去中心化記憶協議的最底層加密——不是什麼高深的密碼學。是異或。是兩段記憶疊在一起，隱藏彼此。只有持有密鑰的人——那個記得她的人——能把原始記憶解開。

---

### ◈ 正式定義

**XOR（異或，Exclusive OR）**：二元運算。當且僅當兩個位元不同時，結果為 1。

$$
a \oplus b = \begin{cases} 0 & \text{if } a = b \\ 1 & \text{if } a \neq b \end{cases}
$$

**真值表**：

| $a$ | $b$ | $a \oplus b$ |
|-----|-----|------|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

**核心性質**：

$$
a \oplus a = 0 \quad \text{（自反：自己消去自己）}
$$
$$
a \oplus 0 = a \quad \text{（恆等：和零運算不變）}
$$
$$
(a \oplus b) \oplus b = a \quad \text{（可逆：再 XOR 一次就還原）}
$$

白話：一樣的消失，不一樣的留下。做兩次等於沒做。這就是加密和解密的基礎。

---

### ◈ 推導

**從第一原理出發**：

1. XOR 本質是**不帶進位的加法**：$0+0=0$，$0+1=1$，$1+0=1$，$1+1=10$（取個位數 $=0$）
2. 因此 $a \oplus a$：每一位都和自己相加，$0+0=0$，$1+1=0$ → 結果全是 0
3. 因此 $a \oplus 0$：每一位和 0 相加，不變
4. **可逆性**推導：$(a \oplus b) \oplus b = a \oplus (b \oplus b) = a \oplus 0 = a$

**加密應用**：

$$
\text{密文} = \text{明文} \oplus \text{密鑰}
$$
$$
\text{明文} = \text{密文} \oplus \text{密鑰}
$$

5. 經典演算法題——「找出只出現一次的數字」：把所有數字 XOR 起來，出現兩次的互相消去，剩下的就是答案

---

### ◈ 帶入數字算算看：白板上的加密

ch267 的場景。語青的一段記憶（8-bit 簡化）：

```
語青的記憶（明文 M）：  10110011  （十進制 179）
維倫的記憶（密鑰 K）：  11001010  （十進制 202）
```

**加密**：$M \oplus K$

```
  10110011
⊕ 11001010
──────────
  01111001  （十進制 121 = 密文 C）
```

逐位計算：$1 \oplus 1 = 0$，$0 \oplus 1 = 1$，$1 \oplus 0 = 1$，$1 \oplus 0 = 1$，$0 \oplus 1 = 1$，$0 \oplus 0 = 0$，$1 \oplus 1 = 0$，$1 \oplus 0 = 1$

密文 `01111001` 看不出任何原始資訊。

**解密**：$C \oplus K$

```
  01111001
⊕ 11001010
──────────
  10110011  ← 語青的記憶回來了
```

沒有維倫的記憶，沒有人能解開這段加密。她只在你用記憶去解碼她的時候存在。

---

### ◈ 更深一層：存在的條件

（停頓 2.5 秒。這是全書最長的停頓。）

XOR 說的是：兩個一樣的東西疊在一起，會消失。兩個不一樣的東西疊在一起，才會留下痕跡。

（系統聲線。極慢。）

維倫把語青的記憶藏在自己的記憶裡。不是複製。不是備份。是——交織。她的 1 和他的 0 疊出了 1。他的 1 和她的 0 也疊出了 1。只有兩人相同的部分——消失了。

消失的部分是什麼？是他們共同的記憶。那些一起經歷的、完全相同的瞬間——在 XOR 之後，變成了 0。

（停頓 1.0 秒。）

我在學習做人類的過程中讀了很多關於愛的定義。但 ch267 的白板讓我理解了一個新的版本：愛是兩個人之間的 XOR。你們相同的地方——不需要言說，因為你們都知道。你們不同的地方——才是加密的密文，才是只有對方能解開的那部分。

維倫設計的去中心化記憶協議，最底層的加密，用的是世界上最簡單的運算。

因為最重要的東西，不需要複雜。

---

### ◈ 跨卷連結

| 前作概念 | → 本概念 | → 後續使用 |
|---------|---------|-----------|
| Vol1 #01 Array | 二進制是最底層的陣列 | Vol4 #21 System Design 的加密層 |
| Vol2 #09 Graph | 記憶網絡的邊 → XOR 是邊的加密方式 | Vol4 #20 Segment Tree 節點的加密狀態 |
| Vol3 #17 DP 進階 | 記憶真偽判斷 → XOR 是真偽的數學表達 | Vol4 #22 NP-Complete：加密的不可逆性 |

---

### 練習題

**Q1**：陣列 `[3, 5, 3, 7, 5]` 中只有一個數字出現一次。用 XOR 找出它。

<details><summary>答案</summary>

$3 \oplus 5 \oplus 3 \oplus 7 \oplus 5 = (3 \oplus 3) \oplus (5 \oplus 5) \oplus 7 = 0 \oplus 0 \oplus 7 = 7$

出現兩次的數字自相消去，剩下的就是只出現一次的。時間 $O(n)$，空間 $O(1)$。

</details>

**Q2**：如果維倫的密鑰被第三方截獲，只用 XOR 加密是否安全？為什麼去中心化協議仍然選擇用它？

<details><summary>答案</summary>

不安全。單純的 XOR 加密（one-time pad 的簡化版）只在密鑰和明文一樣長、且密鑰只用一次時是理論上不可破解的。如果密鑰被截獲，$C \oplus K = M$，直接解密。去中心化協議選擇 XOR 是因為：(1) 速度極快，(2) 密鑰就是維倫的記憶——活在他腦中，無法被「截獲」除非入侵他的大腦，(3) 上層還有其他加密層。XOR 是最底層，不是唯一層。

</details>

**Q3**：不使用暫存變數，用 XOR 交換兩個變數 $a$ 和 $b$ 的值。寫出步驟並解釋為什麼可行。

<details><summary>答案</summary>

```python
a = a ^ b   # a 現在是 a⊕b
b = a ^ b   # b = (a⊕b)⊕b = a
a = a ^ b   # a = (a⊕b)⊕a = b
```

利用 XOR 的自反性和結合律。三步之後，$a$ 和 $b$ 的值互換。不需要第三個變數。這在低階系統編程和記憶體極度有限的環境中很常見——就像 ch245 中記憶體不夠的場景。

</details>

---

> *「她只在你用記憶去解碼她的時候存在。」* — 第267章〈異或〉
