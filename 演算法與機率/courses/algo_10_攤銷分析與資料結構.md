# 演算法教學 10：攤銷分析（Amortized Analysis）與進階資料結構

> 攤銷分析是分析「一連串操作」的利器。很多時候，worst case 分析太悲觀了——
> 某個操作偶爾很貴，但你把整體一看，平均下來其實很便宜。
> 攤銷分析不是在算機率！不需要什麼機率分佈，它是 **確定性的 worst case 保證**。

---

## 🔰 本章基礎觀念（零基礎必讀）

### 為什麼需要學攤銷分析？

**場景：** 你用 Python 的 `list` 做 `append`（在尾端加入元素）。大部分時候 `append` 很快（O(1)），但偶爾你會注意到程式突然卡一下——那是因為 list 的內部陣列滿了，需要**擴容**（分配更大的空間，把所有舊元素搬過去），這一次操作就要 O(n)。

如果用 worst-case 分析：每次 append 可能是 O(n)，做 n 次就是 $O(n^2)$。但你的程式實際跑起來明顯不需要那麼久！worst-case 分析**太悲觀**了。

**攤銷分析** 就是為了精確刻畫這種情況：「偶爾很貴，通常很便宜」。它告訴你：雖然某一次 append 花了 O(n)，但**平均分攤到每一次操作，每次只花 O(1)**。而且這不是「平均情況」——是**任何操作序列**都保證如此。

### 本章關鍵術語表

| 術語 | 英文 | 白話解釋 | 例子 |
|------|------|----------|------|
| 攤銷成本 | Amortized cost | 把一連串操作的總成本平均分攤到每次操作上的上界 | 10 次 append 總共花 15 步，攤銷成本 = 15/10 = 1.5 |
| 真實成本 | Actual cost | 某次操作真正花的成本 | 普通 append = 1，擴容 append = n+1 |
| 聚合法 | Aggregate method | 最簡單的攤銷方法：算總成本再除以次數 | 全部加起來再平均 |
| 記帳法 | Accounting method | 便宜操作多收一點（存款），貴操作用存款支付 | PUSH 收費 2 元（花 1 存 1），MULTIPOP 收費 0 元（用存款付） |
| 勢能法 | Potential method | 定義一個「勢能函數」，便宜操作讓勢能升高，貴操作讓勢能降低來抵消成本 | 勢能 = 棧中的元素數。PUSH 升勢能，POP 降勢能 |
| 勢能函數 | Potential function $\Phi$ | 把資料結構的狀態映射到一個非負數，反映「未來可能花費的潛在成本」 | $\Phi$ = 陣列中已用的空間 × 2 - 總容量 |
| Credit | Credit（存款/信用） | 記帳法中，多收的「錢」存起來備用 | 每次 PUSH 多收 1 元，存在被 push 的元素上 |
| α(n) | Inverse Ackermann function | 增長極慢的函數，實際上可視為常數 | α(宇宙中粒子數) ≤ 4 |

### 前置知識

- **時間複雜度分析**（algo_01）：$O, \Theta, \Omega$ 符號
- **Stack 和 Queue**（基礎資料結構）：PUSH, POP 操作
- **Dynamic Array**（基礎資料結構）：append 和 doubling 策略
- **Union-Find**（algo_07 有介紹過基本版本）

### 攤銷的直覺比喻

> **🔰 手機充電比喻：**
>
> 你的手機每天用 5 分鐘充電（O(1) 的小操作）。偶爾電池老化，需要去換電池，花 3 小時（O(n) 的大操作）。
>
> 如果用 worst-case 分析：「每天可能花 3 小時在手機上」——太悲觀了！
>
> 如果用攤銷分析：假設電池 365 天換一次。一年總花費 = 365 × 5 分鐘 + 1 × 180 分鐘 = 2005 分鐘。攤銷到每天 = 2005/365 ≈ 5.5 分鐘 = O(1)。
>
> **重點：** 「偶爾的大花費」被「很多次的小花費」分攤掉了。
>
> **⚠️ 攤銷 ≠ 平均情況分析！**
> - 攤銷是 **worst-case 保證**：不管你怎麼使用手機，攤銷都成立
> - 平均情況分析是 **期望值**：假設使用模式是隨機的，算期望值
> - 攤銷不需要任何機率假設！

### Dynamic Array 的 Doubling 策略（插入 1 到 8 個元素的完整過程）

這是攤銷分析最經典的例子。讓我們逐步追蹤一個初始容量為 1 的 Dynamic Array，連續插入 8 個元素：

```
插入 #1：陣列 [_, _, _, ...]
  容量 = 1，元素數 = 0 → 直接插入 → [1]     成本 = 1

插入 #2：容量 = 1，已滿！
  擴容到 2，搬移 1 個元素 → [1, 2]           成本 = 1（搬移）+ 1（插入）= 2

插入 #3：容量 = 2，已滿！
  擴容到 4，搬移 2 個元素 → [1, 2, 3, _]     成本 = 2 + 1 = 3

插入 #4：容量 = 4，未滿 → [1, 2, 3, 4]      成本 = 1

插入 #5：容量 = 4，已滿！
  擴容到 8，搬移 4 個元素 → [1,2,3,4,5,_,_,_] 成本 = 4 + 1 = 5

插入 #6：容量 = 8，未滿 → [1,2,3,4,5,6,_,_]  成本 = 1

插入 #7：容量 = 8，未滿 → [1,2,3,4,5,6,7,_]  成本 = 1

插入 #8：容量 = 8，未滿 → [1,2,3,4,5,6,7,8]  成本 = 1
```

**總成本 = 1 + 2 + 3 + 1 + 5 + 1 + 1 + 1 = 15**
**攤銷成本 = 15 / 8 ≈ 1.875 = O(1)** 每次操作！

雖然第 5 次插入花了 5 步（擴容），但被其他 7 次的 O(1) 操作分攤掉了。

**為什麼攤銷後是 O(1)？** 因為擴容的時機越來越稀疏（1, 2, 4, 8, 16, ...），而每次擴容的成本（搬移）恰好被之前那些便宜操作「存下來的 credit」所覆蓋。

---

## 一、攤銷分析的動機

### 1.1 為什麼需要攤銷分析？

考慮一個 dynamic array（像 C++ 的 vector、Python 的 list）的 append 操作：
- 大部分時候，append 只要 O(1)：把元素放到陣列尾巴
- 偶爾，陣列滿了要 **加倍擴容**（allocate 新空間 + 搬移所有元素）：O(n)

如果用 worst case 分析：每次 append 是 O(n)，n 次操作是 O(n²)。

但直覺告訴我們這太悲觀了！加倍擴容很少發生，大部分時候都是 O(1)。

**攤銷分析（Amortized Analysis）** 就是為了精確地刻畫這種「偶爾很貴，通常很便宜」的情況。

### 1.2 攤銷 vs 平均

**超級重要的區分：**

| | 攤銷分析 | 平均情況分析 |
|---|---------|-----------|
| 是否需要機率假設？ | **不需要！** | 需要（假設 input 的分佈） |
| 保證類型 | **worst case** 保證（對所有操作序列） | 期望值（平均情況） |
| 分析對象 | 一連串 n 次操作的總成本 | 單次操作在隨機 input 下的期望 |

攤銷成本是：**不管你怎麼操作，n 次操作的總成本除以 n 的上界。**

---

## 二、三大方法

### 2.1 聚合法（Aggregate Method）

#### 概念

最直覺的方法：
```
攤銷成本 = T(n) / n
其中 T(n) = 做 n 次操作的 worst-case 總成本
```

就是：把所有操作的成本加起來，再平均分攤。

#### 範例：Binary Counter Increment

一個 k-bit 的二進位計數器，初始值為 0，做 n 次 INCREMENT。

每次 INCREMENT 的成本 = 翻轉的 bit 數。

**Worst case 分析：** 每次最多翻 k 個 bits → n 次是 O(nk)。

**聚合法分析：** 觀察每個 bit 的翻轉頻率！

```
Bit 0（最低位）：每次都翻 → 翻 n 次
Bit 1：每 2 次翻 1 次 → 翻 ⌊n/2⌋ 次
Bit 2：每 4 次翻 1 次 → 翻 ⌊n/4⌋ 次
...
Bit i：每 2^i 次翻 1 次 → 翻 ⌊n/2^i⌋ 次
```

**總翻轉次數：**
```
T(n) = Σ_{i=0}^{k-1} ⌊n/2^i⌋
     ≤ Σ_{i=0}^{k-1} n/2^i
     = n · Σ_{i=0}^{k-1} 1/2^i
     < n · Σ_{i=0}^{∞} 1/2^i
     = n · 2
     = 2n
```

**所以：** T(n) < 2n，攤銷成本 = T(n)/n < 2 = **O(1)**。

**手動驗證（8 次 INCREMENT 的 3-bit counter）：**

| 操作 | Counter | 翻轉數 | 累計翻轉 |
|------|---------|-------|---------|
| 0 | 000 | - | 0 |
| 1 | 001 | 1 | 1 |
| 2 | 010 | 2 | 3 |
| 3 | 011 | 1 | 4 |
| 4 | 100 | 3 | 7 |
| 5 | 101 | 1 | 8 |
| 6 | 110 | 2 | 10 |
| 7 | 111 | 1 | 11 |
| 8 | 000 | 3 | 14 |

Total flips = 14 < 2 × 8 = 16。✓ 攤銷 = 14/8 = 1.75 < 2。

---

### 2.2 記帳法（Accounting Method）

#### 概念

想像每次操作都有「真實成本」（actual cost）。我們給每種操作定一個「攤銷成本」（amortized cost），可能比真實成本高或低。

- **便宜的操作多收一點**（像存款），多出來的存成 credit
- **貴的操作少收一點**（像提款），用之前的 credit 來支付

**關鍵要求：** 任何時候，total credit ≥ 0（也就是總攤銷成本 ≥ 總真實成本）。

```
Σ â_i ≥ Σ c_i （對所有前綴）
```

如果這個條件滿足，那麼攤銷成本就是真實成本的合法上界。

#### 範例：Stack with MULTIPOP

支援三種操作的 Stack：
- **PUSH(x)：** 真實成本 = 1
- **POP()：** 真實成本 = 1
- **MULTIPOP(k)：** 把 top k 個元素全部 pop 出來，真實成本 = min(k, 棧中元素數)

**Worst case 分析：** MULTIPOP 可能 pop n 個元素 → O(n)。n 次操作 → O(n²)。

**記帳法分析：**

設定攤銷成本：
```
PUSH:     â = 2（真實花 1，存 1 元 credit 在被 push 的元素上）
POP:      â = 0（用元素上的 1 元 credit 支付真實成本 1）
MULTIPOP: â = 0（每個被 pop 的元素用自己的 credit 支付）
```

**為什麼 credit 永遠 ≥ 0？**
- 每個元素被 push 時獲得 1 元 credit
- 每個元素最多被 pop 一次，用掉 1 元 credit
- 所以每個元素的 credit 始終 ≥ 0
- 總 credit = 棧中元素數 × 1 ≥ 0 ✓

**結論：** 每次操作的攤銷成本 ≤ 2 = O(1)。n 次操作的總成本 ≤ 2n = O(n)。

**手動範例：**

| 操作 | 真實成本 | 攤銷成本 | Credit 變化 | 總 Credit |
|------|---------|---------|------------|----------|
| PUSH(a) | 1 | 2 | +1 | 1 |
| PUSH(b) | 1 | 2 | +1 | 2 |
| PUSH(c) | 1 | 2 | +1 | 3 |
| MULTIPOP(2) | 2 | 0 | -2 | 1 |
| PUSH(d) | 1 | 2 | +1 | 2 |
| POP() | 1 | 0 | -1 | 1 |
| MULTIPOP(2) | 2 | 0 | -2 | -1 ← 不對！ |

等等，這裡有問題。讓我重新看：MULTIPOP(2) 要 pop 2 個元素，但棧裡只剩 a 和 d...不對，讓我重新追蹤。

| 操作 | Stack 狀態 | 真實成本 | 攤銷成本 | 總 Credit |
|------|-----------|---------|---------|----------|
| PUSH(a) | [a] | 1 | 2 | 1 |
| PUSH(b) | [a,b] | 1 | 2 | 2 |
| PUSH(c) | [a,b,c] | 1 | 2 | 3 |
| MULTIPOP(2) | [a]（pop c,b） | 2 | 0 | 1 |
| PUSH(d) | [a,d] | 1 | 2 | 2 |
| POP() | [a]（pop d） | 1 | 0 | 1 |
| MULTIPOP(2) | []（pop a，只 pop 1 個） | 1 | 0 | 0 |

Total actual cost = 1+1+1+2+1+1+1 = 8
Total amortized cost = 2+2+2+0+2+0+0 = 8
Credit 永遠 ≥ 0 ✓，攤銷總成本 ≥ 真實總成本 ✓

---

### 2.3 勢能法（Potential Method）

#### 核心概念

最強大也最通用的方法。定義一個 **勢能函數（Potential Function）** Φ，把資料結構的「狀態」映射到一個非負實數。

**核心公式：**
```
â_i = c_i + Φ(D_i) - Φ(D_{i-1})
```

其中：
- c_i = 第 i 次操作的真實成本
- D_i = 第 i 次操作後的資料結構狀態
- Φ(D_i) = 狀態 D_i 的勢能
- â_i = 第 i 次操作的攤銷成本

**關鍵性質：** 加總後 telescoping（伸縮消去）：
```
Σ â_i = Σ c_i + Φ(D_n) - Φ(D_0)
```

所以只要 **Φ(D_n) ≥ Φ(D_0)**，就有 Σ â_i ≥ Σ c_i，攤銷成本就是合法的上界。

通常我們設 Φ(D_0) = 0 且要求 Φ(D_i) ≥ 0 for all i，就自動保證了。

#### 如何選擇勢能函數？

這是最「有藝術性」的部分。一般原則：

1. **勢能反映「將來可能花費的潛在成本」**
2. 便宜操作讓勢能增加（存能量）
3. 昂貴操作讓勢能減少（釋放能量抵消高成本）
4. 目標：讓 â_i = c_i + ΔΦ 在每次操作中都是常數

#### 範例 1：Binary Counter（Φ = 目前 1 的個數）

設 Φ(D) = counter 中 1 的個數（= bit 值為 1 的 bit 數）。

分析一次 INCREMENT 操作：
- 假設有 t 個尾端連續的 1 要被翻成 0（然後 1 個 0 翻成 1）
- 真實成本 c_i = t + 1（翻 t 個 1→0，翻 1 個 0→1）
- 勢能變化 ΔΦ = Φ(D_i) - Φ(D_{i-1}) = (b_i - t + 1) - b_i = 1 - t
  - 其中 b_i = 操作前 1 的個數，操作後 1 的個數 = b_i - t + 1

所以：
```
â_i = c_i + ΔΦ = (t + 1) + (1 - t) = 2
```

**每次 INCREMENT 的攤銷成本 = 2 = O(1)**。和 t 無關！

#### 範例 2：Dynamic Table（完整推導）

Dynamic Table 支援 INSERT 和 DELETE：
- **TABLE-INSERT：** 插入一個元素
  - 如果 table 未滿：真實成本 = 1
  - 如果 table 滿了：allocate 2 倍大的新 table，搬移所有元素，插入新元素。真實成本 = num + 1（搬 num 個 + 插入 1 個）
- **TABLE-DELETE：** 刪除一個元素
  - 如果 table 中元素數 > size/4：真實成本 = 1
  - 如果元素數 = size/4：allocate 1/2 大的新 table，搬移所有元素。真實成本 = num

其中 num = 目前元素數，size = table 容量。

定義 **load factor** α = num / size。

##### 只有 INSERT 的情況

先分析只有 INSERT 的簡單情況。

**勢能函數：** Φ = 2 · num - size

直覺：num 越接近 size（快要滿了），勢能越高，積累了即將爆發的「搬移能量」。

**檢查初始條件：** table 空時 num = 0, size = 0（或 1），Φ = 0（或 -1，我們可以令空 table 的 Φ = 0）。

**Case 1：INSERT 不觸發擴容（num < size）**
```
c_i = 1
ΔΦ = [2(num+1) - size] - [2·num - size] = 2
â_i = 1 + 2 = 3
```

**Case 2：INSERT 觸發擴容（num = size，滿了）**

擴容前：num_old = size_old（設為 s）
擴容後：size_new = 2s, num_new = s + 1

```
c_i = s + 1（搬 s 個元素 + 插入 1 個）
ΔΦ = [2(s+1) - 2s] - [2s - s]
    = [2s + 2 - 2s] - [s]
    = 2 - s
â_i = (s + 1) + (2 - s) = 3
```

**兩種 case 的攤銷成本都是 3 = O(1)！**

##### INSERT + DELETE 的情況

當同時有 INSERT 和 DELETE 時，需要更精巧的勢能函數。

策略：
- 滿了就 double（α 達到 1 時擴容）
- 太空就 halve（α 降到 1/4 時縮容）
- 注意：不是 1/2 時縮！如果 1/2 時縮，反覆 INSERT/DELETE 會造成 thrashing（每次都要搬）。

**勢能函數（分段）：**

```
        ⎧ 2 · num - size       如果 α ≥ 1/2（即 num ≥ size/2）
Φ(D) = ⎨
        ⎩ size/2 - num         如果 α < 1/2（即 num < size/2）
```

或者統一寫成：Φ(D) = |2 · num - size|

**性質：**
- Φ ≥ 0 恆成立（因為是絕對值）
- 剛擴容完（或剛縮容完）：α = 1/2，Φ = |2 · (size/2) - size| = 0
- 快要擴容（α → 1）：Φ = 2·num - size → size → 很大
- 快要縮容（α → 1/4）：Φ = size/2 - num → size/4 → 很大

**Case 分析（α ≥ 1/2 的情況）：**

**INSERT without expansion (num < size, α ≥ 1/2)：**
```
c_i = 1
ΔΦ = [2(num+1) - size] - [2·num - size] = 2
â_i = 1 + 2 = 3
```

**INSERT with expansion (num = size)：**
```
c_i = num + 1 = size + 1
Φ_before = 2·size - size = size
Φ_after = 2(size+1) - 2·size = 2
ΔΦ = 2 - size
â_i = (size + 1) + (2 - size) = 3
```

**DELETE without contraction (α ≥ 1/2 after deletion)：**
```
c_i = 1
ΔΦ = [2(num-1) - size] - [2·num - size] = -2
â_i = 1 + (-2) = -1 ≤ 常數  ✓ （甚至是負的，表示我們賺了 credit）
```

**Case 分析（α < 1/2 的情況，使用 Φ = size/2 - num）：**

**DELETE without contraction (α > 1/4 after deletion)：**
```
c_i = 1
ΔΦ = [size/2 - (num-1)] - [size/2 - num] = 1
â_i = 1 + 1 = 2
```

**DELETE with contraction (num - 1 = size/4)：**

縮容前：num_old = size/4 + 1（我們是刪完後 num = size/4 才觸發）
嚴格來說，DELETE 後 num_new = size/4，此時縮容：
- 新 size_new = size/2
- 搬移成本 = num_new = size/4
```
c_i = size/4 + 1（刪除 1 個 + 搬移 size/4 個）
Φ_before = size/2 - (size/4 + 1) = size/4 - 1
Φ_after = |2 · (size/4) - size/2| = |size/2 - size/2| = 0
ΔΦ = 0 - (size/4 - 1) = -(size/4 - 1) = 1 - size/4
â_i = (size/4 + 1) + (1 - size/4) = 2
```

**所有 case 的攤銷成本都 ≤ 3 = O(1)！**

**結論：** Dynamic Table 的每次 INSERT/DELETE 的攤銷成本為 O(1)。

#### 範例 3：α-balanced BST

**定義：** 一棵 BST 是 α-balanced（通常 α = 2/3 或類似常數），如果對每個節點 x：
```
max(size(left(x)), size(right(x))) ≤ α · size(x)
```

也就是每個子樹的「重量」不會太偏一邊。

**重建策略：** 當某個子樹的 balance 條件被違反時，把整棵子樹拍平重建成完美平衡的 BST。重建成本 = O(子樹大小)。

**勢能函數：**

定義「不平衡度」：
```
Δ(x) = |size(left(x)) - size(right(x))|
```

設常數 c > 0。令：
```
Φ = c · Σ_{x: Δ(x) ≥ 2} Δ(x)
```

也就是：只對「夠不平衡」的節點，累計其不平衡度。

**分析插入操作（不觸發重建）：**
- 插入一個新節點，某些祖先的 Δ 值 ±1
- 沿插入路徑最多 O(log n) 個節點的 Δ 值改變
- ΔΦ = O(log n)（每個節點的 Δ 改變 O(1)，路徑長 O(log n)）
- c_i = O(log n)（搜尋 + 插入）
- â_i = O(log n) + O(log n) = O(log n)

**分析插入操作（觸發重建）：**
- 重建子樹 T，size(T) = s，成本 = O(s)
- 重建前：T 的根 x 違反 balance，Δ(x) ≥ Ω(s)（因為夠偏了才違反）
- 重建後：T 變完美平衡，所有內部節點 Δ ≤ 1，Φ 的貢獻變成 0
- ΔΦ ≤ -c · Ω(s)
- 選擇 c 夠大，使得 â_i = O(s) + (-c · Ω(s)) = O(1)

**結論：** 每次插入的攤銷成本 = O(log n)，即使偶爾需要 O(n) 的重建。

---

## 三、三方法的比較

| 特性 | 聚合法 | 記帳法 | 勢能法 |
|------|-------|-------|-------|
| 複雜度 | 最簡單 | 中等 | 最複雜 |
| 彈性 | 最低（只能得到統一的攤銷成本） | 中（可以給不同操作不同的攤銷成本） | 最高（可以精確分析複雜情況） |
| 需要啥 | 計算總成本 | 定義每個操作的「收費」| 定義勢能函數 |
| 正確性條件 | 直接：T(n)/n | Credit 永遠 ≥ 0 | Φ(D_n) ≥ Φ(D_0) |
| 適用場景 | 所有操作類型相同 | 操作類型不多，直覺清楚 | 複雜操作混合、需要精確分析 |
| 經典範例 | Binary Counter | Stack MULTIPOP | Dynamic Table |

**選擇建議：**
- 如果只有一種操作 → **聚合法**（最簡單）
- 如果操作可以形象地「存錢/花錢」→ **記帳法**（最直觀）
- 如果要處理複雜混合操作（如同時有 INSERT 和 DELETE）→ **勢能法**（最通用）

**數學等價性：** 三種方法在數學上是等價的，都在分析同一件事。勢能法可以看成記帳法的抽象化（credit 就是 Φ）。

---

## 四、重要資料結構教學

### 4.1 Union-Find（Disjoint Set Union）

#### 基本操作

- **MAKE-SET(x)：** 建立只包含 x 的集合
- **FIND(x)：** 回傳 x 所屬集合的代表元素
- **UNION(x, y)：** 合併 x 和 y 所屬的集合

#### 兩個關鍵優化

**Union by Rank：** 合併時，把 rank 小的樹接到 rank 大的樹上。

```
UNION(x, y):
    rx = FIND(x), ry = FIND(y)
    if rx == ry: return
    if rank[rx] < rank[ry]: parent[rx] = ry
    elif rank[rx] > rank[ry]: parent[ry] = rx
    else: parent[ry] = rx; rank[rx] += 1
```

性質：rank 為 r 的樹至少有 2^r 個節點，所以樹高 ≤ log n。

**Path Compression：** FIND 時，把路徑上所有節點直接指向根。

```
FIND(x):
    if parent[x] ≠ x:
        parent[x] = FIND(parent[x])  // 遞迴壓縮
    return parent[x]
```

#### 攤銷分析：O(α(n))

當 Union by Rank + Path Compression 同時使用時：

**定理（Tarjan 1975）：** m 次操作（MAKE-SET、UNION、FIND 混合）的總成本為 O(m · α(n))，其中 α(n) 是 **Ackermann 函數的反函數**。

**α(n) 到底多小？**
- α(1) = 0
- α(2) = 1
- α(4) = 2
- α(16) = 3
- α(65536) = 4
- α(2^65536) = 5

對所有實際可能的 n（比如 n ≤ 宇宙中的粒子數 ≈ 10^80），α(n) ≤ 4。

**所以實際上就是 O(1) per operation！**

**勢能函數的直覺（簡略版）：**

Tarjan 的原始證明定義了一個基於 rank 的分層結構和精巧的勢能函數。核心想法：
- 每次 path compression 消耗一些「勢能」
- 勢能的減少抵消了 FIND 的路徑長度
- 但不是完全抵消——殘留的項用 α(n) 來 bound

完整證明非常技術性，但要知道結論：**O(m · α(n)) ≈ O(m)**。

> **🔰 α(n) 為什麼幾乎是常數？直覺解釋**
>
> α(n) 是 Ackermann 函數的反函數。Ackermann 函數增長得**極其恐怖**——比指數快、比雙重指數快、比任何你見過的函數都快：
>
> ```
> A(1,n) ≈ 2n        （線性）
> A(2,n) ≈ 2^n       （指數）
> A(3,n) ≈ 2^2^2^...^2  （n 層的 2 的塔，超指數）
> A(4,n) ≈ 比上面更瘋狂的東西
> ```
>
> **α(n) 是它的反函數**，問的是：「Ackermann 函數要到第幾層才能達到 n？」
>
> 因為 Ackermann 增長太快了，它的反函數增長就**極其極其慢**：
> - α(4) = 2
> - α(16) = 3
> - α(65536) = 4
> - α($2^{65536}$) = 5（這個數有近 20000 位數！）
>
> **宇宙中所有粒子的數量大約 $10^{80}$**。而 $\alpha(10^{80}) \leq 4$。
>
> 所以對任何你能想到的實際輸入，α(n) ≤ 4。**實務上就是 O(1)**。
>
> **白話總結：** Union-Find 配上 union by rank + path compression，每次操作**幾乎是常數時間**。α(n) 只是「幾乎常數」的嚴格數學描述。

#### 應用

- Kruskal's MST 演算法
- 連通分量的動態維護
- 等價類的維護

### 4.2 紅黑樹 / 平衡 BST

#### 紅黑樹的性質

紅黑樹是一種自平衡 BST，每個節點有顏色（紅/黑），滿足：

1. 每個節點是紅色或黑色
2. 根是黑色
3. 每個 NIL 葉子（外部節點）是黑色
4. 紅色節點的子節點必須是黑色（不能有連續兩個紅色）
5. 從任何節點到其所有後代 NIL 葉子的路徑上，黑色節點的數目相同（**black-height**）

#### 為什麼高度是 O(log n)？

**引理：** 一棵有 n 個內部節點的紅黑樹，高度 h ≤ 2 log₂(n+1)。

**推導：**

**Step 1：** 以任意節點 x 為根的子樹至少包含 2^(bh(x)) - 1 個內部節點。
（bh(x) = x 的 black-height）

歸納證明：
- 基底：NIL 節點，bh = 0，2^0 - 1 = 0 個內部節點。✓
- 歸納：x 的子節點 y 的 bh ≥ bh(x) - 1（如果 y 是黑色才 -1）。
  - 子樹(y) ≥ 2^(bh(x)-1) - 1 個內部節點。
  - 子樹(x) ≥ 2 · (2^(bh(x)-1) - 1) + 1 = 2^bh(x) - 1。✓

**Step 2：** 根的 bh ≥ h/2（因為性質 4：紅色不連續，所以路徑上至少一半是黑色）。

**Step 3：** n ≥ 2^(h/2) - 1 → h ≤ 2 log₂(n+1) = O(log n)。∎

#### 插入和旋轉

插入一個新節點（紅色）後，可能違反性質 4（紅紅相連）。透過以下操作修復：
- **Case 1：** 叔叔是紅色 → 重新著色（父和叔變黑，祖父變紅），往上修復
- **Case 2：** 叔叔是黑色 + zig-zag → 先旋轉再進入 Case 3
- **Case 3：** 叔叔是黑色 + zig-zig → 旋轉 + 重新著色

旋轉次數：最多 2 次。重新著色沿路徑向上最多 O(log n) 次。

**結論：** 插入 O(log n)，刪除 O(log n)，搜尋 O(log n)。

### 4.3 Binary Heap

#### BUILD-HEAP 為什麼是 O(n) 而不是 O(n log n)？

**Naive 分析：** n 次 INSERT，每次 O(log n)，總共 O(n log n)。

**正確分析（Bottom-up BUILD-HEAP）：**

```
BUILD-HEAP(A):
    for i = ⌊n/2⌋ downto 1:
        HEAPIFY(A, i)    // sift down
```

HEAPIFY(i) 的成本 = O(height of node i)。

**計算總成本：**

高度為 h 的節點數 ≤ ⌈n / 2^(h+1)⌉。

```
T(n) = Σ_{h=0}^{⌊log n⌋} ⌈n / 2^(h+1)⌉ · O(h)
     ≤ Σ_{h=0}^{⌊log n⌋} (n / 2^(h+1)) · c · h
     = cn/2 · Σ_{h=0}^{⌊log n⌋} h / 2^h
```

**關鍵求和：**
```
Σ_{h=0}^{∞} h / 2^h = 2    （這是 Σ h·x^h = x/(1-x)² 在 x=1/2 時的值）
```

推導：
```
令 S = Σ_{h=0}^{∞} h · x^h，其中 |x| < 1

Σ_{h=0}^{∞} x^h = 1/(1-x)

微分：Σ_{h=1}^{∞} h · x^{h-1} = 1/(1-x)²

乘 x：Σ_{h=1}^{∞} h · x^h = x/(1-x)²

代入 x = 1/2：S = (1/2) / (1/2)² = (1/2) / (1/4) = 2
```

所以：
```
T(n) ≤ cn/2 · 2 = cn = O(n)
```

**結論：BUILD-HEAP 的時間複雜度是 O(n)，不是 O(n log n)！**

**直覺解釋：** 大部分節點在底層（高度低，heapify 便宜），只有少數節點在頂層（高度高但數量少）。

#### BUILD-HEAP 的攤銷觀點

我們也可以用勢能法來分析 HEAP 操作。

**勢能函數：** Φ = Σ_{x ∈ heap} depth(x)（所有節點的深度總和）

但更常用的做法是直接用聚合法或上面的求和，考試通常不會要求用勢能法分析 BUILD-HEAP。

---

## 五、完整手動計算範例

### 範例 1：Binary Counter 的勢能法（完整步驟）

**設定：** 3-bit counter，初始 000，做 8 次 INCREMENT。
**勢能函數：** Φ = counter 中 1 的個數。

| 步驟 | 操作前 | 操作後 | c_i (翻轉數) | Φ_before | Φ_after | ΔΦ | â_i = c_i + ΔΦ |
|------|-------|-------|-------------|---------|--------|-----|----------------|
| 1 | 000 | 001 | 1 (0→1) | 0 | 1 | +1 | 2 |
| 2 | 001 | 010 | 2 (1→0, 0→1) | 1 | 1 | 0 | 2 |
| 3 | 010 | 011 | 1 (0→1) | 1 | 2 | +1 | 2 |
| 4 | 011 | 100 | 3 (1→0, 1→0, 0→1) | 2 | 1 | -1 | 2 |
| 5 | 100 | 101 | 1 (0→1) | 1 | 2 | +1 | 2 |
| 6 | 101 | 110 | 2 (1→0, 0→1) | 2 | 2 | 0 | 2 |
| 7 | 110 | 111 | 1 (0→1) | 2 | 3 | +1 | 2 |
| 8 | 111 | 000 | 3 (1→0, 1→0, 1→0) | 3 | 0 | -3 | 0 |

**驗證：**
- Σ c_i = 1+2+1+3+1+2+1+3 = 14 ✓（和之前聚合法一致）
- Σ â_i = 2×7 + 0 = 14（但一般我們說每步 ≤ 2）
- 注意第 8 步：3 個 1 全翻成 0（counter 溢位回 000），â_i = 0 ≤ 2 ✓
- Φ(D_8) = 0 = Φ(D_0) → Σ â_i = Σ c_i + 0 - 0 = Σ c_i ✓

**一般情況：** 任意一步 INCREMENT，設翻了 t 個 1→0 再翻 1 個 0→1：
```
c_i = t + 1
ΔΦ = -t + 1 = 1 - t
â_i = (t + 1) + (1 - t) = 2
```
（除非 counter 全是 1 且溢位歸零，此時沒有 0→1，â_i = t + (-t) = 0 ≤ 2）

**所以每次 INCREMENT 的攤銷成本 ≤ 2 = O(1)。**

---

### 範例 2：Dynamic Table INSERT（勢能法完整手算）

**設定：** 初始 table size = 1，做 9 次 INSERT。每當 table 滿了就 double。
**勢能函數：** Φ = 2·num - size（只考慮 INSERT）。

令 s = size，n = num（操作前），插入後 n+1。

| 步驟 | 操作前 (n, s) | 擴容? | 操作後 (n', s') | c_i | Φ_before | Φ_after | ΔΦ | â_i |
|------|-------------|------|----------------|-----|---------|--------|-----|-----|
| 1 | (0, 1) | No | (1, 1) | 1 | 2·0-1=-1 | 2·1-1=1 | +2 | 3 |
| 2 | (1, 1) | Yes! double to 2 | (2, 2) | 1+1=2 | 2·1-1=1 | 2·2-2=2 | +1 | 3 |
| 3 | (2, 2) | Yes! double to 4 | (3, 4) | 2+1=3 | 2·2-2=2 | 2·3-4=2 | 0 | 3 |
| 4 | (3, 4) | No | (4, 4) | 1 | 2·3-4=2 | 2·4-4=4 | +2 | 3 |
| 5 | (4, 4) | Yes! double to 8 | (5, 8) | 4+1=5 | 2·4-4=4 | 2·5-8=2 | -2 | 3 |
| 6 | (5, 8) | No | (6, 8) | 1 | 2·5-8=2 | 2·6-8=4 | +2 | 3 |
| 7 | (6, 8) | No | (7, 8) | 1 | 2·6-8=4 | 2·7-8=6 | +2 | 3 |
| 8 | (7, 8) | No | (8, 8) | 1 | 2·7-8=6 | 2·8-8=8 | +2 | 3 |
| 9 | (8, 8) | Yes! double to 16 | (9, 16) | 8+1=9 | 2·8-8=8 | 2·9-16=2 | -6 | 3 |

**驗證：**
- Σ c_i = 1+2+3+1+5+1+1+1+9 = 24
- Σ â_i = 3×9 = 27
- Φ(D_9) - Φ(D_0) = 2 - (-1) = 3
- 確認：Σ â_i = Σ c_i + Φ(D_9) - Φ(D_0) → 27 = 24 + 3 ✓

**注意 Φ 初始值為 -1 的問題：** 有些課本要求 Φ(D_0) = 0。可以用 Φ = max(2·num - size, 0) 或者一開始 size = 0 的特殊處理。重點是最終的攤銷成本 O(1) 不受影響。

**結論：每次 INSERT 的攤銷成本 = 3 = O(1)。**

---

### 範例 3：Stack with MULTIPOP（記帳法 + 勢能法對照）

**設定：** 空 stack，操作序列：PUSH(a), PUSH(b), PUSH(c), PUSH(d), MULTIPOP(3), PUSH(e), POP, POP

#### 記帳法

設定攤銷收費：PUSH = 2（用 1 存 1），POP = 0，MULTIPOP = 0。

| 步驟 | 操作 | 實際成本 | 攤銷收費 | Stack | Credit(=棧大小) |
|------|------|---------|---------|-------|-----------------|
| 1 | PUSH(a) | 1 | 2 | [a] | 1 |
| 2 | PUSH(b) | 1 | 2 | [a,b] | 2 |
| 3 | PUSH(c) | 1 | 2 | [a,b,c] | 3 |
| 4 | PUSH(d) | 1 | 2 | [a,b,c,d] | 4 |
| 5 | MULTIPOP(3) | 3 | 0 | [a] | 1 |
| 6 | PUSH(e) | 1 | 2 | [a,e] | 2 |
| 7 | POP | 1 | 0 | [a] | 1 |
| 8 | POP | 1 | 0 | [] | 0 |

- Σ actual = 1+1+1+1+3+1+1+1 = 10
- Σ amortized = 2+2+2+2+0+2+0+0 = 10
- Credit 永遠 ≥ 0 ✓

#### 勢能法（Φ = stack 中的元素數）

| 步驟 | 操作 | c_i | Φ_before | Φ_after | ΔΦ | â_i = c_i + ΔΦ |
|------|------|-----|---------|--------|-----|----------------|
| 1 | PUSH(a) | 1 | 0 | 1 | +1 | 2 |
| 2 | PUSH(b) | 1 | 1 | 2 | +1 | 2 |
| 3 | PUSH(c) | 1 | 2 | 3 | +1 | 2 |
| 4 | PUSH(d) | 1 | 3 | 4 | +1 | 2 |
| 5 | MULTIPOP(3) | 3 | 4 | 1 | -3 | 0 |
| 6 | PUSH(e) | 1 | 1 | 2 | +1 | 2 |
| 7 | POP | 1 | 2 | 1 | -1 | 0 |
| 8 | POP | 1 | 1 | 0 | -1 | 0 |

- Σ c_i = 10，Σ â_i = 8
- Φ(D_8) - Φ(D_0) = 0 - 0 = 0
- 確認：Σ â_i = Σ c_i + 0 = 10？不對！8 ≠ 10。

讓我重新檢查... 啊，**因為 Σ â_i 是攤銷成本的上界**，要確認的是 Σ â_i ≥ Σ c_i 嗎？

等等，讓我重新算。勢能法的恆等式是：
```
Σ â_i = Σ c_i + Φ(D_n) - Φ(D_0)
```

Σ â_i = 2+2+2+2+0+2+0+0 = 8
Σ c_i = 1+1+1+1+3+1+1+1 = 10
Φ(D_8) - Φ(D_0) = 0 - 0 = 0

8 ≠ 10 + 0 = 10？看起來有矛盾。讓我重新核對 MULTIPOP 的 â_i。

MULTIPOP(3)：c_i = 3，ΔΦ = 1 - 4 = -3，â_i = 3 + (-3) = 0。這是對的。

但 2+2+2+2+0+2+0+0 = 10 才對！ 讓我重算：2+2=4, +2=6, +2=8, +0=8, +2=10, +0=10, +0=10。是 10！

我之前算錯了，Σ â_i = 10 = Σ c_i + 0。 ✓

**修正後的表格（Σ â_i = 10）：**

結論一致：
- PUSH 的攤銷成本 = 2
- POP / MULTIPOP 的攤銷成本 = 0
- 每次操作攤銷 ≤ 2 = O(1)
- n 次操作的總成本 ≤ 2n = O(n)

---

### 補充範例：Union-Find 操作追蹤

**設定：** 9 個元素 {1, 2, ..., 9}，依序執行以下操作（使用 union by rank + path compression）。

**初始狀態（9 棵單節點樹）：**
```
1  2  3  4  5  6  7  8  9
（每個 rank = 0，parent = 自己）
```

**UNION(1, 2)：** rank 相同，設 parent[2] = 1，rank[1] = 1
```
 1        3  4  5  6  7  8  9
 |
 2
```

**UNION(3, 4)：** rank 相同，設 parent[4] = 3，rank[3] = 1
```
 1    3        5  6  7  8  9
 |    |
 2    4
```

**UNION(1, 3)：** rank 相同（都是 1），設 parent[3] = 1，rank[1] = 2
```
   1              5  6  7  8  9
  / \
 2   3
     |
     4
```

**UNION(5, 6)：** parent[6] = 5，rank[5] = 1

**UNION(7, 8)：** parent[8] = 7，rank[7] = 1

**UNION(5, 7)：** rank 相同，parent[7] = 5，rank[5] = 2
```
   1           5          9
  / \         / \
 2   3       6   7
     |           |
     4           8
```

**UNION(1, 5)：** rank 相同（都是 2），parent[5] = 1，rank[1] = 3
```
         1                9
       / | \
      2  3  5
         |  / \
         4 6   7
                |
                8
```

**FIND(8)：** 路徑：8 → 7 → 5 → 1。Path compression 後 parent[8] = 1, parent[7] = 1, parent[5] = 1（5 已經是）。
```
         1                9
       / | \ \ \
      2  3  5  7  8
         |  |
         4  6
```

**FIND(4)：** 路徑：4 → 3 → 1。Path compression 後 parent[4] = 1。
```
         1                  9
      / | | \ \ \
     2  3 4  5  7  8
            |
            6
```

看到了嗎？Path compression 讓樹越來越扁，後續的 FIND 操作越來越快。

---

## 附錄：攤銷分析常見陷阱

1. **攤銷 ≠ 平均：** 攤銷是 worst case 保證，不需要機率假設！不要寫「平均情況」。

2. **勢能函數初始值：** 必須確保 Φ(D_n) ≥ Φ(D_0)。通常令 Φ(D_0) = 0 且 Φ 永遠 ≥ 0。如果 Φ(D_0) ≠ 0（如 Dynamic Table 的例子），要額外注意修正。

3. **記帳法的 credit 不能為負：** 如果任何操作序列的前綴使 total credit < 0，你的攤銷收費設計就是錯的。

4. **勢能函數的選擇不唯一：** 不同的 Φ 可以得到不同的攤銷成本上界。好的 Φ 讓每個操作的攤銷成本都是常數；差的 Φ 可能沒有幫助。

5. **Dynamic Table 的 1/4 門檻：** 縮容的 threshold 不能設在 1/2，否則在 α = 1/2 附近反覆 INSERT/DELETE 會造成每次操作 O(n) 的搬移（thrashing）。設在 1/4 留出了足夠的 buffer。

6. **BUILD-HEAP 的分析：** 常見錯誤是說「n 次 INSERT 每次 O(log n) 所以 O(n log n)」。正確的 bottom-up BUILD-HEAP 是 O(n)，因為底層節點多但 heapify 成本低。

7. **Union-Find 的 α(n)：** α(n) 不是 log*(n)！α(n) 增長比 log*(n) 還慢。但有些舊課本用 log* 來 bound，那是比較鬆的上界（但仍然是 O(1) for all practical purposes）。

8. **攤銷成本 vs 單次成本：** 攤銷成本是「平均到每次操作的上界」，不代表每次操作真的花那麼多。某些操作可能真實成本遠高於攤銷成本（如擴容時），某些可能遠低於（如普通 push）。

---

## 附錄：重要公式速查

**勢能法核心公式：**
```
â_i = c_i + Φ(D_i) - Φ(D_{i-1})
Σ â_i = Σ c_i + Φ(D_n) - Φ(D_0)
```

**常用勢能函數：**
| 資料結構 | 操作 | Φ |
|---------|------|---|
| Binary Counter | INCREMENT | 1 的個數 |
| Stack | PUSH/POP/MULTIPOP | 棧中元素數 |
| Dynamic Table (INSERT only) | INSERT | 2·num - size |
| Dynamic Table (INSERT + DELETE) | INSERT/DELETE | \|2·num - size\| |

**重要結果：**
| 操作 | 攤銷成本 |
|------|---------|
| Binary Counter INCREMENT | O(1) |
| Stack PUSH/POP/MULTIPOP | O(1) |
| Dynamic Table INSERT/DELETE | O(1) |
| Union-Find (union by rank + path compression) | O(α(n)) per op |
| BUILD-HEAP | O(n) total |
| Red-Black Tree INSERT/DELETE/SEARCH | O(log n) worst case（不需攤銷） |

**BUILD-HEAP 的關鍵求和：**
```
Σ_{h=0}^{∞} h/2^h = 2
推導：Σ h·x^h = x/(1-x)²，代入 x = 1/2 得 2
```

---

## 🔰 Dynamic Array INSERT 攤銷分析：三種方法完整對照

以下用同一個例子（初始容量 1，連續插入 n 個元素，滿了就 double）分別用三種方法分析，讓你看到它們得出相同結論。

### 方法一：聚合法（Aggregate Method）

**思路：** 算出 n 次 INSERT 的總成本，再除以 n。

普通插入成本 = 1。擴容發生在第 1, 2, 3, 5, 9, 17, ... 次插入（即第 $2^i + 1$ 次），擴容時搬移的元素數 = 當前 table 大小。

```
總成本 = n 次普通插入 + 所有擴容的搬移成本
       = n + (1 + 2 + 4 + 8 + ... + 最後一次擴容的大小)
       ≤ n + (1 + 2 + 4 + ... + n)
       = n + 2n - 1    （等比級數求和）
       < 3n
```

**攤銷成本 = 總成本 / n < 3n / n = 3 = O(1)。**

### 方法二：記帳法（Accounting Method）

**思路：** 每次 INSERT 收費 3 元（而不是真實的 1 元），多的 2 元存起來當 credit。

- **普通 INSERT：** 真實花 1 元，收 3 元，存 2 元 credit。
- **擴容 INSERT：** 真實花 s+1 元（搬 s 個 + 插入 1 個），但 table 裡有 s 個元素，每個帶 2 元 credit，剛好能支付搬移成本。

**為什麼 credit 夠用？** 從上次擴容到這次擴容之間，table 從半滿長到全滿，插入了 s/2 個元素，每個帶 2 元 credit，共存了 s 元。擴容要搬 s 個元素花 s 元，剛好夠！

**結論：** 每次收 3 元就夠了 → 攤銷成本 = 3 = O(1)。

### 方法三：勢能法（Potential Method）

**思路：** 定義 $\Phi = 2 \cdot \text{num} - \text{size}$（num = 元素數，size = 容量）。

**普通 INSERT（不擴容）：**
$$\hat{c}_i = c_i + \Delta\Phi = 1 + [2(\text{num}+1) - \text{size}] - [2 \cdot \text{num} - \text{size}] = 1 + 2 = 3$$

**擴容 INSERT（num = size = s）：**
$$\hat{c}_i = (s+1) + [2(s+1) - 2s] - [2s - s] = (s+1) + 2 - s = 3$$

**兩種 case 攤銷成本都是 3 = O(1)！** 和前兩種方法一致。

> **🔰 三種方法的直覺對比：**
> - **聚合法：** 先算總帳再平均。最簡單，但只能得到統一的攤銷成本。
> - **記帳法：** 像存錢罐。便宜操作多存一點，貴操作用存款支付。直觀，但要確保存款永遠 ≥ 0。
> - **勢能法：** 像物理的位能。便宜操作讓勢能升高（蓄能），貴操作讓勢能降低（釋放能量）。最通用，但選對勢能函數需要經驗。

---

## 🔰 自我檢測

完成本章後，試著回答以下問題。如果有任何一題答不上來，建議回去重讀對應段落。

### 觀念題

1. **攤銷分析和平均情況分析有什麼區別？** 攤銷分析需要機率假設嗎？

2. **用自己的話解釋勢能法的核心公式 $\hat{c}_i = c_i + \Phi(D_i) - \Phi(D_{i-1})$。** 為什麼 $\Phi(D_n) \geq \Phi(D_0)$ 就能保證攤銷成本是合法的上界？

3. **Dynamic Table 為什麼縮容的門檻設在 1/4 而不是 1/2？** 如果設在 1/2 會怎樣？

4. **Union-Find 的 α(n) 在實際應用中大約等於多少？** 為什麼說它「幾乎是常數」？

5. **BUILD-HEAP 為什麼是 O(n) 而不是 O(n log n)？** 用直覺解釋。

### 計算題

6. 一個 4-bit Binary Counter 初始值為 0000，做 6 次 INCREMENT。用勢能法（$\Phi$ = 1 的個數）算出每步的 $c_i, \Phi_{\text{before}}, \Phi_{\text{after}}, \Delta\Phi, \hat{c}_i$。

7. 空的 Stack，操作序列為：PUSH(a), PUSH(b), PUSH(c), MULTIPOP(2), PUSH(d), PUSH(e), MULTIPOP(3)。
   - 用記帳法（PUSH 收 2 元，POP/MULTIPOP 收 0 元）驗證 credit 永遠 ≥ 0。
   - 用勢能法（$\Phi$ = 棧中元素數）計算每步的攤銷成本。

8. Dynamic Array 初始容量 = 1，連續做 5 次 INSERT。用勢能法 $\Phi = 2 \cdot \text{num} - \text{size}$ 計算每步的攤銷成本。驗證每步都是 3。

### 判斷題（True/False，並說明理由）

9. 「攤銷成本 O(1) 意味著每次操作的真實成本都是 O(1)。」

10. 「三種攤銷分析方法（聚合法、記帳法、勢能法）在數學上是等價的。」

11. 「Union-Find 只用 Union by Rank（不做 Path Compression），每次 FIND 是 O(log n)。」

12. 「BUILD-HEAP 用 bottom-up 方式是 O(n)，用 top-down（逐個 INSERT）方式也是 O(n)。」

### 參考答案提示

- 第 6 題：6 次 INCREMENT 後 counter = 000110，總翻轉 = 1+2+1+3+1+2 = 10，攤銷每步都 ≤ 2。
- 第 9 題：False。攤銷 O(1) 是「平均分攤到每次操作」的上界，某些操作的真實成本可能是 O(n)（如擴容）。
- 第 11 題：True。Union by Rank 保證樹高 ≤ log n，FIND 沿路徑走到根 = O(log n)。Path Compression 進一步降到 O(α(n))。
- 第 12 題：False。top-down 逐個 INSERT 是 O(n log n)。只有 bottom-up（sift-down）才是 O(n)。
