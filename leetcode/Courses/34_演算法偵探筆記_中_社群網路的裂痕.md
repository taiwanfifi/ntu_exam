# 演算法偵探筆記（中）— 社群網路的裂痕

> *「人跟人之間的關係，畫出來就是一張圖。*
> *而圖裡面如果有環——代表有人在繞圈子說謊。」—— 林凱*

---

## 前情提要

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  系計中的伺服器在凌晨 01:23:47 被入侵。                    │
│  一百萬筆選課資料被打亂（半完成的 heap sort）。             │
│  多出 2,627 筆重複資料，位置間距呈等比數列。               │
│                                                             │
│  這些重複資料的 course 欄位被竄改成「其他學號」。           │
│  它們不是 bug —— 它們是指標。                               │
│  有人在資料庫裡偷偷建了一張隱藏的「圖」。                   │
│                                                             │
│  現在，我們要把那張圖拆開。                                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 第一幕　早上九點的咖啡與圖論

睡了三個小時。感覺跟沒睡差不多。

我到系館的時候，阿翔已經在實驗室了。
這大概是我認識他以來，他第一次比我早到。

「我興奮到睡不著，」他說，手上拿著超商的罐裝咖啡，
眼睛底下的黑眼圈深到可以拿來當 dark mode。

學姊在角落的位置上，面前三台螢幕同時開著。
她看起來完全沒有睡過的痕跡。我合理懷疑她根本沒回去。

「坐下，」她說，「我整理了一下昨晚的東西。」

大螢幕亮起來。

```
╔══════════════════════════════════════════════════════════════╗
║  [ANALYSIS]  隱藏圖 — 從資料庫重複記錄中提取              ║
╠══════════════════════════════════════════════════════════════╣
║                                                              ║
║  提取方式：                                                  ║
║  每筆重複記錄 → (原始學號, 被竄改的 course 欄位)           ║
║  學號 A 的 course 被改成學號 B → 代表 A 指向 B              ║
║  → 一條有方向的邊：A → B                                    ║
║                                                              ║
║  提取結果：                                                  ║
║  • 節點數：1,847（不重複的學號）                            ║
║  • 邊數：  2,627（每筆重複記錄 = 一條邊）                  ║
║  • 類型：  有向圖（Directed Graph）                          ║
║                                                              ║
║  但這些學號代表的......不只是學號。                          ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
```

「我拿這些學號去比對學校的公開通訊錄，」學姊說。

她切到下一頁。

「這不是隨便一群學生。」

螢幕上列出了一些身份：

```
  #10001  陳彥廷  —  資工系教授（系統安全實驗室主持人）
  #10042  方志偉  —  資工系助教
  #10156  黃詩涵  —  資工系碩二（系統安全實驗室）
  #20301  劉建宏  —  電機系教授（嵌入式系統實驗室）
  #30087  鄭宇翔  —  資工系大四（校務系統開發團隊）
  #30512  林筱彤  —  資工系大三（校務系統開發團隊）
  #50742  ???     —  查無此人
  ...
```

「教授、助教、研究生、校務系統的開發者......」我喃喃自語。

「而且有一個學號查不到對應的人，」學姊指著 #50742。

阿翔放下咖啡：「幽靈帳號？」

「有可能。」

我盯著螢幕上那堆名字和箭頭。

一千八百多個人。兩千六百多條連結。
有方向的。A 指向 B 不代表 B 指向 A。

「所以......這就是一張圖？」阿翔問。

「這就是一張圖。」

---

### 1.1　什麼是圖？

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 偵探手札 #5 —— 用三十秒理解「圖」                      │
│                                                             │
│  圖（Graph）是最直覺的資料結構。因為現實世界到處都是圖。   │
│                                                             │
│  • 人際關係 → 人是節點，認識彼此是邊                        │
│  • 道路網路 → 路口是節點，道路是邊                          │
│  • 網頁連結 → 網頁是節點，超連結是邊                        │
│  • 課程擋修 → 課程是節點，「要先修 A 才能修 B」是邊        │
│                                                             │
│  圖只有兩個元素：                                           │
│  • 節點（Node / Vertex）：東西                              │
│  • 邊（Edge）：東西之間的關係                               │
│                                                             │
│  邊可以有方向（有向圖）或沒有方向（無向圖）。               │
│  邊可以有權重（加權圖）或沒有（等權圖）。                   │
│                                                             │
│  就這樣。沒了。圖就是「一堆東西 + 它們之間的關係」。       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

「好，」我說，「我們有一張圖了。然後呢？」

學姊靠回椅背：「你會怎麼開始？」

我想了想。

一千八百多個節點，兩千六百多條邊。
用肉眼看是不可能的。我需要系統性地走過這張圖。

「先搞清楚結構。這張圖是連在一起的，還是分成好幾塊？」

學姊微微點頭。

「如果分成好幾塊，每一塊可能代表不同的......群體。
不同的圈子。不同的陰謀。」

---

## 第二幕　有幾座島？

### 2.1　連通分量

一張圖裡，如果某些節點之間能互相到達，它們就是「連通」的。
反過來，如果兩個節點之間完全沒有路可以走，它們就是分開的。

```
  想像你站在一座群島上空往下看：

  ┌──────────────────────────────────────────────────────┐
  │                                                      │
  │      ┌─A──B─┐         E──F                          │
  │      │      │         │                              │
  │      C──D───┘         G                              │
  │                                                      │
  │                    H──I──J                            │
  │                    │     │                            │
  │                    K─────┘                            │
  │                                                      │
  │   島嶼 1: {A,B,C,D}    島嶼 2: {E,F,G}              │
  │                         島嶼 3: {H,I,J,K}            │
  │                                                      │
  │   三座島。島內的人可以互相到達。                      │
  │   島跟島之間，沒有橋。                                │
  │                                                      │
  └──────────────────────────────────────────────────────┘
```

每座「島」在圖論裡叫做一個 **Connected Component（連通分量）**。

問題來了——怎麼找出有幾座島，每座島上有誰？

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 暫停推理                                                │
│                                                             │
│  你面前有 1,847 個節點和 2,627 條邊。                       │
│  你看不到全貌。你只能做兩件事：                             │
│                                                             │
│  (1) 選一個節點，看它連到誰                                 │
│  (2) 從那些鄰居再往外看                                     │
│                                                             │
│  你會怎麼探索這張圖？                                       │
│                                                             │
│  想像你站在一座未知的島嶼上，四周被迷霧籠罩。               │
│  你要怎麼確認「這座島有多大、邊界在哪」？                   │
│                                                             │
│  想三十秒。                                                 │
└─────────────────────────────────────────────────────────────┘
```

---

### 2.2　兩種探索的哲學

阿翔搶先回答：「就從一個人開始，看他認識誰，
然後再看那些人認識誰，一圈一圈往外擴！」

他在白板上畫了個圖：

```
  阿翔的方法：一圈一圈往外

         第 0 圈：A（起點）
                  │
         第 1 圈：B, C（A 的鄰居）
                  │
         第 2 圈：D, E（B 和 C 的鄰居，扣掉已經見過的）
                  │
         第 3 圈：F（D 和 E 的鄰居，扣掉已經見過的）
                  │
         沒有新鄰居了 → 這座島探索完畢
```

「不錯，」學姊說，「這叫 BFS——Breadth-First Search。」

然後她看著我：「你呢？」

我想了一下。

「我的直覺不太一樣。如果是我，我會選一條路一直走下去，
走到死路再回頭。像是......探索迷宮的方式。」

```
  我的方法：一條路走到底

         A → B → D → F（死路！）
                      ↑
                      回頭到 D → 沒有其他路了
                      ↑
                      回頭到 B → 走 E → G（死路！）
                                         ↑
                                         回頭到 E → 沒了
                                         ↑
                                         回頭到 B → 沒了
                      ↑
                      回頭到 A → 走 C → ...
```

「這叫 DFS——Depth-First Search。」

兩種方法。兩種哲學。但都能把整座島走完。

---

### 2.3　但是——為什麼？

這是今天最重要的問題。

不是「BFS 和 DFS 是什麼」——那是定義，背就好。
而是：**為什麼這兩種方法都保證能走完整座島？**

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 偵探手札 #6 —— 為什麼 BFS/DFS 一定能走完？             │
│                                                             │
│  關鍵在一個簡單的機制：「去過的地方不再去」。               │
│                                                             │
│  visited = set()                                            │
│                                                             │
│  你每到一個節點，就在上面插一面旗子。                       │
│  之後看到有旗子的節點就跳過。                               │
│                                                             │
│  為什麼這樣就夠了？                                         │
│                                                             │
│  反證法：                                                   │
│  假設有一個節點 X 跟起點是連通的，但 BFS/DFS 沒走到它。    │
│  X 跟起點連通 → 存在一條路徑 S → ... → X。                 │
│  路徑上的每個節點都跟 S 連通。                              │
│  BFS/DFS 從 S 出發，會拜訪 S 的所有鄰居。                  │
│  那些鄰居的鄰居也會被拜訪。                                │
│  以此類推......路徑上的每個節點都會被碰到。                 │
│  所以 X 一定會被碰到。矛盾。                               │
│                                                             │
│  這就是為什麼 BFS 和 DFS 都「一定」能走完整座島。          │
│  只要圖是連通的、你有 visited 記錄，就不會漏掉任何人。     │
│                                                             │
│  那怎麼找到所有的島？                                       │
│                                                             │
│  for 每個節點:                                              │
│      if 它沒有被拜訪過:                                     │
│          從它出發做一次 BFS 或 DFS                           │
│          所有被拜訪到的節點 → 同一座島                      │
│          島的數量 += 1                                       │
│                                                             │
│  時間複雜度：O(V + E)，每個節點和每條邊各看一次。           │
│  就這麼簡單。                                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### 2.4　圖裡藏著什麼

學姊跑完了程式。結果出來了。

```
╔══════════════════════════════════════════════════════════════╗
║  連通分量分析結果                                           ║
╠══════════════════════════════════════════════════════════════╣
║                                                              ║
║  總節點數：1,847                                            ║
║  總邊數：  2,627                                            ║
║                                                              ║
║  連通分量數：5                                               ║
║                                                              ║
║  ┌────────────┬──────┬──────┬────────────────────────┐      ║
║  │ 島嶼編號   │ 節點 │  邊  │ 主要成員               │      ║
║  ├────────────┼──────┼──────┼────────────────────────┤      ║
║  │ 島嶼 #1    │  723 │ 1,041│ 資工系師生為主         │      ║
║  │ 島嶼 #2    │  456 │  612 │ 電機系 + 跨系修課生    │      ║
║  │ 島嶼 #3    │  389 │  507 │ 校務系統開發團隊       │      ║
║  │ 島嶼 #4    │  247 │  403 │ 混合（多系）           │      ║
║  │ 島嶼 #5    │   32 │   64 │ ???（含幽靈帳號#50742）│      ║
║  └────────────┴──────┴──────┴────────────────────────┘      ║
║                                                              ║
║  ⚠ 島嶼 #5 的邊數 / 節點數比異常高（2.0 vs 平均 1.4）     ║
║  ⚠ 島嶼 #5 包含幽靈帳號 #50742                             ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
```

「五座島，」我說，「五個群體。」

「前四座看起來正常。系上的人、電機的人、校務團隊、跨系的學生。
但第五座——」

「才 32 個人，卻有 64 條邊，」學姊說，「每個人平均被連了 4 條邊。
其他島平均不到 3 條。」

「而且那個查不到身份的 #50742 就在裡面。」

阿翔抓了抓頭：「所以......第五座島最可疑？」

「先別下結論，」我說，「我們應該先看看這座島長什麼樣子。」

---

## 第三幕　BFS——偵探的同心圓

### 3.1　從可疑的人開始

我們決定從幽靈帳號 #50742 開始，用 BFS 展開第五座島。

BFS 的邏輯就像往水裡丟一顆石頭——波紋一圈一圈往外擴。

```
  ┌─────────────────────────────────────────────────────────┐
  │                                                         │
  │  BFS 從 #50742 開始                                     │
  │                                                         │
  │  使用一個 Queue（先進先出）：                            │
  │                                                         │
  │  1. 把 #50742 丟進 queue                                │
  │  2. 從 queue 前面拿一個出來                              │
  │  3. 看它指向誰（鄰居）                                  │
  │  4. 沒拜訪過的鄰居 → 標記已拜訪 → 丟進 queue 後面      │
  │  5. 重複 2-4 直到 queue 空了                             │
  │                                                         │
  └─────────────────────────────────────────────────────────┘
```

學姊跑了 BFS，然後把結果用距離（離 #50742 幾步）來分層：

```
╔═══════════════════════════════════════════════════════════════╗
║  BFS 從 #50742 展開 — 第五座島的結構                        ║
╠═══════════════════════════════════════════════════════════════╣
║                                                               ║
║  距離 0：#50742（幽靈帳號）                                  ║
║     │                                                         ║
║     ├──→ #30087 鄭宇翔（校務系統開發）                       ║
║     ├──→ #10156 黃詩涵（系統安全實驗室碩二）                 ║
║     └──→ #40021 趙柏翰（資管系・身份待確認）                 ║
║                                                               ║
║  距離 1：3 人                                                 ║
║     │                                                         ║
║     ├──→ #30512 林筱彤（校務系統開發）      ← 從鄭宇翔來     ║
║     ├──→ #10042 方志偉（資工系助教）        ← 從黃詩涵來     ║
║     ├──→ #20301 劉建宏（電機系教授）        ← 從黃詩涵來     ║
║     ├──→ #40055 吳家豪（資管系碩一）        ← 從趙柏翰來     ║
║     └──→ ...（共 8 人）                                      ║
║                                                               ║
║  距離 2：8 人                                                 ║
║     │                                                         ║
║     ├──→ ...（共 12 人）                                     ║
║     └──→ #10001 陳彥廷（資工系教授）        ← 從方志偉來     ║
║                                                               ║
║  距離 3：12 人                                                ║
║     │                                                         ║
║     └──→ ...（共 9 人）                                      ║
║                                                               ║
║  距離 4 以上：無（島的直徑 = 4）                              ║
║                                                               ║
║  ┌─ 視覺化 ─────────────────────────────────────────────┐   ║
║  │                                                       │   ║
║  │                    #50742 (???)                        │   ║
║  │                   ╱   │    ╲                           │   ║
║  │               鄭宇翔 黃詩涵 趙柏翰                    │   ║
║  │              ╱  │    ╱  ╲     ╲                        │   ║
║  │          林筱彤  │ 方志偉 劉建宏 吳家豪                │   ║
║  │            │     │   │      │      │                   │   ║
║  │           ...   ... 陳彥廷  ...   ...                  │   ║
║  │                      │                                 │   ║
║  │                     ...                                │   ║
║  │                                                       │   ║
║  └───────────────────────────────────────────────────────┘   ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
```

---

### 3.2　為什麼 BFS 能保證「最短」？

我看著分層的結果，忽然意識到一件重要的事。

「學姊，BFS 算出來的距離——是最短距離嗎？」

「是。」

「為什麼？」

她看著我。等我自己想。

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 暫停推理                                                │
│                                                             │
│  BFS 一圈一圈往外擴，先發現的節點距離一定比較近。          │
│  這聽起來很直覺。但「直覺」不是「證明」。                   │
│                                                             │
│  想想看：為什麼一圈一圈擴就一定是最短路？                   │
│  有沒有可能先繞遠路反而更快到？                             │
│                                                             │
│  提示：想想 BFS 用的資料結構——Queue。                       │
│  Queue 是先進先出。這跟「最短」有什麼關係？                 │
│                                                             │
│  想三十秒。                                                 │
└─────────────────────────────────────────────────────────────┘
```

我在白板上寫：

```
  BFS 保證最短路的原因：

  Queue 是先進先出（FIFO）。
  先被發現的節點，先被處理。

  假設有兩條路可以到節點 X：
    路 1：S → A → X        （距離 2）
    路 2：S → B → C → X    （距離 3）

  BFS 的過程：
    第 0 圈：處理 S    → 發現 A, B（加入 queue）
    第 1 圈：處理 A    → 發現 X！標記距離 = 2
             處理 B    → 發現 C（加入 queue）
    第 2 圈：處理 X    → （已被標記，跳過）
             處理 C    → 看到 X 已拜訪 → 跳過

  因為 queue 是 FIFO，距離 1 的節點一定排在距離 2 的前面。
  距離 2 的一定排在距離 3 的前面。

  所以，第一次碰到 X 的路徑，一定是最短的。
  因為更短的路徑一定更早進 queue、更早被處理。

  如果有人先用距離 3 的路到達 X，
  那表示距離 1、2 的路都還沒處理完——
  但那不可能，因為 FIFO 保證距離小的先出來。

  結論：BFS + FIFO = 自動最短路。
```

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 偵探手札 #7 —— BFS 保證最短路的直覺                     │
│                                                             │
│  想像你站在池塘邊，丟一顆石頭進去。                         │
│                                                             │
│  水波一圈一圈往外擴散。                                     │
│  第 1 圈到的地方，就是距離 1。                              │
│  第 2 圈到的地方，就是距離 2。                              │
│                                                             │
│  水波不會跳過中間直接到外圈。                               │
│  它永遠是「近的先到、遠的後到」。                           │
│                                                             │
│  BFS 就是程式版的水波。                                     │
│  Queue 就是那個波紋——先進去的先處理。                       │
│                                                             │
│  但注意：這只在「每條邊的權重都相同」時成立。               │
│  如果有些路比較長、有些比較短（加權圖），                   │
│  那水波就不是等速擴散的了。                                 │
│  那時候你需要 Dijkstra——但那是後面的故事。                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

「所以，」我總結，「#50742 到陳彥廷教授的最短距離是 3 步。」

「意味著中間隔了兩個人，」學姊說。

「一個幽靈帳號，經過三步就能到達一位教授。在一個只有 32 人的小網路裡。」

阿翔打了個寒顫：「聽起來好像什麼秘密組織。」

我看著那張圖的視覺化。
有什麼不對。但我還說不上來。

---

## 第四幕　DFS——一條路走到黑

### 4.1　換一種方式看

BFS 讓我們看到了「這座島的形狀」——一圈一圈的同心圓。

但我想看另一種東西。我想看「路徑」。

從 #50742 出發，能走出多少條不同的路？每條路通向哪裡？

「用 DFS 吧，」我說。

DFS 和 BFS 的差別在哪？

```
  ┌─────────────────────────────────────────────────────────┐
  │                                                         │
  │  BFS（廣度優先）          DFS（深度優先）               │
  │                                                         │
  │  用 Queue（FIFO）         用 Stack（LIFO）              │
  │  → 先進先出               → 後進先出                    │
  │  → 一層一層展開            → 一條路走到底                │
  │                                                         │
  │  像水波                    像迷宮探險                    │
  │  ─────                    ─────                         │
  │                                                         │
  │  BFS 的視角：             DFS 的視角：                   │
  │                                                         │
  │       1                        1                        │
  │      ╱ ╲                      │                         │
  │     2   3      ← 一層層       2                         │
  │    ╱ ╲   ╲                    │                         │
  │   4   5   6                    4                         │
  │                                （死路，回頭）             │
  │  走訪順序：                    │                         │
  │  1 → 2 → 3 → 4 → 5 → 6      5                         │
  │                                （死路，回頭到 2）        │
  │                                回到 1 → 3 → 6           │
  │                                                         │
  │                                走訪順序：                │
  │                                1 → 2 → 4 → 5 → 3 → 6  │
  │                                                         │
  │  BFS 適合找「最短距離」       DFS 適合找「所有路徑」     │
  │  BFS 適合「這東西離我多遠」   DFS 適合「有沒有辦法到」   │
  │  BFS 需要記住整圈的人         DFS 只要記住這條路上的人   │
  │                                                         │
  └─────────────────────────────────────────────────────────┘
```

---

### 4.2　遞迴 = 隱形的 Stack

我開始寫 DFS 的程式。寫了幾行之後，阿翔湊過來看。

「等等——你沒有用 Stack 啊？你用的是遞迴。」

「遞迴本身就是一個 Stack。」

阿翔眨眨眼。

我在白板上畫：

```
  DFS 的遞迴版本：

  def dfs(node):
      visited.add(node)
      for neighbor in graph[node]:
          if neighbor not in visited:
              dfs(neighbor)        ← 呼叫自己

  每次呼叫 dfs()，系統就把當前狀態「推入」call stack。
  當遞迴 return，就從 call stack「彈出」回到上一層。

  ┌─────────────────────────────────────────────────┐
  │  Call Stack 的變化：                             │
  │                                                 │
  │  dfs(50742)                                     │
  │    └→ dfs(30087)                                │
  │        └→ dfs(30512)                            │
  │            └→ dfs(40088)     ← 死路，return     │
  │            回到 dfs(30512)                       │
  │            └→ dfs(40099)     ← 死路，return     │
  │        回到 dfs(30087)                           │
  │    回到 dfs(50742)                               │
  │    └→ dfs(10156)                                │
  │        └→ ...                                   │
  │                                                 │
  │  遞迴 = 你的程式自動幫你管理 Stack。             │
  │  不用遞迴？你就得自己管理一個 Stack。            │
  │  本質完全相同。                                  │
  └─────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 偵探手札 #8 —— 遞迴的本質就是 Stack                     │
│                                                             │
│  很多人覺得遞迴是「魔法」。其實不是。                       │
│                                                             │
│  遞迴 = 你把「記住現在的狀態 + 等下回來」這件事             │
│          交給了系統的 call stack。                           │
│                                                             │
│  不用遞迴的 DFS = 你自己拿一個 Stack，                      │
│          手動 push（進去）和 pop（出來）。                   │
│                                                             │
│  兩者在做完全一樣的事。                                     │
│  差別只在誰來管那個 Stack：系統還是你。                     │
│                                                             │
│  所以：                                                     │
│  • 遞迴的 call stack 太深 → Stack Overflow                  │
│  • 改用 iterative + 自己的 stack → 就不怕了                 │
│  • 這就是為什麼 Python 的遞迴限制是 1000 層                 │
│    但自己寫 stack 可以到上百萬                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

DFS 跑完了。我把所有路徑列出來——

然後我看到了。

---

## 第五幕　環——有人在說謊

### 5.1　不該存在的箭頭

DFS 走到某個時刻，撞上了一件奇怪的事。

```
╔══════════════════════════════════════════════════════════════╗
║  DFS 路徑追蹤 — 異常回報                                    ║
╠══════════════════════════════════════════════════════════════╣
║                                                              ║
║  當前路徑：                                                  ║
║  #50742 → #10156(黃詩涵) → #10042(方志偉) → #10001(陳彥廷) ║
║                                                              ║
║  從 #10001 的鄰居中，發現一條邊指向：                       ║
║                                                              ║
║       #10001 → #10156                                        ║
║                                                              ║
║  ⚠ #10156 已經在當前的 DFS 路徑上！                         ║
║                                                              ║
║  這代表：                                                    ║
║                                                              ║
║      #10156 → #10042 → #10001                                ║
║        ↑                   │                                 ║
║        └───────────────────┘                                 ║
║                                                              ║
║  🔴 偵測到環（Cycle）                                       ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
```

我的手指停在鍵盤上。

黃詩涵 → 方志偉 → 陳彥廷 → 黃詩涵。

碩士生指向助教。助教指向教授。教授又指回碩士生。

「有一個環，」我說。

阿翔：「環是什麼意思？」

「在有向圖裡，」我慢慢地說，「一條邊 A → B 代表 A 指向 B。
通常，指向關係是有層級的。教授指導助教，助教帶碩士生。
箭頭應該是單向的。」

我在白板上畫：

```
  正常的指導關係（無環）：

      教授
       ↓
      助教
       ↓
      碩士生

  我們發現的（有環）：

      碩士生(黃詩涵)
       ↓
      助教(方志偉) ──→ 教授(陳彥廷)
                              │
                              ↓
                        碩士生(黃詩涵)  ← 回來了！

  這代表什麼？

  如果邊代表「信任」或「授權」：
      碩士生授權助教、助教授權教授、教授又授權碩士生
      → 循環授權 → 沒有人是真正的源頭

  如果邊代表「傳遞資訊」：
      資訊在這三人之間無限循環
      → 它們之間有某種「回饋迴路」
```

---

### 5.2　環怎麼偵測的？

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 偵探手札 #9 —— 有向圖的環偵測                           │
│                                                             │
│  在 DFS 的過程中，每個節點有三種狀態：                      │
│                                                             │
│  ⬜ 未拜訪（WHITE）：還沒看過                                │
│  🟡 進行中（GRAY）：正在這條路徑上，還沒走完               │
│  ⬛ 已完成（BLACK）：這個節點和它的所有後代都看完了          │
│                                                             │
│  DFS 走訪時：                                               │
│  1. 進入一個節點 → 標記為 🟡                                │
│  2. 遞迴拜訪所有鄰居                                       │
│  3. 全部拜訪完 → 標記為 ⬛                                   │
│                                                             │
│  如果在走的時候，碰到一個 🟡 的節點——                       │
│  那代表你從那個節點出發，繞了一圈又回到它了。               │
│  → 環。                                                     │
│                                                             │
│  碰到 ⬛ 的節點呢？                                          │
│  那是已經走完的路。不是環，只是「殊途同歸」。               │
│                                                             │
│  ┌─────────────────────────────────────────┐               │
│  │  def dfs(node):                          │               │
│  │      color[node] = GRAY                  │               │
│  │      for neighbor in graph[node]:        │               │
│  │          if color[neighbor] == GRAY:     │               │
│  │              → 🔴 找到環了！              │               │
│  │          if color[neighbor] == WHITE:    │               │
│  │              dfs(neighbor)               │               │
│  │      color[node] = BLACK                 │               │
│  └─────────────────────────────────────────┘               │
│                                                             │
│  關鍵理解：                                                 │
│  🟡 = 「我正在探索這條路」                                  │
│  碰到 🟡 = 「我又回到正在走的這條路上了」= 環              │
│  碰到 ⬛ = 「這條路別人走過了，不關我的事」= 不是環         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

阿翔盯著白板上的三色標記，眉頭皺了很久，然後忽然鬆開：

「啊——我懂了。🟡 代表這個人還在你的『調查鏈』上。
如果你追著線索走，又碰到一個還在調查中的人——
那表示這條調查鏈本身就是一個圈。」

「完全正確。」學姊說。

她罕見地多說了兩個字。阿翔快樂得像中了樂透。

---

### 5.3　不只一個環

學姊把完整的環偵測跑完了。

```
╔══════════════════════════════════════════════════════════════╗
║  環偵測結果 — 島嶼 #5                                       ║
╠══════════════════════════════════════════════════════════════╣
║                                                              ║
║  找到 3 個環：                                               ║
║                                                              ║
║  環 A（3 人）：                                              ║
║  黃詩涵 → 方志偉 → 陳彥廷 → 黃詩涵                        ║
║  （碩士生 → 助教 → 教授 → 碩士生）                         ║
║                                                              ║
║  環 B（4 人）：                                              ║
║  趙柏翰 → 吳家豪 → 林筱彤 → 鄭宇翔 → 趙柏翰             ║
║  （資管碩 → 資管碩 → 校務開發 → 校務開發 → 資管碩）       ║
║                                                              ║
║  環 C（2 人）：                                              ║
║  #50742 → 鄭宇翔 → #50742                                  ║
║  （幽靈帳號 → 校務開發 → 幽靈帳號）                        ║
║                                                              ║
║  ┌─ 視覺化 ─────────────────────────────────────────────┐  ║
║  │                                                       │  ║
║  │        ┌──────→ 黃詩涵 ──────→ 方志偉               │  ║
║  │        │           ↑               │                  │  ║
║  │        │           └── 陳彥廷 ←────┘   ← 環 A        │  ║
║  │        │                                              │  ║
║  │     #50742 ←──→ 鄭宇翔 ←── 林筱彤          ← 環 C   │  ║
║  │                    ↑            ↑                     │  ║
║  │                    └── 趙柏翰 → 吳家豪      ← 環 B   │  ║
║  │                         ↑           │                 │  ║
║  │                         └───────────┘                 │  ║
║  │                                                       │  ║
║  └───────────────────────────────────────────────────────┘  ║
║                                                              ║
║  所有的環都跟 #50742 在同一座島上。                         ║
║  而且 #50742 自己就在一個環裡。                              ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
```

房間裡安靜了好幾秒。

「三個環，」我的聲音有點乾，「一個連著教授和實驗室的人，
一個連著校務系統的開發者，還有一個——直接連著幽靈帳號。」

「#50742 跟鄭宇翔互相指向，」學姊說，
「這是最小的環。雙向連結。」

「鄭宇翔......是校務系統開發團隊的，」阿翔翻著名單，
「他有伺服器的存取權限嗎？」

「校務系統開發團隊的成員，」吳教授忽然從門口走進來，
手上端著四杯咖啡，「當然有。他們要維護選課系統。」

我接過咖啡。腦子裡的拼圖開始浮現輪廓——但還差幾塊。

---

## 第六幕　派系——誰跟誰一國？

### 6.1　Union-Find

學姊指著其他四座島。

「第五座島最可疑，但其他四座也不能忽視。
如果犯人不只在第五座島活動呢？如果有些島之間存在隱藏的連結呢？」

「但你剛才不是說它們是分開的嗎？」阿翔問。

「以目前的邊來看是分開的。但如果有些邊的方向被故意反轉呢？
或者有些邊被刪掉了呢？」

她轉向螢幕：「我想做另一件事——把有向邊暫時當成無向的，
重新看分群情況。看看忽略方向之後，有沒有不同的結構浮現。」

「這樣的話，要重跑一次連通分量嗎？」我問。

「有更快的方式。」

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 偵探手札 #10 —— Union-Find（並查集）                    │
│                                                             │
│  問題：有 n 個人，陸續告訴你「A 和 B 是同一組」。          │
│  隨時可能被問：「A 和 C 是同一組嗎？」                     │
│                                                             │
│  天真的方法：每次有新關係就重新跑 BFS → 太慢              │
│                                                             │
│  Union-Find：每一組選一個「代表人」。                       │
│                                                             │
│  ┌──────────────────────────────────────────┐              │
│  │  一開始：每個人自成一組，自己是自己的代表 │              │
│  │                                          │              │
│  │  [A] [B] [C] [D] [E] [F] [G]            │              │
│  │   代表各自是自己                          │              │
│  │                                          │              │
│  │  Union(A, B)：A 和 B 合併                │              │
│  │  → B 的代表改成 A（或反過來）             │              │
│  │                                          │              │
│  │  [A] [C] [D] [E] [F] [G]                │              │
│  │   ↑                                      │              │
│  │  [B]                                     │              │
│  │                                          │              │
│  │  Union(C, D)：                           │              │
│  │  [A] [C] [E] [F] [G]                    │              │
│  │   ↑   ↑                                  │              │
│  │  [B] [D]                                 │              │
│  │                                          │              │
│  │  Union(A, C)：A 的代表 = A，C 的代表 = C │              │
│  │  → 把 C 接到 A 底下                      │              │
│  │  [A]   [E] [F] [G]                      │              │
│  │  ↑ ↑                                     │              │
│  │ [B][C]                                   │              │
│  │     ↑                                    │              │
│  │    [D]                                   │              │
│  │                                          │              │
│  │  Find(D) = ?                             │              │
│  │  D → C → A。代表是 A。                   │              │
│  │                                          │              │
│  │  Find(B) = ?                             │              │
│  │  B → A。代表也是 A。                     │              │
│  │                                          │              │
│  │  → D 和 B 同一組！（因為代表相同）       │              │
│  └──────────────────────────────────────────┘              │
│                                                             │
│  兩個關鍵優化：                                             │
│                                                             │
│  1. 路徑壓縮（Path Compression）：                          │
│     Find(D) 走了 D → C → A 三步。                          │
│     之後直接把 D 接到 A → 下次 Find(D) 只要一步。          │
│                                                             │
│     Before:  A ← C ← D                                     │
│     After:   A ← C                                          │
│              A ← D       （D 直接指向 A）                   │
│                                                             │
│  2. 按秩合併（Union by Rank）：                             │
│     合併兩組時，把矮的樹接到高的樹上。                     │
│     → 樹永遠不會太深 → Find 永遠很快。                     │
│                                                             │
│  兩個優化一起用 → 幾乎 O(1) per operation                  │
│  （嚴格來說是 O(α(n))，α 是反 Ackermann 函數，             │
│    對任何實際的 n 都 ≤ 4。比常數大不了多少。）             │
│                                                             │
│  為什麼這麼快？                                             │
│  因為每次 Find 都在壓縮路徑。                               │
│  用得越多，樹越扁。                                         │
│  它是一個「越用越快」的資料結構。                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### 6.2　合併之後

學姊用 Union-Find 把所有邊當無向來處理。結果令人意外：

```
╔══════════════════════════════════════════════════════════════╗
║  Union-Find 結果（忽略邊的方向）                            ║
╠══════════════════════════════════════════════════════════════╣
║                                                              ║
║  原本 5 座島 → 忽略方向後仍然是 5 座島                     ║
║                                                              ║
║  但是！島嶼 #4（247 人，混合多系）出現了新發現：            ║
║                                                              ║
║  島嶼 #4 內部有明顯的「子群落」：                           ║
║                                                              ║
║  ┌──────────────────────────────────────────────────┐      ║
║  │                                                  │      ║
║  │  子群 4a：73 人 ── 幾乎全是大三大四              │      ║
║  │     │                                             │      ║
║  │     └──（只有 2 條邊連到 4b）                    │      ║
║  │                                                  │      ║
║  │  子群 4b：98 人 ── 混合年級                      │      ║
║  │     │                                             │      ║
║  │     └──（只有 1 條邊連到 4c）                    │      ║
║  │                                                  │      ║
║  │  子群 4c：76 人 ── 幾乎全是研究生                │      ║
║  │                                                  │      ║
║  │  如果刪掉那 3 條橋接邊 → 三個子群各自獨立       │      ║
║  │                                                  │      ║
║  └──────────────────────────────────────────────────┘      ║
║                                                              ║
║  那 3 條橋接邊經過的人：                                     ║
║    • 鄭宇翔（#30087）← 校務開發，也在島嶼 #5               ║
║                                                              ║
║  等等——鄭宇翔同時出現在島嶼 #4 和 #5？                     ║
║                                                              ║
║  ⚠ 重新檢查：鄭宇翔在有向圖中有兩個身份。                 ║
║    在島嶼 #5 他是被指向的人。                                ║
║    在島嶼 #4 他是橋接不同子群的關鍵節點。                   ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
```

「鄭宇翔，」我說出聲，「他是橋。」

「在圖論裡叫 bridge 或 articulation point，」學姊補充，
「拿掉他，整個子群的結構就碎了。」

「一個校務系統開發者，同時出現在可疑的第五座島，
又是第四座島的關鍵橋接點。他連接了不同的群體。」

吳教授放下咖啡杯，表情變得嚴肅。

「鄭宇翔上個月申請過一次非常規的資料庫權限升級。
我當時核准了，因為他說是為了系統維護。」

房間裡又安靜了。

---

## 第七幕　最短路徑——犯人的足跡

### 7.1　如果每一步的代價不同？

我們有了嫌疑人。但我需要更多證據。

我回到那張圖。如果邊不只是「有沒有連」，還有「強度」呢？

學姊似乎想到了同樣的事。

「我剛才仔細看了那些被竄改的 course 欄位，」她說，
「有些不只包含學號，還包含一個時間戳。
時間戳的差值可以當作邊的權重——代表兩筆操作之間的時間間隔。」

時間間隔短 = 操作密集 = 關係更緊密。
時間間隔長 = 偶爾聯繫 = 關係鬆散。

「這變成加權圖了。」

```
  ┌────────────────────────────────────────────────────────┐
  │                                                        │
  │  之前：無權重                  現在：有權重             │
  │                                                        │
  │  A ──→ B                     A ──3──→ B                │
  │  │      │                     │         │              │
  │  ↓      ↓                     5         1              │
  │  C ──→ D                     ↓         ↓              │
  │                               C ──2──→ D               │
  │  BFS 可以找最短路             BFS 不行了！              │
  │  （每條邊都是 1）             （邊的長度不同）          │
  │                                                        │
  └────────────────────────────────────────────────────────┘
```

BFS 在等權圖上保證最短路。但現在每條邊的「距離」不同了。

BFS 的水波假設每條邊等長。
如果有些路短、有些路長，水波就不是均勻擴散的了。

「我們需要 Dijkstra，」學姊說。

---

### 7.2　Dijkstra——貪心的旅人

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 暫停推理                                                │
│                                                             │
│  你在一張有權重的地圖上。                                   │
│  想找從 S 到所有其他點的最短路。                            │
│  每條路有不同的長度。                                       │
│                                                             │
│  BFS 的「一圈一圈」不管用了。                               │
│  因為走兩步短邊可能比走一步長邊更近。                       │
│                                                             │
│  那該怎麼辦？                                               │
│                                                             │
│  提示：如果你永遠先處理「目前離起點最近的那個人」，         │
│  會發生什麼？                                               │
│                                                             │
│  想三十秒。                                                 │
└─────────────────────────────────────────────────────────────┘
```

Dijkstra 的直覺其實很簡單：

**永遠先處理離起點最近的未確定節點。**

```
  ╔══════════════════════════════════════════════════════════╗
  ║  Dijkstra 演算法 — 用一個例子走一遍                     ║
  ╠══════════════════════════════════════════════════════════╣
  ║                                                          ║
  ║  圖：                                                    ║
  ║          2                                               ║
  ║     S ──────→ A                                          ║
  ║     │         │                                          ║
  ║     5         1                                          ║
  ║     │         │                                          ║
  ║     ↓         ↓                                          ║
  ║     B ──────→ C                                          ║
  ║          3                                               ║
  ║                                                          ║
  ║  S → A 的直接距離：2                                     ║
  ║  S → B 的直接距離：5                                     ║
  ║  S → A → C 的距離：2 + 1 = 3                            ║
  ║  S → B → C 的距離：5 + 3 = 8                            ║
  ║  最短到 C：3（經過 A）                                   ║
  ║                                                          ║
  ║  步驟：                                                  ║
  ║                                                          ║
  ║  1. 起始：dist[S]=0, 其他=∞                              ║
  ║     Heap: [(0, S)]                                       ║
  ║                                                          ║
  ║  2. 取出最近的：S (dist=0)                               ║
  ║     更新鄰居：dist[A]=2, dist[B]=5                       ║
  ║     Heap: [(2, A), (5, B)]                               ║
  ║                                                          ║
  ║  3. 取出最近的：A (dist=2)  ✓ 確定了                     ║
  ║     更新鄰居：dist[C]=2+1=3                              ║
  ║     Heap: [(3, C), (5, B)]                               ║
  ║                                                          ║
  ║  4. 取出最近的：C (dist=3)  ✓ 確定了                     ║
  ║     C 沒有鄰居                                           ║
  ║     Heap: [(5, B)]                                       ║
  ║                                                          ║
  ║  5. 取出最近的：B (dist=5)  ✓ 確定了                     ║
  ║     B → C：5+3=8 > 3（已經有更短的）→ 不更新            ║
  ║                                                          ║
  ║  結果：S→A=2, S→B=5, S→C=3                              ║
  ╚══════════════════════════════════════════════════════════╝
```

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 偵探手札 #11 —— Dijkstra 為什麼有效？                   │
│                                                             │
│  核心保證：當你從 heap 取出一個節點時，                     │
│  它的距離已經是最短的了。不會再被更新。                     │
│                                                             │
│  為什麼？                                                   │
│                                                             │
│  你取出的是「目前所有候選人中距離最小的」。                 │
│  還沒被取出的候選人，距離都 ≥ 它。                          │
│  未來新發現的路徑，只可能更長（因為邊權 ≥ 0）。            │
│  所以不可能有更短的路經過還沒處理的節點到達它。             │
│                                                             │
│  這就是為什麼 Dijkstra 要求邊權不能是負的。                │
│  如果有負權邊，「未來的路可能更短」這個假設就崩了。         │
│                                                             │
│  BFS vs Dijkstra：                                          │
│  • BFS 用 Queue（FIFO）→ 等權圖的最短路                    │
│  • Dijkstra 用 Heap（最小優先）→ 加權圖的最短路            │
│  • 本質一樣：都是「先處理近的」                             │
│  • BFS 是 Dijkstra 的特例（所有邊權 = 1 時）               │
│                                                             │
│  用 Heap 的 Dijkstra：O((V + E) log V)                     │
│  因為每次從 heap 取最小值是 O(log V)。                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### 7.3　犯人的最短路

學姊跑了 Dijkstra，以 #50742 為起點。

```
╔══════════════════════════════════════════════════════════════╗
║  Dijkstra 結果：從 #50742 到所有節點的最短加權距離          ║
╠══════════════════════════════════════════════════════════════╣
║                                                              ║
║  最短路到資料庫管理員帳號群組：                              ║
║                                                              ║
║  #50742 → #30087(鄭宇翔) → #30512(林筱彤)                  ║
║  → #10042(方志偉) → #10001(陳彥廷)                          ║
║                                                              ║
║  加權距離：3 + 7 + 2 + 12 = 24                              ║
║                                                              ║
║  但有另一條路：                                              ║
║  #50742 → #10156(黃詩涵) → #10042(方志偉) → #10001(陳彥廷) ║
║                                                              ║
║  加權距離：5 + 1 + 12 = 18  ← 更短！                       ║
║                                                              ║
║  ┌─ 最短路徑視覺化 ────────────────────────────────────┐   ║
║  │                                                      │   ║
║  │  #50742 ───(5)──→ 黃詩涵 ───(1)──→ 方志偉          │   ║
║  │                                       │              │   ║
║  │                                      (12)            │   ║
║  │                                       │              │   ║
║  │                                       ↓              │   ║
║  │                                    陳彥廷             │   ║
║  │                                                      │   ║
║  │  總距離：18（最短）                                  │   ║
║  │                                                      │   ║
║  └──────────────────────────────────────────────────────┘   ║
║                                                              ║
║  注意：最短路恰好經過 環 A 的成員。                         ║
║  黃詩涵 → 方志偉 → 陳彥廷 就是環 A 的三個人。             ║
║  犯人利用了這個環。                                          ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
```

我盯著結果。

「犯人從幽靈帳號出發，走最短路到達教授帳號。
而這條最短路剛好經過那三個形成環的人。」

「不是巧合，」學姊說，
「這個環本來就是為了提供一條捷徑而建立的。
環裡的人互相授權，形成一個信任迴路。
任何人只要進入環的任何一個節點，就能以最短的代價到達所有其他成員。」

她頓了一下。

「這是一個精心設計的攻擊路徑。」

---

## 第八幕　拓撲排序——事情的先後順序

### 8.1　入侵的步驟

吳教授一直在旁邊默默聽著。現在他開口了。

「我查了伺服器的操作日誌。入侵者執行了一系列操作，每個操作都有前置條件。」

他把日誌投到螢幕上。

```
╔══════════════════════════════════════════════════════════════╗
║  入侵操作序列（從日誌還原）                                 ║
╠══════════════════════════════════════════════════════════════╣
║                                                              ║
║  操作 A：取得系統使用者列表                                  ║
║  操作 B：取得校務資料庫 read 權限     （需要先完成 A）      ║
║  操作 C：建立幽靈帳號 #50742          （需要先完成 A）      ║
║  操作 D：複製選課資料                  （需要先完成 B）      ║
║  操作 E：植入隱藏圖的節點             （需要先完成 B, C）    ║
║  操作 F：執行 heap sort 打亂資料      （需要先完成 D, E）   ║
║  操作 G：清除操作痕跡                  （需要先完成 F）      ║
║                                                              ║
║  依賴關係：                                                  ║
║                                                              ║
║     A → B → D ──┐                                           ║
║     │            │                                           ║
║     └→ C ──┐    │                                           ║
║             ↓    ↓                                           ║
║             E ──→ F → G                                     ║
║                                                              ║
║  問題：這些操作的合法執行順序是什麼？                        ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
```

「這是一個依賴圖，」我說，
「有些事情一定要在另一些事情之前完成。就像修課的擋修一樣。」

「你不能在修完微積分之前修線性代數，」阿翔難得貢獻了一個好比喻。

「沒錯。我們需要找一個合法的順序——
滿足所有依賴關係的線性排列。」

這就是 **Topological Sort（拓撲排序）**。

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 偵探手札 #12 —— 拓撲排序                                │
│                                                             │
│  前提：圖必須是 DAG（有向無環圖）。                         │
│  如果有環 → 不可能排出合法順序（A 要在 B 前面，            │
│  B 又要在 A 前面 → 矛盾）。                                │
│                                                             │
│  方法（Kahn's Algorithm / BFS 版）：                        │
│                                                             │
│  1. 算每個節點的 in-degree（有幾條邊指向它）                │
│  2. in-degree = 0 的節點 → 沒有前置條件 → 放入 queue       │
│  3. 從 queue 取一個出來，加入結果序列                       │
│  4. 把它指向的所有節點的 in-degree 減 1                     │
│  5. 如果某個節點的 in-degree 變成 0 → 放入 queue           │
│  6. 重複直到 queue 空了                                     │
│                                                             │
│  走一遍入侵操作：                                           │
│                                                             │
│  初始 in-degree：                                           │
│  A=0  B=1  C=1  D=1  E=2  F=2  G=1                        │
│                                                             │
│  Step 1: A(in=0) → 取出 A → 結果 [A]                      │
│          B 的 in 減到 0，C 的 in 減到 0                     │
│  Step 2: B(in=0) → 取出 B → 結果 [A, B]                   │
│          D 的 in 減到 0                                     │
│  Step 3: C(in=0) → 取出 C → 結果 [A, B, C]                │
│          E 的 in 減到 1                                     │
│  Step 4: D(in=0) → 取出 D → 結果 [A, B, C, D]             │
│          F 的 in 減到 1                                     │
│  Step 5: E(in=0？不對，E 的 in 是 1）                      │
│          E 需要 B 和 C，B 已處理，C 已處理 → in=0          │
│          取出 E → 結果 [A, B, C, D, E]                     │
│          F 的 in 減到 0                                     │
│  Step 6: F(in=0) → 取出 F → 結果 [A, B, C, D, E, F]      │
│          G 的 in 減到 0                                     │
│  Step 7: G(in=0) → 取出 G → 結果 [A, B, C, D, E, F, G]   │
│                                                             │
│  合法的執行順序：A → B → C → D → E → F → G               │
│  （注意：B 和 C 的順序可以交換，D 和 C 也可以。            │
│   拓撲排序不唯一，但都合法。）                              │
│                                                             │
│  關鍵直覺：                                                 │
│  in-degree = 0 意味著「所有前置條件都滿足了」。             │
│  每處理一個節點，就「解鎖」它的後繼。                       │
│  像是推倒骨牌——倒了一張，後面的才能倒。                     │
│                                                             │
│  這跟遊戲裡的「科技樹」完全一樣。                           │
│  你不能跳過前置科技直接研究終極武器。                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### 8.2　重建犯罪時間線

我們用拓撲排序重建了入侵者的操作順序。

再對照伺服器日誌的時間戳——

「01:23:47 取得使用者列表。01:24:12 建立幽靈帳號。
01:24:30 取得資料庫權限......」

「從取得權限到植入完隱藏圖，只花了七分鐘，」學姊說，
「要嘛是事先寫好了腳本，要嘛——」

「要嘛是對系統極其熟悉的人，」吳教授接話。

我們三個人看著吳教授。他慢慢點了頭。

「鄭宇翔。校務系統開發者。有資料庫全部權限。
上個月申請過權限升級。而且——」

他看向學姊的螢幕。

「而且幽靈帳號 #50742 跟他形成了雙向連結。
那個帳號就是他創造的，他自己的後門。」

阿翔猛地站起來：「那我們去找他啊！」

「等等，」我抬手制止他。

因為有什麼東西不對。

我重新看了一眼那張圖。
那些環。那些精心設計的最短路徑。那個半完成的 heap sort。

「如果他是犯人，」我慢慢說，「他為什麼只做了一半？」

學姊轉過來看我。

「Heap sort 沒做完。日誌顯示操作在 01:31:22 中斷了。
不是被系統擋住，是操作者自己停下來的。
如果他有腳本，如果他準備充分——為什麼中途放棄？」

房間裡又安靜了。

「而且，」我繼續說，「他藏了一張圖在資料庫裡。
如果目的是破壞，幹嘛留下這麼精緻的結構？
這張圖連 Dijkstra 最短路都算好了。
這不像犯罪，更像是——」

「一道題目，」學姊說。

她的眼神變了。從分析者的冷靜，變成了——某種我辨認不出的情緒。

「有人在資料庫裡出了一道題。」

她指著那張圖。

「環、最短路徑、連通分量、拓撲排序的操作序列......
這些不是攻擊的痕跡。」

「這是一場考試。」

我看了一眼時鐘。上午十一點四十七分。

窗外陽光正好。但我感覺這個案子，反而越來越暗了。

---

## 偵探手札　第二日總結

```
╔══════════════════════════════════════════════════════════════╗
║                                                              ║
║   ┌─────────────────────────────────────────────────────┐   ║
║   │         📓 偵 探 手 札 — 第 二 日                    │   ║
║   └─────────────────────────────────────────────────────┘   ║
║                                                              ║
║   案件進展：                                                 ║
║                                                              ║
║   ─── 今日查明 ───                                           ║
║                                                              ║
║   1. 隱藏圖結構                                              ║
║      1,847 節點 / 2,627 邊 / 有向圖                          ║
║      對應真實身份：教授、助教、學生、開發者                   ║
║                                                              ║
║   2. 五座島（連通分量）                                      ║
║      方法：BFS/DFS 遍歷 + visited 去重                       ║
║      洞見：任何不回頭的遍歷，只要有 visited，                ║
║            就保證走完整座連通的島                             ║
║                                                              ║
║   3. BFS 分層 → 最短距離（等權圖）                           ║
║      Queue 的 FIFO 性質保證近的先到                          ║
║      等價於水波的均勻擴散                                    ║
║                                                              ║
║   4. DFS 探路 → 發現三個環                                   ║
║      三色標記：WHITE / GRAY / BLACK                          ║
║      碰到 GRAY = 正在這條路上 = 環                           ║
║                                                              ║
║   5. Union-Find → 快速分群                                   ║
║      路徑壓縮 + 按秩合併 → 幾乎 O(1)                        ║
║      越用越快（路徑壓縮的自我優化）                           ║
║      發現鄭宇翔是跨島的「橋」                                ║
║                                                              ║
║   6. Dijkstra → 加權最短路                                   ║
║      BFS 的升級版。用 Heap 取代 Queue。                      ║
║      先處理最近的 → 保證取出時已最短。                       ║
║      前提：邊權不能為負。                                    ║
║                                                              ║
║   7. 拓撲排序 → 重建犯罪順序                                 ║
║      DAG 上的合法線性順序                                    ║
║      Kahn's：反覆取 in-degree = 0 的節點                    ║
║      像推倒骨牌 / 科技樹解鎖                                 ║
║                                                              ║
║   ─── 新的謎團 ───                                           ║
║                                                              ║
║   • 嫌疑人鄭宇翔為何中途停止？                               ║
║   • 隱藏的圖結構太精緻——不像破壞，像出題                     ║
║   • 學姊說：「這是一場考試。」什麼意思？                     ║
║   • 是誰的考試？考誰的？                                     ║
║                                                              ║
║   ─── 今日學到的事 ───                                       ║
║                                                              ║
║   「圖，是現實世界最自然的抽象。                             ║
║     人跟人之間、事跟事之間、因跟果之間，                     ║
║     全都是節點和邊。                                         ║
║                                                              ║
║     而走過一張圖的方式，                                     ║
║     決定了你能看到什麼：                                     ║
║     BFS 讓你看到距離。                                       ║
║     DFS 讓你看到路徑。                                       ║
║     Union-Find 讓你看到派系。                                ║
║     Dijkstra 讓你看到最佳路線。                              ║
║     拓撲排序讓你看到因果。                                   ║
║                                                              ║
║     同一張圖，五種視角，五種真相。                           ║
║     也許——破案也是這樣。」                                   ║
║                                                              ║
║                             —— 林凱，12:03 寫於系館實驗室    ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
```

---

> **下集預告**
>
> *「這是一場考試」—— 學姊的這句話，打開了一扇門。*
>
> *如果犯人不是在破壞，而是在出題——*
> *那這道題的「答案」，可能就藏在那個半完成的 heap sort 裡。*
>
> *但要還原那個答案，我們得回到過去。*
> *在伺服器日誌的時間線上，一步一步倒推。*
> *每一步都依賴上一步的結果。*
> *每一個選擇都不能反悔。*
>
> *——這聽起來像什麼？*
>
> *「Dynamic Programming，」學姊說。*
> *「用過去的答案，拼出未來的路。」*
>
> *《演算法偵探筆記（下）— 時間迴廊的最後推理》，待續。*
