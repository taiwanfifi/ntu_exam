# EP09 — 前後端開發實戰：從 Python 到 Full-Stack

> **對象讀者**：已熟悉 Python 的開發者，想從後端 API 一路學到前端 React，
> 最終能獨立完成一個前後端分離的 Web 應用。本篇以實戰為核心，每個章節都有完整可執行程式碼。

---

## 目錄

1. [網頁運作原理](#1-網頁運作原理)
2. [Python 後端 — Flask](#2-python-後端--flask)
3. [Python 後端 — FastAPI](#3-python-後端--fastapi--推薦)
4. [資料庫基礎](#4-資料庫基礎)
5. [HTML/CSS 基礎](#5-htmlcss-基礎-前端必備)
6. [JavaScript 前端互動](#6-javascript-前端互動)
7. [React 入門](#7-react-入門-)
8. [TypeScript + React](#8-typescript--react)
9. [前後端整合實戰](#9-前後端整合實戰)
10. [API 安全性](#10-api-安全性)
11. [部署](#11-部署)
12. [現代前端工具鏈](#12-現代前端工具鏈)

---

## 1. 網頁運作原理

### 1.1 HTTP 請求/回應 (Request / Response)

每一次你在瀏覽器輸入網址，背後都是一個 **HTTP 交易**：

```
┌──────────┐   HTTP Request    ┌──────────┐    SQL Query    ┌──────────┐
│          │ ───────────────→  │          │ ─────────────→  │          │
│  前端    │                    │  後端    │                  │  資料庫  │
│ (瀏覽器) │ ←───────────────  │ (Server) │ ←─────────────  │ (DB)     │
│          │   HTTP Response   │          │   Query Result  │          │
└──────────┘                    └──────────┘                  └──────────┘
```

### 1.2 HTTP 方法 (Methods)

```
方法      用途                  是否帶 Body    冪等性
────────────────────────────────────────────────────
GET       取得資源              否             是
POST      新建資源              是             否
PUT       完整更新資源          是             是
PATCH     部分更新資源          是             否*
DELETE    刪除資源              通常否         是
```

```python
# Python requests 模組示範各種 HTTP 方法
import requests

BASE = "https://jsonplaceholder.typicode.com"

# GET — 取得所有使用者
resp = requests.get(f"{BASE}/users")
print(resp.status_code)  # 200
print(resp.json()[:2])   # 前兩筆資料

# POST — 新建一篇文章
resp = requests.post(f"{BASE}/posts", json={
    "title": "我的第一篇文章",
    "body": "Hello World",
    "userId": 1
})
print(resp.status_code)  # 201 Created
print(resp.json()["id"]) # 新建的 ID

# PUT — 完整更新（覆蓋整筆資料）
resp = requests.put(f"{BASE}/posts/1", json={
    "id": 1,
    "title": "更新後的標題",
    "body": "更新後的內容",
    "userId": 1
})
print(resp.status_code)  # 200

# PATCH — 部分更新（只改指定欄位）
resp = requests.patch(f"{BASE}/posts/1", json={
    "title": "只改標題"
})
print(resp.status_code)  # 200

# DELETE — 刪除資源
resp = requests.delete(f"{BASE}/posts/1")
print(resp.status_code)  # 200
```

### 1.3 HTTP 狀態碼 (Status Codes)

```
狀態碼    類別        意義                    常見場景
──────────────────────────────────────────────────────────
200       成功        OK                      GET/PUT/PATCH 成功
201       成功        Created                 POST 新建成功
301       重導向      Moved Permanently       網址永久搬遷
400       客戶端錯誤  Bad Request             參數格式錯誤
401       客戶端錯誤  Unauthorized            未提供認證 Token
403       客戶端錯誤  Forbidden               權限不足
404       客戶端錯誤  Not Found               資源不存在
500       伺服器錯誤  Internal Server Error   後端程式 bug
```

### 1.4 Headers, Body, Query Parameters

```python
import requests

# --- Headers ---
# 告訴伺服器「我送的是 JSON」「我的身份是 xxx」
headers = {
    "Content-Type": "application/json",
    "Authorization": "Bearer eyJhbGciOiJIUzI1NiIs..."
}

# --- Query Parameters ---
# GET /users?page=2&limit=10
resp = requests.get("https://api.example.com/users", params={
    "page": 2,
    "limit": 10
})
# 實際 URL: https://api.example.com/users?page=2&limit=10

# --- Request Body (JSON) ---
resp = requests.post("https://api.example.com/users",
    headers=headers,
    json={
        "name": "Alice",
        "email": "alice@example.com"
    }
)
```

### 1.5 JSON 格式

```python
import json

# Python dict ↔ JSON 互轉
data = {
    "name": "Alice",
    "age": 30,
    "skills": ["Python", "React", "SQL"],
    "address": {
        "city": "Taipei",
        "zip": "100"
    },
    "is_active": True,    # JSON 會變成 true (小寫)
    "score": None          # JSON 會變成 null
}

# dict → JSON 字串
json_str = json.dumps(data, ensure_ascii=False, indent=2)
print(json_str)

# JSON 字串 → dict
parsed = json.loads(json_str)
print(parsed["name"])  # "Alice"
```

### 1.6 REST API 設計原則

```
資源        方法      路徑                  說明
─────────────────────────────────────────────────────
使用者      GET       /api/users            取得所有使用者
            GET       /api/users/42         取得 ID=42 的使用者
            POST      /api/users            新建使用者
            PUT       /api/users/42         完整更新使用者
            PATCH     /api/users/42         部分更新使用者
            DELETE    /api/users/42         刪除使用者

使用者的文章 GET      /api/users/42/posts   取得該使用者的所有文章
```

**設計原則**：
- 路徑用**名詞**（`/users`），不用動詞（不要 `/getUsers`）
- 複數形式（`/users` 而非 `/user`）
- 用 HTTP 方法區分操作
- 版本化：`/api/v1/users`
- 巢狀資源不超過兩層

---

## 2. Python 後端 — Flask

### 2.1 最小 Flask App（5 行）

```python
from flask import Flask

app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello, World!"

# 執行: flask run 或 python app.py
if __name__ == "__main__":
    app.run(debug=True, port=5000)
```

### 2.2 路由與方法

```python
from flask import Flask, request, jsonify

app = Flask(__name__)

# 基本路由
@app.route("/")
def index():
    return jsonify({"message": "歡迎來到首頁"})

# 路徑參數
@app.route("/users/<int:user_id>")
def get_user(user_id):
    return jsonify({"user_id": user_id})

# 指定 HTTP 方法
@app.route("/users", methods=["GET", "POST"])
def users():
    if request.method == "GET":
        return jsonify({"action": "列出所有使用者"})
    elif request.method == "POST":
        data = request.json  # 取得 JSON body
        return jsonify({"action": "新建使用者", "data": data}), 201
```

### 2.3 請求處理

```python
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route("/search")
def search():
    # Query Parameters: /search?q=python&page=1
    keyword = request.args.get("q", "")
    page = request.args.get("page", 1, type=int)
    return jsonify({"keyword": keyword, "page": page})

@app.route("/submit", methods=["POST"])
def submit():
    # JSON Body
    data = request.json
    name = data.get("name")
    email = data.get("email")
    return jsonify({"received": {"name": name, "email": email}})

@app.route("/upload", methods=["POST"])
def upload():
    # Form Data
    name = request.form.get("name")
    file = request.files.get("file")
    if file:
        file.save(f"./uploads/{file.filename}")
    return jsonify({"name": name, "filename": file.filename if file else None})
```

### 2.4 Blueprint 模組化

```python
# blueprints/users.py
from flask import Blueprint, jsonify, request

users_bp = Blueprint("users", __name__, url_prefix="/api/users")

@users_bp.route("/", methods=["GET"])
def list_users():
    return jsonify({"users": []})

@users_bp.route("/<int:uid>", methods=["GET"])
def get_user(uid):
    return jsonify({"user_id": uid})

# app.py
from flask import Flask
from blueprints.users import users_bp

app = Flask(__name__)
app.register_blueprint(users_bp)
```

### 2.5 完整 CRUD API — User 管理 (Flask)

```python
from flask import Flask, request, jsonify

app = Flask(__name__)

# 模擬資料庫（實際專案用真正的 DB）
users_db = {}
next_id = 1

@app.route("/api/users", methods=["GET"])
def list_users():
    """取得所有使用者"""
    return jsonify({"users": list(users_db.values())})

@app.route("/api/users/<int:user_id>", methods=["GET"])
def get_user(user_id):
    """取得單一使用者"""
    user = users_db.get(user_id)
    if not user:
        return jsonify({"error": "使用者不存在"}), 404
    return jsonify(user)

@app.route("/api/users", methods=["POST"])
def create_user():
    """新建使用者"""
    global next_id
    data = request.json
    if not data or not data.get("name") or not data.get("email"):
        return jsonify({"error": "name 和 email 為必填"}), 400
    user = {
        "id": next_id,
        "name": data["name"],
        "email": data["email"],
        "age": data.get("age")
    }
    users_db[next_id] = user
    next_id += 1
    return jsonify(user), 201

@app.route("/api/users/<int:user_id>", methods=["PUT"])
def update_user(user_id):
    """完整更新使用者"""
    if user_id not in users_db:
        return jsonify({"error": "使用者不存在"}), 404
    data = request.json
    if not data or not data.get("name") or not data.get("email"):
        return jsonify({"error": "name 和 email 為必填"}), 400
    users_db[user_id] = {
        "id": user_id,
        "name": data["name"],
        "email": data["email"],
        "age": data.get("age")
    }
    return jsonify(users_db[user_id])

@app.route("/api/users/<int:user_id>", methods=["PATCH"])
def patch_user(user_id):
    """部分更新使用者"""
    if user_id not in users_db:
        return jsonify({"error": "使用者不存在"}), 404
    data = request.json
    user = users_db[user_id]
    if "name" in data:
        user["name"] = data["name"]
    if "email" in data:
        user["email"] = data["email"]
    if "age" in data:
        user["age"] = data["age"]
    return jsonify(user)

@app.route("/api/users/<int:user_id>", methods=["DELETE"])
def delete_user(user_id):
    """刪除使用者"""
    if user_id not in users_db:
        return jsonify({"error": "使用者不存在"}), 404
    deleted = users_db.pop(user_id)
    return jsonify({"message": "已刪除", "user": deleted})

if __name__ == "__main__":
    app.run(debug=True, port=5000)
```

---

## 3. Python 後端 — FastAPI ⭐ 推薦

### 3.1 為什麼 FastAPI 比 Flask 好

```
特性              Flask               FastAPI
──────────────────────────────────────────────────
型別驗證          需手動               Pydantic 自動驗證
API 文件          需裝 Swagger 外掛    自動生成 /docs (Swagger)
非同步支援        有限 (需 Quart)      原生 async/await
效能              WSGI (較慢)          ASGI (接近 Node.js)
錯誤訊息          自己寫               自動回傳驗證錯誤
學習曲線          較低                 稍高但值得
```

### 3.2 最小 FastAPI App

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def hello():
    return {"message": "Hello, World!"}

# 執行: uvicorn main:app --reload
# 自動文件: http://localhost:8000/docs
```

### 3.3 Pydantic Model

```python
from pydantic import BaseModel, EmailStr, Field
from typing import Optional

class UserCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=50, examples=["Alice"])
    email: EmailStr
    age: Optional[int] = Field(None, ge=0, le=150)

class UserResponse(BaseModel):
    id: int
    name: str
    email: str
    age: Optional[int] = None

# Pydantic 自動驗證
user = UserCreate(name="Alice", email="alice@example.com", age=30)
print(user.model_dump())  # {'name': 'Alice', 'email': 'alice@example.com', 'age': 30}

# 驗證失敗會拋出 ValidationError
# UserCreate(name="", email="not-an-email", age=-1)  # 拋出錯誤
```

### 3.4 Path / Query Parameters 與 Request Body

```python
from fastapi import FastAPI, Query, Path
from pydantic import BaseModel
from typing import Optional

app = FastAPI()

# --- Path Parameter ---
@app.get("/users/{user_id}")
def get_user(user_id: int = Path(..., ge=1, description="使用者 ID")):
    return {"user_id": user_id}

# --- Query Parameter ---
@app.get("/search")
def search(
    q: str = Query(..., min_length=1, description="搜尋關鍵字"),
    page: int = Query(1, ge=1, description="頁碼"),
    limit: int = Query(10, ge=1, le=100, description="每頁筆數")
):
    return {"q": q, "page": page, "limit": limit}

# --- Request Body ---
class ItemCreate(BaseModel):
    name: str
    price: float
    description: Optional[str] = None

@app.post("/items", status_code=201)
def create_item(item: ItemCreate):
    return {"message": "已建立", "item": item.model_dump()}
```

### 3.5 依賴注入 (Depends)

```python
from fastapi import FastAPI, Depends, HTTPException, Header
from typing import Optional

app = FastAPI()

# 共用的分頁參數
def pagination(page: int = 1, limit: int = 10):
    return {"page": page, "limit": limit, "offset": (page - 1) * limit}

@app.get("/items")
def list_items(paging: dict = Depends(pagination)):
    return {"paging": paging, "items": []}

@app.get("/users")
def list_users(paging: dict = Depends(pagination)):
    return {"paging": paging, "users": []}

# 驗證 Token 的依賴
def verify_token(authorization: Optional[str] = Header(None)):
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="未提供有效 Token")
    token = authorization.split(" ")[1]
    if token != "my-secret-token":
        raise HTTPException(status_code=403, detail="Token 無效")
    return token

@app.get("/protected")
def protected_route(token: str = Depends(verify_token)):
    return {"message": "這是受保護的資源", "token": token}
```

### 3.6 完整 CRUD API — Todo 管理 (FastAPI)

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from typing import Optional

app = FastAPI(title="Todo API", version="1.0.0")

# --- Models ---
class TodoCreate(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = None

class TodoUpdate(BaseModel):
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = None
    completed: Optional[bool] = None

class TodoResponse(BaseModel):
    id: int
    title: str
    description: Optional[str] = None
    completed: bool = False

# --- 模擬資料庫 ---
todos_db: dict[int, dict] = {}
next_id = 1

# --- CRUD 路由 ---
@app.get("/api/todos", response_model=list[TodoResponse])
def list_todos():
    """取得所有待辦事項"""
    return list(todos_db.values())

@app.get("/api/todos/{todo_id}", response_model=TodoResponse)
def get_todo(todo_id: int):
    """取得單一待辦事項"""
    if todo_id not in todos_db:
        raise HTTPException(status_code=404, detail="待辦事項不存在")
    return todos_db[todo_id]

@app.post("/api/todos", response_model=TodoResponse, status_code=201)
def create_todo(todo: TodoCreate):
    """新建待辦事項"""
    global next_id
    new_todo = {
        "id": next_id,
        "title": todo.title,
        "description": todo.description,
        "completed": False
    }
    todos_db[next_id] = new_todo
    next_id += 1
    return new_todo

@app.patch("/api/todos/{todo_id}", response_model=TodoResponse)
def update_todo(todo_id: int, todo: TodoUpdate):
    """更新待辦事項"""
    if todo_id not in todos_db:
        raise HTTPException(status_code=404, detail="待辦事項不存在")
    existing = todos_db[todo_id]
    update_data = todo.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        existing[key] = value
    return existing

@app.delete("/api/todos/{todo_id}")
def delete_todo(todo_id: int):
    """刪除待辦事項"""
    if todo_id not in todos_db:
        raise HTTPException(status_code=404, detail="待辦事項不存在")
    deleted = todos_db.pop(todo_id)
    return {"message": "已刪除", "todo": deleted}
```

### 3.7 Flask vs FastAPI 相同功能對比

```python
# ===== Flask 寫法 =====
from flask import Flask, request, jsonify
app = Flask(__name__)

@app.route("/api/items", methods=["POST"])
def create_item():
    data = request.json
    if not data or not data.get("name"):
        return jsonify({"error": "name 為必填"}), 400
    if not isinstance(data.get("price"), (int, float)):
        return jsonify({"error": "price 必須是數字"}), 400
    return jsonify({"name": data["name"], "price": data["price"]}), 201

# ===== FastAPI 寫法 =====
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str          # 自動驗證非空
    price: float       # 自動驗證型別

@app.post("/api/items", status_code=201)
def create_item(item: Item):
    return item  # 自動序列化、自動生成文件、自動驗證錯誤回傳
```

---

## 4. 資料庫基礎

### 4.1 SQL vs NoSQL

```
特性          SQL (關聯式)              NoSQL (非關聯式)
─────────────────────────────────────────────────────────────
結構          固定 Schema (表格)        彈性 Schema (文件/鍵值)
代表          PostgreSQL, MySQL,        MongoDB, Redis,
              SQLite                    DynamoDB
查詢語言      SQL                       各家不同
事務支援      強 (ACID)                 部分支援
擴展方式      垂直擴展為主              水平擴展為主
適合場景      結構化資料、複雜查詢      大量非結構化資料、高速讀寫
```

### 4.2 SQLite 入門 (Python sqlite3)

```python
import sqlite3

# 建立連線（檔案不存在會自動建立）
conn = sqlite3.connect("myapp.db")
conn.row_factory = sqlite3.Row  # 讓結果可以用欄位名稱存取
cursor = conn.cursor()

# --- 建表 ---
cursor.execute("""
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT UNIQUE NOT NULL,
        age INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
""")
conn.commit()

# --- Create ---
cursor.execute(
    "INSERT INTO users (name, email, age) VALUES (?, ?, ?)",
    ("Alice", "alice@example.com", 30)
)
cursor.execute(
    "INSERT INTO users (name, email, age) VALUES (?, ?, ?)",
    ("Bob", "bob@example.com", 25)
)
conn.commit()

# --- Read ---
cursor.execute("SELECT * FROM users")
rows = cursor.fetchall()
for row in rows:
    print(f"ID={row['id']}, Name={row['name']}, Email={row['email']}")

# 條件查詢
cursor.execute("SELECT * FROM users WHERE age > ?", (26,))
print(cursor.fetchall())

# --- Update ---
cursor.execute("UPDATE users SET age = ? WHERE name = ?", (31, "Alice"))
conn.commit()

# --- Delete ---
cursor.execute("DELETE FROM users WHERE name = ?", ("Bob",))
conn.commit()

conn.close()
```

### 4.3 ORM: SQLAlchemy 基礎

```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.orm import declarative_base, sessionmaker

# 建立引擎與 Session
engine = create_engine("sqlite:///myapp.db", echo=False)
SessionLocal = sessionmaker(bind=engine)
Base = declarative_base()

# --- 定義 Model ---
class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    age = Column(Integer)

    def __repr__(self):
        return f"<User(id={self.id}, name={self.name})>"

# 建表
Base.metadata.create_all(engine)

# --- CRUD 操作 ---
db = SessionLocal()

# Create
new_user = User(name="Alice", email="alice@example.com", age=30)
db.add(new_user)
db.commit()
db.refresh(new_user)
print(new_user.id)  # 自動產生的 ID

# Read
all_users = db.query(User).all()
user = db.query(User).filter(User.name == "Alice").first()
print(user)

# Update
user.age = 31
db.commit()

# Delete
db.delete(user)
db.commit()

db.close()
```

### 4.4 PostgreSQL / MongoDB 概念

```python
# --- PostgreSQL (透過 SQLAlchemy，只需改連線字串) ---
# pip install psycopg2-binary
engine = create_engine("postgresql://user:password@localhost:5432/mydb")
# 其餘 ORM 程式碼完全相同！

# --- MongoDB (使用 pymongo) ---
# pip install pymongo
from pymongo import MongoClient

client = MongoClient("mongodb://localhost:27017")
db = client["myapp"]
collection = db["users"]

# Create
collection.insert_one({"name": "Alice", "email": "alice@example.com", "age": 30})

# Read
user = collection.find_one({"name": "Alice"})
all_users = list(collection.find({"age": {"$gt": 25}}))

# Update
collection.update_one({"name": "Alice"}, {"$set": {"age": 31}})

# Delete
collection.delete_one({"name": "Alice"})
```

---

## 5. HTML/CSS 基礎 (前端必備)

### 5.1 HTML 結構

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的第一個網頁</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- 標題 h1 ~ h6 -->
    <h1>主標題</h1>
    <h2>次標題</h2>

    <!-- 段落與連結 -->
    <p>這是一個段落，包含<a href="https://example.com">連結</a>。</p>

    <!-- 圖片 -->
    <img src="photo.jpg" alt="描述文字" width="300">

    <!-- 容器 div -->
    <div class="container">
        <div class="card">
            <h3>卡片標題</h3>
            <p>卡片內容</p>
        </div>
    </div>

    <!-- 表格 -->
    <table>
        <thead>
            <tr>
                <th>姓名</th>
                <th>年齡</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Alice</td>
                <td>30</td>
            </tr>
        </tbody>
    </table>

    <!-- 表單 -->
    <form action="/api/login" method="POST">
        <label for="email">Email:</label>
        <input type="email" id="email" name="email" required>

        <label for="password">密碼:</label>
        <input type="password" id="password" name="password" required>

        <button type="submit">登入</button>
    </form>

    <script src="app.js"></script>
</body>
</html>
```

### 5.2 CSS 選擇器

```css
/* --- 元素選擇器 --- */
h1 {
    color: #333;
    font-size: 2rem;
}

p {
    line-height: 1.6;
}

/* --- class 選擇器 (最常用) --- */
.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 20px;
}

.card {
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    padding: 20px;
}

/* --- id 選擇器 (唯一元素) --- */
#header {
    background: #1a1a2e;
    color: white;
}

/* --- 組合選擇器 --- */
.card h3 {            /* .card 裡面的 h3 */
    margin-bottom: 10px;
}

.card:hover {         /* 滑鼠懸停時 */
    transform: translateY(-2px);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
    transition: all 0.3s ease;
}
```

### 5.3 Flexbox 排版

```css
/* Flexbox 是一維排版 (橫向或縱向) */
.flex-container {
    display: flex;
    justify-content: center;      /* 主軸置中 */
    align-items: center;          /* 交叉軸置中 */
    gap: 16px;                    /* 元素間距 */
    flex-wrap: wrap;              /* 自動換行 */
}

/* 導航列範例 */
.navbar {
    display: flex;
    justify-content: space-between;  /* 兩端對齊 */
    align-items: center;
    padding: 10px 20px;
    background: #1a1a2e;
    color: white;
}

.navbar .nav-links {
    display: flex;
    gap: 20px;
    list-style: none;
}

/* 卡片排列 */
.card-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
}

.card-grid .card {
    flex: 1 1 300px;  /* 成長、收縮、基礎寬度 300px */
}
```

### 5.4 Grid 排版

```css
/* Grid 是二維排版 (同時控制橫向與縱向) */
.grid-container {
    display: grid;
    grid-template-columns: repeat(3, 1fr);  /* 三欄等寬 */
    grid-gap: 20px;
    padding: 20px;
}

/* 經典的 Holy Grail Layout */
.page-layout {
    display: grid;
    grid-template-areas:
        "header  header  header"
        "sidebar content aside"
        "footer  footer  footer";
    grid-template-columns: 200px 1fr 200px;
    grid-template-rows: auto 1fr auto;
    min-height: 100vh;
    gap: 10px;
}

.page-layout .header  { grid-area: header;  background: #1a1a2e; color: white; padding: 20px; }
.page-layout .sidebar { grid-area: sidebar; background: #f0f0f0; padding: 20px; }
.page-layout .content { grid-area: content; padding: 20px; }
.page-layout .aside   { grid-area: aside;   background: #f0f0f0; padding: 20px; }
.page-layout .footer  { grid-area: footer;  background: #333; color: white; padding: 20px; }
```

### 5.5 響應式設計 (@media)

```css
/* Mobile First: 預設是手機版 */
.card-grid {
    display: grid;
    grid-template-columns: 1fr;  /* 手機: 單欄 */
    gap: 16px;
}

/* 平板 (768px 以上) */
@media (min-width: 768px) {
    .card-grid {
        grid-template-columns: repeat(2, 1fr);  /* 兩欄 */
    }
}

/* 桌面 (1024px 以上) */
@media (min-width: 1024px) {
    .card-grid {
        grid-template-columns: repeat(3, 1fr);  /* 三欄 */
    }
}

/* 響應式字體大小 */
h1 {
    font-size: 1.5rem;
}

@media (min-width: 768px) {
    h1 {
        font-size: 2rem;
    }
}

@media (min-width: 1024px) {
    h1 {
        font-size: 2.5rem;
    }
}
```

### 5.6 完整登入頁面 HTML + CSS

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>登入</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .login-card {
            background: white;
            border-radius: 16px;
            padding: 40px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .login-card h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 1.8rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            color: #555;
            font-weight: 500;
        }

        .form-group input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn-login {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.3s;
        }

        .btn-login:hover {
            opacity: 0.9;
        }

        .links {
            text-align: center;
            margin-top: 20px;
        }

        .links a {
            color: #667eea;
            text-decoration: none;
        }

        .links a:hover {
            text-decoration: underline;
        }

        @media (max-width: 480px) {
            .login-card {
                margin: 20px;
                padding: 30px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="login-card">
        <h1>會員登入</h1>
        <form id="loginForm">
            <div class="form-group">
                <label for="email">電子信箱</label>
                <input type="email" id="email" placeholder="your@email.com" required>
            </div>
            <div class="form-group">
                <label for="password">密碼</label>
                <input type="password" id="password" placeholder="請輸入密碼" required>
            </div>
            <button type="submit" class="btn-login">登入</button>
        </form>
        <div class="links">
            <a href="#">忘記密碼？</a> | <a href="#">註冊新帳號</a>
        </div>
    </div>
</body>
</html>
```

---

## 6. JavaScript 前端互動

### 6.1 DOM 操作

```javascript
// --- 選取元素 ---
const title = document.getElementById("title");          // 用 ID 選取
const cards = document.querySelectorAll(".card");         // 用 CSS 選擇器選取多個
const firstCard = document.querySelector(".card");        // 選取第一個符合的

// --- 修改內容 ---
title.textContent = "新標題";           // 純文字
title.innerHTML = "<em>斜體標題</em>";  // HTML 內容（注意 XSS 風險）

// --- 修改樣式 ---
title.style.color = "blue";
title.style.fontSize = "2rem";
title.classList.add("active");          // 新增 CSS class
title.classList.remove("hidden");       // 移除 CSS class
title.classList.toggle("dark-mode");    // 切換 CSS class

// --- 建立與插入元素 ---
const newDiv = document.createElement("div");
newDiv.textContent = "動態新增的元素";
newDiv.className = "card";
document.querySelector(".container").appendChild(newDiv);

// --- 事件監聽 ---
const button = document.querySelector("#myButton");
button.addEventListener("click", function (event) {
    console.log("按鈕被點擊了！");
    event.preventDefault();  // 阻止預設行為（例如表單提交）
});

// 表單提交事件
document.querySelector("#loginForm").addEventListener("submit", function (e) {
    e.preventDefault();
    const email = document.querySelector("#email").value;
    const password = document.querySelector("#password").value;
    console.log("登入:", email, password);
});
```

### 6.2 Fetch API 呼叫後端

```javascript
// --- GET 請求 ---
async function fetchUsers() {
    const response = await fetch("/api/users");
    if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
    }
    const data = await response.json();
    return data;
}

// --- POST 請求 ---
async function createUser(name, email) {
    const response = await fetch("/api/users", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name, email })
    });
    if (!response.ok) {
        const error = await response.json();
        throw new Error(error.detail || "建立失敗");
    }
    return await response.json();
}

// --- DELETE 請求 ---
async function deleteUser(userId) {
    const response = await fetch(`/api/users/${userId}`, {
        method: "DELETE"
    });
    if (!response.ok) throw new Error("刪除失敗");
    return await response.json();
}
```

### 6.3 完整範例：Todo 前端 (純 JS)

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Todo App</title>
    <style>
        body { font-family: sans-serif; max-width: 500px; margin: 40px auto; padding: 0 20px; }
        .todo-item { display: flex; align-items: center; gap: 10px; padding: 8px 0; border-bottom: 1px solid #eee; }
        .todo-item.completed span { text-decoration: line-through; color: #999; }
        .todo-item span { flex: 1; }
        input[type="text"] { flex: 1; padding: 8px; font-size: 1rem; }
        .add-form { display: flex; gap: 8px; margin-bottom: 20px; }
        button { padding: 8px 16px; cursor: pointer; }
    </style>
</head>
<body>
    <h1>Todo List</h1>
    <div class="add-form">
        <input type="text" id="newTodo" placeholder="輸入新的待辦事項...">
        <button onclick="addTodo()">新增</button>
    </div>
    <div id="todoList"></div>

    <script>
        const API = "http://localhost:8000/api/todos";

        async function loadTodos() {
            const res = await fetch(API);
            const todos = await res.json();
            const container = document.getElementById("todoList");
            container.innerHTML = "";
            todos.forEach(todo => {
                const div = document.createElement("div");
                div.className = "todo-item" + (todo.completed ? " completed" : "");
                div.innerHTML = `
                    <input type="checkbox" ${todo.completed ? "checked" : ""}
                           onchange="toggleTodo(${todo.id}, this.checked)">
                    <span>${todo.title}</span>
                    <button onclick="deleteTodo(${todo.id})">刪除</button>
                `;
                container.appendChild(div);
            });
        }

        async function addTodo() {
            const input = document.getElementById("newTodo");
            const title = input.value.trim();
            if (!title) return;
            await fetch(API, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ title })
            });
            input.value = "";
            loadTodos();
        }

        async function toggleTodo(id, completed) {
            await fetch(`${API}/${id}`, {
                method: "PATCH",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ completed })
            });
            loadTodos();
        }

        async function deleteTodo(id) {
            await fetch(`${API}/${id}`, { method: "DELETE" });
            loadTodos();
        }

        // Enter 鍵新增
        document.getElementById("newTodo").addEventListener("keypress", e => {
            if (e.key === "Enter") addTodo();
        });

        loadTodos();
    </script>
</body>
</html>
```

---

## 7. React 入門 ⭐

### 7.1 JSX 語法

```jsx
// JSX 是 JavaScript 的語法擴展，看起來像 HTML，但其實是 JS
function Welcome() {
    const name = "Alice";
    const isLoggedIn = true;

    return (
        <div>
            {/* 嵌入 JS 表達式用大括號 {} */}
            <h1>Hello, {name}!</h1>
            <p>1 + 1 = {1 + 1}</p>

            {/* class 要寫成 className */}
            <div className="container">

                {/* style 用物件寫法 */}
                <p style={{ color: "blue", fontSize: "1.2rem" }}>
                    藍色文字
                </p>
            </div>
        </div>
    );
}
```

### 7.2 useState Hook

```jsx
import { useState } from "react";

function Counter() {
    // useState 回傳 [目前值, 設定函式]
    const [count, setCount] = useState(0);
    const [name, setName] = useState("");

    return (
        <div>
            <h2>計數器: {count}</h2>
            <button onClick={() => setCount(count + 1)}>+1</button>
            <button onClick={() => setCount(count - 1)}>-1</button>
            <button onClick={() => setCount(0)}>重置</button>

            <hr />
            <input
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="輸入名稱"
            />
            <p>你輸入的是: {name}</p>
        </div>
    );
}
```

### 7.3 useEffect Hook

```jsx
import { useState, useEffect } from "react";

function UserList() {
    const [users, setUsers] = useState([]);
    const [loading, setLoading] = useState(true);

    // useEffect: 在組件「掛載後」執行副作用
    useEffect(() => {
        async function fetchUsers() {
            const res = await fetch("https://jsonplaceholder.typicode.com/users");
            const data = await res.json();
            setUsers(data);
            setLoading(false);
        }
        fetchUsers();
    }, []);  // 空陣列 = 只在掛載時執行一次

    if (loading) return <p>載入中...</p>;

    return (
        <ul>
            {users.map(user => (
                <li key={user.id}>{user.name} — {user.email}</li>
            ))}
        </ul>
    );
}
```

### 7.4 Props 傳遞

```jsx
// 子組件：接收 props
function TodoItem({ todo, onToggle, onDelete }) {
    return (
        <div style={{ display: "flex", gap: "10px", alignItems: "center" }}>
            <input
                type="checkbox"
                checked={todo.completed}
                onChange={() => onToggle(todo.id)}
            />
            <span style={{
                textDecoration: todo.completed ? "line-through" : "none",
                flex: 1
            }}>
                {todo.title}
            </span>
            <button onClick={() => onDelete(todo.id)}>刪除</button>
        </div>
    );
}

// 父組件：傳遞 props
function TodoList() {
    const [todos, setTodos] = useState([
        { id: 1, title: "學 React", completed: false },
        { id: 2, title: "學 TypeScript", completed: true }
    ]);

    const handleToggle = (id) => {
        setTodos(todos.map(t =>
            t.id === id ? { ...t, completed: !t.completed } : t
        ));
    };

    const handleDelete = (id) => {
        setTodos(todos.filter(t => t.id !== id));
    };

    return (
        <div>
            {todos.map(todo => (
                <TodoItem
                    key={todo.id}
                    todo={todo}
                    onToggle={handleToggle}
                    onDelete={handleDelete}
                />
            ))}
        </div>
    );
}
```

### 7.5 條件渲染與列表渲染

```jsx
function Dashboard({ user, notifications }) {
    return (
        <div>
            {/* 條件渲染方式一：三元運算子 */}
            {user ? <p>歡迎回來，{user.name}</p> : <p>請先登入</p>}

            {/* 條件渲染方式二：&& 短路 */}
            {notifications.length > 0 && (
                <span className="badge">{notifications.length} 則通知</span>
            )}

            {/* 列表渲染：.map() + key */}
            <ul>
                {notifications.map(n => (
                    <li key={n.id}>{n.message}</li>
                ))}
            </ul>
        </div>
    );
}
```

### 7.6 完整範例：Todo App React 組件

```jsx
import { useState } from "react";

function TodoApp() {
    const [todos, setTodos] = useState([]);
    const [input, setInput] = useState("");
    const [filter, setFilter] = useState("all"); // all | active | completed
    let nextId = todos.length > 0 ? Math.max(...todos.map(t => t.id)) + 1 : 1;

    const addTodo = () => {
        const title = input.trim();
        if (!title) return;
        setTodos([...todos, { id: nextId, title, completed: false }]);
        setInput("");
    };

    const toggleTodo = (id) => {
        setTodos(todos.map(t =>
            t.id === id ? { ...t, completed: !t.completed } : t
        ));
    };

    const deleteTodo = (id) => {
        setTodos(todos.filter(t => t.id !== id));
    };

    const filteredTodos = todos.filter(t => {
        if (filter === "active") return !t.completed;
        if (filter === "completed") return t.completed;
        return true;
    });

    const remaining = todos.filter(t => !t.completed).length;

    return (
        <div style={{ maxWidth: 500, margin: "40px auto", fontFamily: "sans-serif" }}>
            <h1>Todo App</h1>

            <div style={{ display: "flex", gap: 8, marginBottom: 20 }}>
                <input
                    value={input}
                    onChange={e => setInput(e.target.value)}
                    onKeyDown={e => e.key === "Enter" && addTodo()}
                    placeholder="新增待辦事項..."
                    style={{ flex: 1, padding: 8, fontSize: "1rem" }}
                />
                <button onClick={addTodo}>新增</button>
            </div>

            <div style={{ marginBottom: 12 }}>
                {["all", "active", "completed"].map(f => (
                    <button
                        key={f}
                        onClick={() => setFilter(f)}
                        style={{
                            marginRight: 8,
                            fontWeight: filter === f ? "bold" : "normal",
                            textDecoration: filter === f ? "underline" : "none"
                        }}
                    >
                        {f === "all" ? "全部" : f === "active" ? "未完成" : "已完成"}
                    </button>
                ))}
                <span style={{ marginLeft: 16, color: "#888" }}>
                    剩餘 {remaining} 項
                </span>
            </div>

            {filteredTodos.map(todo => (
                <div key={todo.id} style={{
                    display: "flex", alignItems: "center", gap: 10,
                    padding: "8px 0", borderBottom: "1px solid #eee"
                }}>
                    <input
                        type="checkbox"
                        checked={todo.completed}
                        onChange={() => toggleTodo(todo.id)}
                    />
                    <span style={{
                        flex: 1,
                        textDecoration: todo.completed ? "line-through" : "none",
                        color: todo.completed ? "#999" : "#333"
                    }}>
                        {todo.title}
                    </span>
                    <button onClick={() => deleteTodo(todo.id)}>刪除</button>
                </div>
            ))}

            {filteredTodos.length === 0 && (
                <p style={{ color: "#999", textAlign: "center", marginTop: 20 }}>
                    沒有{filter === "active" ? "未完成的" : filter === "completed" ? "已完成的" : ""}待辦事項
                </p>
            )}
        </div>
    );
}

export default TodoApp;
```

---

## 8. TypeScript + React

### 8.1 組件 Props 型別定義

```tsx
// 定義 Props 介面
interface TodoItemProps {
    todo: {
        id: number;
        title: string;
        completed: boolean;
    };
    onToggle: (id: number) => void;
    onDelete: (id: number) => void;
}

// 使用 Props 型別的函式組件
function TodoItem({ todo, onToggle, onDelete }: TodoItemProps) {
    return (
        <div style={{ display: "flex", alignItems: "center", gap: 10 }}>
            <input
                type="checkbox"
                checked={todo.completed}
                onChange={() => onToggle(todo.id)}
            />
            <span style={{
                flex: 1,
                textDecoration: todo.completed ? "line-through" : "none"
            }}>
                {todo.title}
            </span>
            <button onClick={() => onDelete(todo.id)}>刪除</button>
        </div>
    );
}
```

### 8.2 State 型別

```tsx
import { useState } from "react";

// 明確定義 State 的型別
interface Todo {
    id: number;
    title: string;
    completed: boolean;
}

type FilterType = "all" | "active" | "completed";

function App() {
    // TypeScript 自動推斷或手動指定泛型
    const [todos, setTodos] = useState<Todo[]>([]);
    const [input, setInput] = useState<string>("");
    const [filter, setFilter] = useState<FilterType>("all");

    // 型別安全：以下會報錯
    // setFilter("invalid");  // Error: '"invalid"' is not assignable to type 'FilterType'
    // setTodos("not array"); // Error: 'string' is not assignable to type 'Todo[]'

    return <div>...</div>;
}
```

### 8.3 Event 型別

```tsx
import { useState, FormEvent, ChangeEvent } from "react";

function SearchForm() {
    const [query, setQuery] = useState("");

    // 表單提交事件
    const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
        e.preventDefault();
        console.log("搜尋:", query);
    };

    // Input 變更事件
    const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
        setQuery(e.target.value);
    };

    // 按鈕點擊事件
    const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
        console.log("按鈕被點擊");
    };

    return (
        <form onSubmit={handleSubmit}>
            <input value={query} onChange={handleChange} />
            <button type="submit" onClick={handleClick}>搜尋</button>
        </form>
    );
}
```

### 8.4 API 回應型別

```tsx
// 定義 API 回應的型別
interface ApiResponse<T> {
    data: T;
    message: string;
    total?: number;
}

interface User {
    id: number;
    name: string;
    email: string;
}

// 型別安全的 API 呼叫
async function fetchUsers(): Promise<ApiResponse<User[]>> {
    const res = await fetch("/api/users");
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
}

// 使用時自動有型別提示
async function main() {
    const result = await fetchUsers();
    result.data.forEach(user => {
        console.log(user.name);   // TypeScript 知道這是 string
        console.log(user.email);  // TypeScript 知道這是 string
    });
}
```

### 8.5 完整範例：型別安全的 Todo 組件

```tsx
import { useState, useEffect, FormEvent } from "react";

// --- 型別定義 ---
interface Todo {
    id: number;
    title: string;
    description: string | null;
    completed: boolean;
}

interface TodoCreatePayload {
    title: string;
    description?: string;
}

type FilterType = "all" | "active" | "completed";

// --- API 層 ---
const API_URL = "http://localhost:8000/api/todos";

async function apiGetTodos(): Promise<Todo[]> {
    const res = await fetch(API_URL);
    return res.json();
}

async function apiCreateTodo(payload: TodoCreatePayload): Promise<Todo> {
    const res = await fetch(API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
    });
    return res.json();
}

async function apiToggleTodo(id: number, completed: boolean): Promise<Todo> {
    const res = await fetch(`${API_URL}/${id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ completed }),
    });
    return res.json();
}

async function apiDeleteTodo(id: number): Promise<void> {
    await fetch(`${API_URL}/${id}`, { method: "DELETE" });
}

// --- 組件 ---
function TodoApp() {
    const [todos, setTodos] = useState<Todo[]>([]);
    const [input, setInput] = useState<string>("");
    const [filter, setFilter] = useState<FilterType>("all");
    const [loading, setLoading] = useState<boolean>(true);

    useEffect(() => {
        apiGetTodos().then(data => {
            setTodos(data);
            setLoading(false);
        });
    }, []);

    const handleSubmit = async (e: FormEvent) => {
        e.preventDefault();
        const title = input.trim();
        if (!title) return;
        const newTodo = await apiCreateTodo({ title });
        setTodos(prev => [...prev, newTodo]);
        setInput("");
    };

    const handleToggle = async (id: number) => {
        const todo = todos.find(t => t.id === id);
        if (!todo) return;
        const updated = await apiToggleTodo(id, !todo.completed);
        setTodos(prev => prev.map(t => (t.id === id ? updated : t)));
    };

    const handleDelete = async (id: number) => {
        await apiDeleteTodo(id);
        setTodos(prev => prev.filter(t => t.id !== id));
    };

    const filtered = todos.filter(t => {
        if (filter === "active") return !t.completed;
        if (filter === "completed") return t.completed;
        return true;
    });

    if (loading) return <p>載入中...</p>;

    return (
        <div style={{ maxWidth: 500, margin: "40px auto" }}>
            <h1>Todo App (TypeScript)</h1>
            <form onSubmit={handleSubmit} style={{ display: "flex", gap: 8 }}>
                <input
                    value={input}
                    onChange={e => setInput(e.target.value)}
                    placeholder="新增待辦..."
                    style={{ flex: 1, padding: 8 }}
                />
                <button type="submit">新增</button>
            </form>
            <div style={{ margin: "12px 0" }}>
                {(["all", "active", "completed"] as FilterType[]).map(f => (
                    <button key={f} onClick={() => setFilter(f)}
                        style={{ marginRight: 8, fontWeight: filter === f ? "bold" : "normal" }}>
                        {f === "all" ? "全部" : f === "active" ? "未完成" : "已完成"}
                    </button>
                ))}
            </div>
            {filtered.map(todo => (
                <div key={todo.id} style={{
                    display: "flex", alignItems: "center", gap: 10,
                    padding: "8px 0", borderBottom: "1px solid #eee"
                }}>
                    <input type="checkbox" checked={todo.completed}
                        onChange={() => handleToggle(todo.id)} />
                    <span style={{
                        flex: 1,
                        textDecoration: todo.completed ? "line-through" : "none"
                    }}>{todo.title}</span>
                    <button onClick={() => handleDelete(todo.id)}>刪除</button>
                </div>
            ))}
        </div>
    );
}

export default TodoApp;
```

---

## 9. 前後端整合實戰

一個完整的 Todo 應用：FastAPI + React (TypeScript) + SQLite。

### 9.1 後端完整程式碼 (FastAPI + SQLite)

```python
# backend/main.py
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
from typing import Optional
import sqlite3

app = FastAPI(title="Todo Full-Stack API")

# --- CORS 設定（允許前端跨域請求）---
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173"],  # Vite 預設 port
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- 資料庫 ---
def get_db():
    conn = sqlite3.connect("todos.db")
    conn.row_factory = sqlite3.Row
    try:
        yield conn
    finally:
        conn.close()

def init_db():
    conn = sqlite3.connect("todos.db")
    conn.execute("""
        CREATE TABLE IF NOT EXISTS todos (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT NOT NULL,
            description TEXT,
            completed BOOLEAN DEFAULT 0,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    """)
    conn.commit()
    conn.close()

init_db()

# --- Pydantic Models ---
class TodoCreate(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = None

class TodoUpdate(BaseModel):
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = None
    completed: Optional[bool] = None

class TodoResponse(BaseModel):
    id: int
    title: str
    description: Optional[str]
    completed: bool
    created_at: str

# --- API 路由 ---
@app.get("/api/todos", response_model=list[TodoResponse])
def list_todos(db: sqlite3.Connection = Depends(get_db)):
    cursor = db.execute("SELECT * FROM todos ORDER BY created_at DESC")
    rows = cursor.fetchall()
    return [dict(row) for row in rows]

@app.get("/api/todos/{todo_id}", response_model=TodoResponse)
def get_todo(todo_id: int, db: sqlite3.Connection = Depends(get_db)):
    cursor = db.execute("SELECT * FROM todos WHERE id = ?", (todo_id,))
    row = cursor.fetchone()
    if not row:
        raise HTTPException(status_code=404, detail="待辦事項不存在")
    return dict(row)

@app.post("/api/todos", response_model=TodoResponse, status_code=201)
def create_todo(todo: TodoCreate, db: sqlite3.Connection = Depends(get_db)):
    cursor = db.execute(
        "INSERT INTO todos (title, description) VALUES (?, ?)",
        (todo.title, todo.description)
    )
    db.commit()
    new_id = cursor.lastrowid
    cursor = db.execute("SELECT * FROM todos WHERE id = ?", (new_id,))
    return dict(cursor.fetchone())

@app.patch("/api/todos/{todo_id}", response_model=TodoResponse)
def update_todo(todo_id: int, todo: TodoUpdate, db: sqlite3.Connection = Depends(get_db)):
    cursor = db.execute("SELECT * FROM todos WHERE id = ?", (todo_id,))
    if not cursor.fetchone():
        raise HTTPException(status_code=404, detail="待辦事項不存在")
    updates = []
    values = []
    for field, value in todo.model_dump(exclude_unset=True).items():
        updates.append(f"{field} = ?")
        values.append(value)
    if updates:
        values.append(todo_id)
        db.execute(f"UPDATE todos SET {', '.join(updates)} WHERE id = ?", values)
        db.commit()
    cursor = db.execute("SELECT * FROM todos WHERE id = ?", (todo_id,))
    return dict(cursor.fetchone())

@app.delete("/api/todos/{todo_id}")
def delete_todo(todo_id: int, db: sqlite3.Connection = Depends(get_db)):
    cursor = db.execute("SELECT * FROM todos WHERE id = ?", (todo_id,))
    if not cursor.fetchone():
        raise HTTPException(status_code=404, detail="待辦事項不存在")
    db.execute("DELETE FROM todos WHERE id = ?", (todo_id,))
    db.commit()
    return {"message": "已刪除"}
```

### 9.2 前端完整程式碼 (React + TypeScript)

```tsx
// frontend/src/App.tsx
import { useState, useEffect, FormEvent } from "react";

interface Todo {
    id: number;
    title: string;
    description: string | null;
    completed: boolean;
    created_at: string;
}

const API = "http://localhost:8000/api/todos";

function App() {
    const [todos, setTodos] = useState<Todo[]>([]);
    const [title, setTitle] = useState("");
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    const fetchTodos = async () => {
        try {
            const res = await fetch(API);
            if (!res.ok) throw new Error("載入失敗");
            const data: Todo[] = await res.json();
            setTodos(data);
            setError(null);
        } catch (e) {
            setError(e instanceof Error ? e.message : "未知錯誤");
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => { fetchTodos(); }, []);

    const handleAdd = async (e: FormEvent) => {
        e.preventDefault();
        if (!title.trim()) return;
        const res = await fetch(API, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ title: title.trim() }),
        });
        if (res.ok) {
            const newTodo: Todo = await res.json();
            setTodos(prev => [newTodo, ...prev]);
            setTitle("");
        }
    };

    const handleToggle = async (todo: Todo) => {
        const res = await fetch(`${API}/${todo.id}`, {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ completed: !todo.completed }),
        });
        if (res.ok) {
            const updated: Todo = await res.json();
            setTodos(prev => prev.map(t => (t.id === todo.id ? updated : t)));
        }
    };

    const handleDelete = async (id: number) => {
        const res = await fetch(`${API}/${id}`, { method: "DELETE" });
        if (res.ok) {
            setTodos(prev => prev.filter(t => t.id !== id));
        }
    };

    if (loading) return <p style={{ textAlign: "center" }}>載入中...</p>;
    if (error) return <p style={{ color: "red" }}>錯誤: {error}</p>;

    const remaining = todos.filter(t => !t.completed).length;

    return (
        <div style={{ maxWidth: 600, margin: "40px auto", padding: "0 20px", fontFamily: "sans-serif" }}>
            <h1>Todo Full-Stack App</h1>
            <form onSubmit={handleAdd} style={{ display: "flex", gap: 8, marginBottom: 20 }}>
                <input
                    value={title}
                    onChange={e => setTitle(e.target.value)}
                    placeholder="新增待辦事項..."
                    style={{ flex: 1, padding: "10px 14px", fontSize: "1rem",
                             border: "2px solid #ddd", borderRadius: 8 }}
                />
                <button type="submit" style={{ padding: "10px 20px", background: "#4f46e5",
                         color: "white", border: "none", borderRadius: 8, cursor: "pointer" }}>
                    新增
                </button>
            </form>
            <p style={{ color: "#888", marginBottom: 12 }}>
                共 {todos.length} 項，剩餘 {remaining} 項未完成
            </p>
            {todos.map(todo => (
                <div key={todo.id} style={{
                    display: "flex", alignItems: "center", gap: 12,
                    padding: "12px 0", borderBottom: "1px solid #eee"
                }}>
                    <input type="checkbox" checked={todo.completed}
                        onChange={() => handleToggle(todo)}
                        style={{ width: 20, height: 20 }} />
                    <div style={{ flex: 1 }}>
                        <span style={{
                            textDecoration: todo.completed ? "line-through" : "none",
                            color: todo.completed ? "#999" : "#333"
                        }}>{todo.title}</span>
                        <br />
                        <small style={{ color: "#aaa" }}>{todo.created_at}</small>
                    </div>
                    <button onClick={() => handleDelete(todo.id)}
                        style={{ padding: "6px 12px", background: "#ef4444", color: "white",
                                 border: "none", borderRadius: 6, cursor: "pointer" }}>
                        刪除
                    </button>
                </div>
            ))}
        </div>
    );
}

export default App;
```

### 9.3 啟動方式

```bash
# 後端
cd backend
pip install fastapi uvicorn
uvicorn main:app --reload --port 8000

# 前端
cd frontend
npm create vite@latest . -- --template react-ts
npm install
npm run dev   # 預設 http://localhost:5173
```

---

## 10. API 安全性

### 10.1 Authentication vs Authorization

```
Authentication（認證）：你是誰？ → 驗證身份（登入）
Authorization（授權）：  你能做什麼？ → 驗證權限（角色、存取範圍）

流程：
使用者登入 → 認證通過 → 發 Token → 之後每次請求帶 Token → 伺服器驗證 Token + 檢查權限
```

### 10.2 JWT Token 原理

```
JWT = Header.Payload.Signature

Header:   {"alg": "HS256", "typ": "JWT"}          → Base64 編碼
Payload:  {"sub": "user123", "exp": 1700000000}    → Base64 編碼
Signature: HMACSHA256(header + "." + payload, secret_key)

特點：
- 無狀態（伺服器不需儲存 Session）
- 自包含（Token 內含使用者資訊）
- 可設定過期時間
```

### 10.3 完整範例：JWT 驗證 (FastAPI)

```python
# pip install fastapi uvicorn python-jose[cryptography] passlib[bcrypt]
from datetime import datetime, timedelta
from typing import Optional
from fastapi import FastAPI, HTTPException, Depends
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import JWTError, jwt
from passlib.context import CryptContext
from pydantic import BaseModel

# --- 設定 ---
SECRET_KEY = "your-secret-key-change-in-production"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

app = FastAPI()

# 密碼加密
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# --- 模擬使用者資料庫 ---
fake_users_db = {
    "alice": {
        "username": "alice",
        "hashed_password": pwd_context.hash("secret123"),
        "role": "admin"
    },
    "bob": {
        "username": "bob",
        "hashed_password": pwd_context.hash("password456"),
        "role": "user"
    }
}

# --- Models ---
class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

class UserResponse(BaseModel):
    username: str
    role: str

# --- 工具函式 ---
def verify_password(plain: str, hashed: str) -> bool:
    return pwd_context.verify(plain, hashed)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=15))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def get_current_user(token: str = Depends(oauth2_scheme)) -> dict:
    credentials_exception = HTTPException(
        status_code=401,
        detail="無法驗證身份",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    user = fake_users_db.get(username)
    if user is None:
        raise credentials_exception
    return user

def require_admin(user: dict = Depends(get_current_user)) -> dict:
    if user["role"] != "admin":
        raise HTTPException(status_code=403, detail="需要管理員權限")
    return user

# --- 路由 ---
@app.post("/token", response_model=Token)
def login(form: OAuth2PasswordRequestForm = Depends()):
    user = fake_users_db.get(form.username)
    if not user or not verify_password(form.password, user["hashed_password"]):
        raise HTTPException(status_code=401, detail="帳號或密碼錯誤")
    token = create_access_token(
        data={"sub": user["username"]},
        expires_delta=timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    )
    return {"access_token": token, "token_type": "bearer"}

@app.get("/users/me", response_model=UserResponse)
def read_me(user: dict = Depends(get_current_user)):
    return user

@app.get("/admin/dashboard")
def admin_dashboard(user: dict = Depends(require_admin)):
    return {"message": f"歡迎管理員 {user['username']}", "secret_data": [1, 2, 3]}
```

### 10.4 CORS / Rate Limiting / Input Validation

```python
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from slowapi import Limiter
from slowapi.util import get_remote_address

app = FastAPI()

# --- CORS ---
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://myapp.com"],  # 生產環境指定具體網域
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH"],
    allow_headers=["*"],
)

# --- Rate Limiting ---
# pip install slowapi
limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter

@app.get("/api/search")
@limiter.limit("10/minute")  # 每分鐘最多 10 次
async def search(request: Request, q: str):
    return {"results": []}

# --- Input Validation (Pydantic 自動處理) ---
from pydantic import BaseModel, Field, field_validator
import re

class UserCreate(BaseModel):
    username: str = Field(..., min_length=3, max_length=20)
    email: str
    password: str = Field(..., min_length=8)

    @field_validator("username")
    @classmethod
    def username_alphanumeric(cls, v):
        if not re.match(r"^[a-zA-Z0-9_]+$", v):
            raise ValueError("使用者名稱只能包含英文、數字和底線")
        return v

    @field_validator("email")
    @classmethod
    def email_valid(cls, v):
        if "@" not in v:
            raise ValueError("無效的 Email 格式")
        return v
```

---

## 11. 部署

### 11.1 Uvicorn / Gunicorn

```bash
# 開發環境
uvicorn main:app --reload --port 8000

# 生產環境：Gunicorn + Uvicorn workers
# pip install gunicorn
gunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker -b 0.0.0.0:8000
# -w 4: 4 個 worker processes
# -k: 使用 Uvicorn 的非同步 worker
```

### 11.2 Nginx 反向代理

```nginx
# /etc/nginx/sites-available/myapp
server {
    listen 80;
    server_name myapp.com;

    # 前端靜態檔案
    location / {
        root /var/www/myapp/frontend/dist;
        try_files $uri $uri/ /index.html;  # SPA 路由支援
    }

    # 後端 API 反向代理
    location /api/ {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

### 11.3 Docker 化

```dockerfile
# backend/Dockerfile
FROM python:3.12-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```dockerfile
# frontend/Dockerfile
FROM node:20-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### 11.4 docker-compose 整合

```yaml
# docker-compose.yml
version: "3.8"

services:
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    volumes:
      - ./backend:/app
      - db-data:/app/data
    environment:
      - DATABASE_URL=sqlite:///data/todos.db
      - SECRET_KEY=change-me-in-production

  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend

  # 如果需要 PostgreSQL
  # postgres:
  #   image: postgres:16-alpine
  #   environment:
  #     POSTGRES_DB: myapp
  #     POSTGRES_USER: user
  #     POSTGRES_PASSWORD: password
  #   volumes:
  #     - pg-data:/var/lib/postgresql/data
  #   ports:
  #     - "5432:5432"

volumes:
  db-data:
```

```bash
# 啟動所有服務
docker-compose up -d

# 查看日誌
docker-compose logs -f backend

# 停止
docker-compose down
```

---

## 12. 現代前端工具鏈

### 12.1 套件管理器：npm / yarn / pnpm

```bash
# npm (Node.js 內建)
npm init -y                    # 初始化專案
npm install react react-dom    # 安裝套件
npm install -D typescript      # 安裝開發依賴
npm run dev                    # 執行 scripts

# yarn (Facebook 開發，較快的快取)
yarn init -y
yarn add react react-dom
yarn add -D typescript
yarn dev

# pnpm (最省空間，用硬連結避免重複下載) ⭐ 推薦
pnpm init
pnpm add react react-dom
pnpm add -D typescript
pnpm dev
```

### 12.2 Vite 建置工具

```bash
# 建立新專案（推薦用 Vite 取代 Create React App）
npm create vite@latest my-app -- --template react-ts
cd my-app
npm install
npm run dev      # 開發伺服器 (HMR 熱更新)
npm run build    # 打包生產版本 → dist/
npm run preview  # 預覽生產版本
```

```typescript
// vite.config.ts — 常用設定
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
    plugins: [react()],
    server: {
        port: 5173,
        proxy: {
            // 開發時將 /api 請求轉發到後端
            "/api": {
                target: "http://localhost:8000",
                changeOrigin: true,
            },
        },
    },
    build: {
        outDir: "dist",
        sourcemap: true,
    },
});
```

### 12.3 Tailwind CSS

```bash
# 安裝
npm install -D tailwindcss @tailwindcss/vite
```

```typescript
// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";

export default defineConfig({
    plugins: [react(), tailwindcss()],
});
```

```css
/* src/index.css */
@import "tailwindcss";
```

```tsx
// 用 Tailwind 寫 Todo 卡片 — 不需要寫任何 CSS 檔案
function TodoCard({ title, completed }: { title: string; completed: boolean }) {
    return (
        <div className="flex items-center gap-3 p-4 bg-white rounded-lg shadow-md
                        hover:shadow-lg transition-shadow duration-200">
            <input
                type="checkbox"
                checked={completed}
                className="w-5 h-5 rounded border-gray-300 text-indigo-600
                           focus:ring-indigo-500"
            />
            <span className={`flex-1 ${completed ? "line-through text-gray-400" : "text-gray-800"}`}>
                {title}
            </span>
            <button className="px-3 py-1 text-sm text-red-600 bg-red-50 rounded-md
                               hover:bg-red-100 transition-colors">
                刪除
            </button>
        </div>
    );
}

// 響應式 Grid（Tailwind 寫法）
function CardGrid() {
    return (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 p-6">
            <TodoCard title="學 React" completed={false} />
            <TodoCard title="學 TypeScript" completed={true} />
            <TodoCard title="學 Tailwind" completed={false} />
        </div>
    );
}
```

### 12.4 Next.js 概覽

```
Next.js 是 React 的全端框架，提供：

功能                    說明
─────────────────────────────────────────────
Server Components       組件在伺服器端渲染（減少 JS 傳輸量）
File-based Routing      檔案即路由 (app/about/page.tsx → /about)
API Routes              在同一專案寫後端 API
SSR / SSG / ISR         伺服器渲染 / 靜態生成 / 增量靜態再生
Image Optimization      自動圖片優化
Middleware              請求攔截（驗證、重導向）
```

```bash
# 建立 Next.js 專案
npx create-next-app@latest my-next-app --typescript --tailwind --app
```

```tsx
// app/page.tsx — 首頁 (Server Component)
export default function Home() {
    return (
        <main className="flex min-h-screen flex-col items-center p-24">
            <h1 className="text-4xl font-bold">歡迎來到 Next.js</h1>
        </main>
    );
}

// app/api/todos/route.ts — API Route
import { NextResponse } from "next/server";

export async function GET() {
    const todos = [{ id: 1, title: "學 Next.js", completed: false }];
    return NextResponse.json(todos);
}

export async function POST(request: Request) {
    const body = await request.json();
    return NextResponse.json({ id: 2, ...body, completed: false }, { status: 201 });
}
```

### 12.5 狀態管理：Redux vs Zustand

```tsx
// ===== Redux Toolkit（適合大型專案）=====
// npm install @reduxjs/toolkit react-redux

// store/todosSlice.ts
import { createSlice, PayloadAction } from "@reduxjs/toolkit";

interface Todo {
    id: number;
    title: string;
    completed: boolean;
}

interface TodosState {
    items: Todo[];
}

const initialState: TodosState = { items: [] };

const todosSlice = createSlice({
    name: "todos",
    initialState,
    reducers: {
        addTodo(state, action: PayloadAction<string>) {
            const id = state.items.length + 1;
            state.items.push({ id, title: action.payload, completed: false });
        },
        toggleTodo(state, action: PayloadAction<number>) {
            const todo = state.items.find(t => t.id === action.payload);
            if (todo) todo.completed = !todo.completed;
        },
        removeTodo(state, action: PayloadAction<number>) {
            state.items = state.items.filter(t => t.id !== action.payload);
        },
    },
});

export const { addTodo, toggleTodo, removeTodo } = todosSlice.actions;
export default todosSlice.reducer;
```

```tsx
// ===== Zustand（更輕量，推薦中小型專案）=====
// npm install zustand

import { create } from "zustand";

interface Todo {
    id: number;
    title: string;
    completed: boolean;
}

interface TodoStore {
    todos: Todo[];
    addTodo: (title: string) => void;
    toggleTodo: (id: number) => void;
    removeTodo: (id: number) => void;
}

const useTodoStore = create<TodoStore>((set) => ({
    todos: [],
    addTodo: (title) =>
        set((state) => ({
            todos: [...state.todos, {
                id: state.todos.length + 1,
                title,
                completed: false,
            }],
        })),
    toggleTodo: (id) =>
        set((state) => ({
            todos: state.todos.map(t =>
                t.id === id ? { ...t, completed: !t.completed } : t
            ),
        })),
    removeTodo: (id) =>
        set((state) => ({
            todos: state.todos.filter(t => t.id !== id),
        })),
}));

// 在組件中使用
function TodoList() {
    const { todos, addTodo, toggleTodo, removeTodo } = useTodoStore();

    return (
        <div>
            <button onClick={() => addTodo("新任務")}>新增</button>
            {todos.map(todo => (
                <div key={todo.id}>
                    <input type="checkbox" checked={todo.completed}
                        onChange={() => toggleTodo(todo.id)} />
                    <span>{todo.title}</span>
                    <button onClick={() => removeTodo(todo.id)}>刪除</button>
                </div>
            ))}
        </div>
    );
}
```

```
Redux vs Zustand 比較：

特性          Redux Toolkit          Zustand
───────────────────────────────────────────────
程式碼量      較多（Slice + Store）   極少（一個 create 搞定）
學習曲線      中等                    極低
DevTools      Redux DevTools          支援 Redux DevTools
適用規模      大型專案                中小型專案
Boilerplate   少（比舊版好很多）      幾乎沒有
```

---

## 全章回顧：學習路線圖

```
階段一：後端 API（1-2 週）
  Python → Flask 基礎 → FastAPI（推薦） → 資料庫 (SQLite/PostgreSQL)

階段二：前端基礎（1-2 週）
  HTML/CSS → JavaScript DOM → Fetch API → 響應式設計

階段三：React 開發（2-3 週）
  React 基礎 → TypeScript + React → 狀態管理 → Tailwind CSS

階段四：全端整合（1-2 週）
  前後端串接 → CORS → JWT 認證 → RESTful API 設計

階段五：部署上線（1 週）
  Docker → Nginx → docker-compose → 雲端部署 (AWS/GCP/Vercel)
```

**核心建議**：動手做比讀文件重要十倍。先跟著本篇的 Todo App 完整做一次，再嘗試自己的專案（例如部落格、記帳本）。遇到問題時回來查對應章節即可。
