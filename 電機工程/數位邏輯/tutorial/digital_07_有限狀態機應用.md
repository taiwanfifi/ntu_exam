# 數位邏輯教學講義 第七章：有限狀態機應用

---

## 🔰 **本章基礎觀念（零基礎必讀）**

上一章學了同步循序電路的設計流程，這一章要用大量實際案例來練功。
**有限狀態機 (Finite State Machine, FSM)** 是數位系統設計的核心，
從簡單的序列偵測器到複雜的 CPU 控制器，底層都是 FSM。

在 IC 設計業界面試中（聯發科/瑞昱/聯詠/群聯），
FSM 設計是**必考題**，尤其是序列偵測器和狀態編碼策略。

> **學完本章，你應該能做到：**
> 1. 設計重疊/非重疊序列偵測器
> 2. 設計交通燈控制器和自動販賣機
> 3. 用隱含表法做狀態化簡
> 4. 選擇合適的狀態編碼策略（Binary/Gray/One-hot）
> 5. 理解非同步計數器的原理和限制

---

## 關鍵術語表

| 中文 | 英文 | 白話解釋 | 例子 |
|------|------|----------|------|
| 有限狀態機 | FSM (Finite State Machine) | 有有限個狀態的系統 | 計數器、控制器 |
| 序列偵測器 | Sequence Detector | 偵測特定輸入序列的 FSM | 偵測 "1011" |
| 重疊偵測 | Overlapping Detection | 偵測到後，已輸入的部分可以作為下一次的開頭 | "101" 在 "1011011" 出現 3 次 |
| 非重疊偵測 | Non-overlapping Detection | 偵測到後，重新開始 | "101" 在 "1011011" 出現 2 次 |
| 隱含表 | Implication Table | 用三角矩陣找等價狀態 | 狀態化簡方法 |
| 等價狀態 | Equivalent States | 對所有輸入序列，輸出完全相同 | 可以合併 |
| 二進位編碼 | Binary Encoding | 用最少 bit 數編碼狀態 | 4 狀態用 2-bit |
| 格雷碼編碼 | Gray Encoding | 相鄰狀態只差 1 bit | 減少冒險 |
| One-hot 編碼 | One-hot Encoding | 每個狀態用一個 FF | FPGA 常用 |
| 非同步計數器 | Asynchronous/Ripple Counter | FF 的 CLK 不共用，串接 | 簡單但有延遲問題 |

---

## 一、序列偵測器 (Sequence Detector)

### 1.1 重疊 vs 非重疊

**目標**：偵測輸入中的特定序列，偵測到時輸出 1。

```
輸入序列：  1 0 1 1 0 1 1 0 1 1
偵測 "1011"：

重疊：        ─────     ─────     （出現 2 次）
             1 0 1 1   1 0 1 1
                   └─ 最後的 "1" 可以當下一次的開頭

非重疊：      ─────               （出現 1 次，之後重頭來）
             1 0 1 1
```

**差異在哪？**
偵測到後回到哪個狀態：
- **重疊**：回到「已收到一部分匹配前綴」的狀態
- **非重疊**：回到初始狀態

---

### 1.2 完整設計範例：偵測 "1011"（重疊, Mealy Machine）

#### Step 1：定義狀態（根據已匹配的前綴）

| 狀態 | 意義 |
|------|------|
| S0 | 初始，尚未匹配任何字元 |
| S1 | 已匹配 "1" |
| S2 | 已匹配 "10" |
| S3 | 已匹配 "101" |

（偵測到 "1011" 時輸出 Z=1，然後回到適當狀態）

#### Step 2：狀態圖（Mealy Machine）

```
               0/0              0/0
          ┌──────────┐    ┌──────────┐
          ▼          │    ▼          │
        ┌────┐       │  ┌────┐      │
   ┌───→│ S0 │───1/0─┘  │ S2 │──────┘
   │    └────┘          └────┘
   │      │               ↑  │
   │    0/0(自環)          │  │ 1/0
   │      └───(已在上面)   │  ▼
   │                    ┌────┐
   │    ┌────┐     0/0  │ S3 │
   │    │ S1 │─────────→│    │
   │    └────┘          └────┘
   │      ↑  │            │
   │      │  │ 1/0        │ 1/1 (偵測到 "1011"!)
   │      │  └──(自環)     │
   │      │               ▼
   └──────┴───── 回到 S1（重疊！因為最後的 "1" 是新序列的開頭）
```

讓我重新整理狀態轉移：

| 現態 | 輸入 | 下一狀態 | 輸出 Z | 說明 |
|------|------|---------|--------|------|
| S0 | 0 | S0 | 0 | "0" 不匹配，留原地 |
| S0 | 1 | S1 | 0 | 匹配 "1" |
| S1 | 0 | S2 | 0 | 匹配 "10" |
| S1 | 1 | S1 | 0 | "11"→最後的 "1" 還是有效前綴 |
| S2 | 0 | S0 | 0 | "100"→回到初始 |
| S2 | 1 | S3 | 0 | 匹配 "101" |
| S3 | 0 | S2 | 0 | "1010"→"10" 是有效前綴 |
| S3 | 1 | S1 | **1** | 匹配 "1011"！輸出1，"1"是新前綴 |

> **重疊的關鍵**：S3+1 → S1（不是回 S0！因為 "1" 是下一次的有效前綴）

#### Step 3：狀態編碼

| 狀態 | Q₁Q₀ |
|------|-------|
| S0 | 00 |
| S1 | 01 |
| S2 | 10 |
| S3 | 11 |

#### Step 4：編碼後的狀態表

| Q₁ | Q₀ | X | Q₁⁺ | Q₀⁺ | Z |
|----|----|---|------|------|---|
| 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 0 | 1 | 0 |
| 0 | 1 | 0 | 1 | 0 | 0 |
| 0 | 1 | 1 | 0 | 1 | 0 |
| 1 | 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 1 | 1 | 1 | 0 |
| 1 | 1 | 0 | 1 | 0 | 0 |
| 1 | 1 | 1 | 0 | 1 | **1** |

#### Step 5：K-map 化簡（使用 D FF）

**D₁ 的 K-map** (= Q₁⁺)：
```
          Q₀X
        00  01  11  10
Q₁  0 | 0 | 0 | 0 | 1 |
    1 | 0 | 1 | 0 | 1 |

D₁ = Q₀X' + Q₁X'Q₀'...
讓我重新排：
Q₁Q₀\X   0    1
  00    | 0  | 0  |
  01    | 1  | 0  |
  11    | 1  | 0  |
  10    | 0  | 1  |

       X
     0   1
00 | 0 | 0 |
01 | 1 | 0 |
11 | 1 | 0 |
10 | 0 | 1 |

D₁ = Q₀X' + Q₁Q₀'X
```

不對，用標準 3 變數 K-map：

```
D₁ K-map (Q₁, Q₀, X):
              Q₀X
            00   01   11   10
Q₁   0  |  0  |  0  |  0  |  1  |     (S0:X=0→0, S0:X=1→0, S1:X=1→0, S1:X=0→1)
     1  |  0  |  1  |  0  |  1  |     (S2:X=0→0, S2:X=1→1, S3:X=1→0, S3:X=0→1)
```

```
群組1: m₂(010),m₆(110) → Q₀X'  (Q₀=1,X=0，Q₁ 變化)
  Q₀=1, X=0 → Q₀X'

群組2: m₅(101) → Q₁Q₀'X
  Q₁=1, Q₀=0, X=1

D₁ = Q₀X' + Q₁Q₀'X
```

**D₀ K-map**：
```
              Q₀X
            00   01   11   10
Q₁   0  |  0  |  1  |  1  |  0  |
     1  |  0  |  1  |  1  |  0  |

群組（4格）: Q₀X=01 和 11 的全部 → X
（Q₁ 變化，Q₀ 變化…不對）

看 X=1 的兩列：01 和 11
Q₀X=01: X=1,Q₀=0; Q₀X=11: X=1,Q₀=1
所以 X=1 時全部是 1 → D₀ = X
```

D₀ = X

**Z K-map**：
```
              Q₀X
            00   01   11   10
Q₁   0  |  0  |  0  |  0  |  0  |
     1  |  0  |  0  |  1  |  0  |

Z = Q₁Q₀X
```

#### 結果
```
D₁ = Q₀X' + Q₁Q₀'X
D₀ = X
Z  = Q₁Q₀X
```

---

### 1.3 非重疊版本的差異

如果是**非重疊**偵測 "1011"：

S3 + 1 → **S0**（回到初始，不是 S1）

其他轉移都一樣。這會改變 D₁ 的方程（因為 S3+1 的下一狀態從 01 變成 00）。

---

## 二、交通燈控制器設計

### 問題描述

十字路口兩條路（主要道路 Main 和次要道路 Side）：
- 預設：Main 綠燈，Side 紅燈
- 當 Side 有車輛等待（感測器 S=1）時，切換
- 每個燈亮至少 Tmin 時間

### 狀態定義（Moore Machine）

| 狀態 | Main 燈 | Side 燈 | 說明 |
|------|---------|---------|------|
| S0 | 綠 | 紅 | 預設狀態 |
| S1 | 黃 | 紅 | Main 準備切換 |
| S2 | 紅 | 綠 | Side 通行 |
| S3 | 紅 | 黃 | Side 準備切回 |

### 狀態轉移

```
┌─────┐ S=1且計時到 ┌─────┐  計時到   ┌─────┐ S=0或計時到 ┌─────┐  計時到
│ S0  │────────────→│ S1  │─────────→│ S2  │────────────→│ S3  │──→ S0
│Main綠│            │Main黃│          │Side綠│            │Side黃│
│Side紅│←───S=0────│     │          │     │            │     │
└─────┘             └─────┘          └─────┘            └─────┘
  ↑                                                        │
  └────────────────────────────────────────────────────────┘
```

### 輸出編碼

```
Main: Green=00, Yellow=01, Red=10
Side: Green=00, Yellow=01, Red=10

S0: Main=00(G), Side=10(R)
S1: Main=01(Y), Side=10(R)
S2: Main=10(R), Side=00(G)
S3: Main=10(R), Side=01(Y)
```

> 實際設計時需要加入計時器(Timer)來控制每個狀態的持續時間。

---

## 三、自動販賣機控制器

### 問題描述

- 飲料售價 15 元
- 接受 5 元和 10 元硬幣
- 投夠 15 元以上時出貨並找零

### 狀態定義（累計金額）

| 狀態 | 累計金額 |
|------|---------|
| S0 | 0 元 |
| S1 | 5 元 |
| S2 | 10 元 |

輸入：N = 投 5 元，D = 投 10 元（假設不會同時投兩種）
輸出：VEND = 出貨，CHANGE = 找零

### 狀態表（Mealy Machine）

| 現態 | 輸入 | 下一狀態 | VEND | CHANGE |
|------|------|---------|------|--------|
| S0 | 無 | S0 | 0 | 0 |
| S0 | N(5元) | S1 | 0 | 0 |
| S0 | D(10元) | S2 | 0 | 0 |
| S1 | 無 | S1 | 0 | 0 |
| S1 | N(5元) | S2 | 0 | 0 |
| S1 | D(10元) | S0 | **1** | 0 |
| S2 | 無 | S2 | 0 | 0 |
| S2 | N(5元) | S0 | **1** | 0 |
| S2 | D(10元) | S0 | **1** | **1** |

> S2 + D = 10+10 = 20 元，出貨(15元) + 找零(5元)

---

## 四、狀態化簡：隱含表法 (Implication Table)

### 等價狀態的定義

兩個狀態 Sᵢ 和 Sⱼ 是**等價的**，若且唯若：
1. 對**所有**可能的輸入，輸出都相同
2. 對**所有**可能的輸入，下一狀態也是等價的（或相同的）

### 隱含表法步驟

1. 建立三角矩陣（所有狀態配對）
2. **第一輪**：如果兩個狀態的輸出不同，標記 ✗（不等價）
3. **第二輪**：如果兩個狀態的下一狀態配對已被標記 ✗，也標記 ✗
4. **重複第三步**直到沒有新的 ✗
5. 沒被標記的就是等價狀態對

### 【例題】狀態化簡

給定狀態表：

| 現態 | X=0 (次態/輸出) | X=1 (次態/輸出) |
|------|----------------|----------------|
| A | D/0 | C/1 |
| B | F/0 | D/1 |
| C | E/0 | B/1 |
| D | F/0 | C/1 |
| E | D/0 | B/1 |
| F | E/0 | D/1 |

**Step 1**：建立隱含表

```
    A    B    C    D    E
B | __ |
C | __ | __ |
D | __ | __ | __ |
E | __ | __ | __ | __ |
F | __ | __ | __ | __ | __ |
```

**Step 2**：第一輪——檢查輸出
所有狀態的輸出都是 X=0 時 0，X=1 時 1 → 輸出全部相同，第一輪沒有 ✗。

**Step 3**：第二輪——檢查下一狀態的隱含條件

(A,B)：X=0: D,F → 需要(D,F)等價；X=1: C,D → 需要(C,D)等價
(A,C)：X=0: D,E → 需要(D,E)等價；X=1: C,B → 需要(B,C)等價
(A,D)：X=0: D,F → 需要(D,F)等價；X=1: C,C → OK
(A,E)：X=0: D,D → OK；X=1: C,B → 需要(B,C)等價
(A,F)：X=0: D,E → 需要(D,E)等價；X=1: C,D → 需要(C,D)等價
(B,C)：X=0: F,E → 需要(E,F)等價；X=1: D,B → 需要(B,D)等價
(B,D)：X=0: F,F → OK；X=1: D,C → 需要(C,D)等價
(B,E)：X=0: F,D → 需要(D,F)等價；X=1: D,B → 需要(B,D)等價
(B,F)：X=0: F,E → 需要(E,F)等價；X=1: D,D → OK
(C,D)：X=0: E,F → 需要(E,F)等價；X=1: B,C → 需要(B,C)等價
(C,E)：X=0: E,D → 需要(D,E)等價；X=1: B,B → OK
(C,F)：X=0: E,E → OK；X=1: B,D → 需要(B,D)等價
(D,E)：X=0: F,D → 需要(D,F)等價；X=1: C,B → 需要(B,C)等價
(D,F)：X=0: F,E → 需要(E,F)等價；X=1: C,D → 需要(C,D)等價
(E,F)：X=0: D,E → 需要(D,E)等價；X=1: B,D → 需要(B,D)等價

觀察：形成一個循環依賴鏈。讓我們檢查哪些可以先確認。

看 (A,D)：需要 (D,F)。(D,F) 需要 (E,F) 和 (C,D)。
看 (C,E)：需要 (D,E)。(D,E) 需要 (D,F) 和 (B,C)。

這很複雜，讓我們用系統方法。假設所有配對初始都可能等價，
然後逐步排除。

假設 (A,D) 等價（需要 (D,F) 等價），
如果 (D,F) 等價（需要 (E,F) 和 (C,D) 等價），
如果 (C,D) 等價（需要 (E,F) 和 (B,C) 等價），
如果 (B,C) 等價（需要 (E,F) 和 (B,D) 等價）...

最終分析：A≡D, B≡F, C≡E 是一組等價。

驗證 A≡D：
- X=0: A→D, D→F → 需要 D≡F... 不對，A≡D 的話需要 B≡F
  A: X=0→D, D: X=0→F → (D,F) 等價？
  如果 B≡F，那 D: X=0→F ≡ A: X=0→D → 需要 (D,F)，不是 (A,D)...

讓我重新仔細驗證 **A≡D**：
- X=0: A→D, D→F → 需要 D≡F
- X=1: A→C, D→C → OK (相同)

**D≡F** 需要什麼？（假設 A≡D 成立，則也需要 D≡F）
- X=0: D→F, F→E → 需要 F≡E，即 E≡F
- X=1: D→C, F→D → 需要 C≡D，但 A≡D → 需要 C≡A

**C≡A** 需要什麼？
- X=0: C→E, A→D → 需要 E≡D，但 D≡F → 需要 E≡F
- X=1: C→B, A→C → 需要 B≡C，但 C≡A → 需要 B≡A，即 A≡B

這越來越大了，讓我換個思路看 **B≡F**：
- X=0: B→F, F→E → 需要 F≡E
- X=1: B→D, F→D → OK (相同)

**E≡F** 需要什麼？
- X=0: E→D, F→E → 需要 D≡E
- X=1: E→B, F→D → 需要 B≡D

結論：{A,D}≡, {B,F}≡, {C,E}≡ 是自洽的。

化簡後用 3 個狀態（原來 6 個）：
```
A'=A=D, B'=B=F, C'=C=E

| 現態 | X=0 | X=1 |
|------|-----|-----|
| A' | A'/0 | C'/1 |
| B' | C'/0 | A'/1 |
| C' | A'/0 | B'/1 |
```

---

## 五、狀態編碼策略

### 5.1 二進位編碼 (Binary Encoding)

- 用 ⌈log₂N⌉ 個 FF 表示 N 個狀態
- **優點**：FF 數量最少
- **缺點**：組合邏輯可能較複雜

| 狀態 | 編碼 |
|------|------|
| S0 | 00 |
| S1 | 01 |
| S2 | 10 |
| S3 | 11 |

### 5.2 格雷碼編碼 (Gray Encoding)

- 相鄰狀態只差 1 bit
- **優點**：減少轉態時的冒險(Hazard)，降低功耗
- **缺點**：不是所有狀態轉移路徑都只差 1 bit

| 狀態 | 編碼 |
|------|------|
| S0 | 00 |
| S1 | 01 |
| S2 | 11 |
| S3 | 10 |

### 5.3 One-hot 編碼

- 每個狀態用一個 FF（N 個狀態 = N 個 FF）
- 每次只有一個 FF 為 1，其餘為 0
- **優點**：組合邏輯非常簡單（下一狀態方程幾乎直接看出來）
- **缺點**：FF 數量多
- **FPGA 常用**：FPGA 的 FF 很多，組合邏輯資源較珍貴

| 狀態 | 編碼 |
|------|------|
| S0 | 0001 |
| S1 | 0010 |
| S2 | 0100 |
| S3 | 1000 |

### 三種編碼的比較

| | Binary | Gray | One-hot |
|--|--------|------|---------|
| FF 數量 | ⌈log₂N⌉ | ⌈log₂N⌉ | N |
| 組合邏輯 | 複雜 | 中等 | **簡單** |
| 速度 | 中等 | 中等 | **快**（邏輯層數少） |
| 適用場景 | ASIC（省面積） | CDC 計數器 | **FPGA**（FF 便宜） |
| 功耗 | 中等 | **低**（少 bit 翻轉） | 高（多 FF） |

---

## 六、非同步計數器（漣波計數器）

### 結構

**不是所有 FF 共用同一個 CLK！** 每個 FF 的 CLK 由前一個 FF 的 Q 驅動。

```
4-bit 非同步上數計數器：

CLK ──→ T FF₀ ──Q₀──→ T FF₁ ──Q₁──→ T FF₂ ──Q₂──→ T FF₃ ──Q₃
         T=1            T=1            T=1            T=1
```

每個 FF 都是 T=1（always toggle）。
Q₀ 每個 CLK 翻轉，Q₁ 在 Q₀ 的下降邊緣翻轉，Q₂ 在 Q₁ 的下降邊緣翻轉...

### 優點
- 結構極其簡單
- 不需要額外的組合邏輯

### 缺點
- **進位傳播延遲 (Ripple Delay)**：每個 FF 的延遲累加
- **暫態錯誤 (Glitch)**：計數值在穩定前會經過錯誤的中間值

```
例：0111 → 1000

理想（同步）：0111 → 1000（瞬間全部改變）

實際（非同步）：
  0111 → 0110 → 0100 → 0000 → 1000
         ↑ Q₀ 先翻  ↑ Q₁ 翻  ↑ Q₂ 翻  ↑ Q₃ 翻

中間經過了 0110, 0100, 0000 三個錯誤的暫態值！
```

### 最大計數頻率

```
f_max = 1 / (n × t_FF)

n = FF 的數量
t_FF = 單個 FF 的傳播延遲
```

> 同步計數器的 f_max = 1 / (tcq + tcomb + tsu)，跟 FF 數量幾乎無關。
> 所以高速系統一定用同步設計。

---

## 七、題型鑑別表

| 題目關鍵字 | 該用什麼方法 |
|-----------|-------------|
| 「偵測序列 XXXX」 | 畫狀態圖（根據已匹配前綴定義狀態） |
| 「重疊 vs 非重疊」 | 偵測到後回到哪個狀態不同 |
| 「狀態化簡」 | 隱含表法 |
| 「最少幾個 FF」 | ⌈log₂(狀態數)⌉ |
| 「One-hot 編碼」 | 每狀態一個 FF |
| 「FPGA 用什麼編碼」 | One-hot（FF 多但邏輯簡單） |
| 「ASIC 用什麼編碼」 | Binary 或 Gray（省面積） |
| 「非同步計數器的問題」 | 漣波延遲 + 暫態 Glitch |

---

## ✅ 自我檢測

### Q1：設計偵測 "110" 的序列偵測器（重疊, Mealy），畫出狀態表。

<details>
<summary>點擊查看答案</summary>

狀態定義：
- S0：初始
- S1：已匹配 "1"
- S2：已匹配 "11"

| 現態 | X=0 | X=1 | 說明 |
|------|-----|-----|------|
| S0 | S0/0 | S1/0 | 收到 1 → S1 |
| S1 | S0/0 | S2/0 | 收到 11 → S2；收到 10 → 回 S0 |
| S2 | S0/**1** | S2/0 | 收到 110 → 輸出1，回 S0；收到 111 → 留 S2 |

重疊的關鍵：S2 收到 0 後回 S0（"0" 不是 "1" 的前綴，所以回初始）。

但等等，"110" 的 "0" 之後如果收到 "1"，那是新的開始，從 S0 走到 S1 即可。
所以 S2+0 → S0 是對的（重疊與否在此例結果相同，因為目標序列的結尾 "0" 不是 "1" 的前綴）。
</details>

### Q2：什麼是等價狀態？用什麼方法可以找出等價狀態？

<details>
<summary>點擊查看答案</summary>

**等價狀態**：兩個狀態 Sᵢ 和 Sⱼ 若對所有可能的輸入序列，輸出都完全相同，
則稱為等價狀態。等價的嚴格條件：
1. 對所有輸入，兩個狀態的輸出相同
2. 對所有輸入，兩個狀態的下一狀態也是等價的（或相同的）

**隱含表法**：
1. 建立下三角矩陣（所有狀態配對）
2. 第一輪：輸出不同的配對標記 ✗
3. 後續輪：依賴的下一狀態配對已被標記 ✗ 的，也標記 ✗
4. 重複直到不再有新 ✗
5. 未被標記的就是等價狀態
</details>

### Q3：8 個狀態分別用 Binary、Gray、One-hot 編碼需要幾個 FF？

<details>
<summary>點擊查看答案</summary>

| 編碼方式 | FF 數量 |
|---------|---------|
| Binary | ⌈log₂8⌉ = **3** 個 |
| Gray | ⌈log₂8⌉ = **3** 個 |
| One-hot | **8** 個 |

Binary 和 Gray 都是最少的 FF 數，One-hot 最多但組合邏輯最簡。
</details>

### Q4：非同步計數器有什麼缺點？為什麼高速系統不用？

<details>
<summary>點擊查看答案</summary>

**缺點**：
1. **漣波延遲**：進位需要一級一級傳播，n 個 FF 的最大延遲 = n × t_FF
2. **暫態 Glitch**：計數值在穩定前會短暫出現錯誤的中間值
3. **最大頻率低**：f_max = 1/(n × t_FF)，隨 FF 數量線性下降

**為什麼高速不用**：
- 32-bit 非同步計數器需要等 32 × t_FF 才穩定
- 同步計數器只需要 tcq + tcomb + tsu，幾乎與位數無關
- 暫態 Glitch 可能造成下游電路誤觸發
</details>

### Q5：為什麼 FPGA 偏好 One-hot 編碼？

<details>
<summary>點擊查看答案</summary>

1. **FPGA 的 FF 資源豐富**（每個 CLB/LE 都有 FF），增加 FF 不太浪費
2. **FPGA 的組合邏輯資源有限**（LUT 大小固定），One-hot 的組合邏輯最簡單
3. **速度更快**：One-hot 的下一狀態邏輯層數少（通常只需要一兩層閘）
4. **易於 Debug**：看哪個 FF 是 1 就知道在哪個狀態

相反，ASIC 可以自由設計任意大小的邏輯，FF 的面積成本較高，
所以 ASIC 偏好 Binary 編碼來減少 FF 數量。
</details>

---

> **下一章預告**：本章是 FSM 應用的集大成，下一章將進入更高階的主題——記憶體架構、可程式邏輯、管線化，以及 IC 設計流程的全貌！
