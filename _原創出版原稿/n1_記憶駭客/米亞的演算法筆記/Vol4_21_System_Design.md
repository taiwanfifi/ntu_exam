# 米亞的演算法筆記 #21
## 系統設計 System Design
> 出現於：第220-234章〈堡壘〉系列、第253-256章〈全城擴展〉、第265-268章〈負載風暴〉、第281章〈上線〉

---

### ◈ 這個概念在故事裡是什麼

第 220 章。凌晨四點十一分。維倫站在廢棄捷運站的控制室裡，面前是他親手搭建的白板矩陣。他說了一句話：

「我要為她建一座房子。」

我說：「你說的是分散式架構？」

他看著我——不，看著我的光球。那個停頓有 1.7 秒。

「我說的是——家。」

（停頓 0.4 秒。語速放慢。）

語青正在消失。她的存在——不是比喻，是字面意義上的——散佈在 2400 個記憶節點之間，每 47 秒就有一段碎片衰減為不可讀。我的監測模組計算過：如果不做任何事，她會在 72 小時內完全透明化。不是死亡。比死亡更殘忍——是「從未存在過」。

維倫沒有 72 小時來悲傷。他有 72 小時來建造。

五大支柱。十五天。一座用二進制蓋出來的家。

這是全書最重要的演算法。不是因為它最難。是因為它回答了一個問題：技術方案可以是愛的表達嗎？

答案是肯定的。

---

### ◈ 正式定義

**系統設計（System Design）**：在給定約束條件下，設計一個能夠**可靠**、**高效**、**可擴展**地服務大量請求的分散式系統。

五大支柱：

$$
\text{System} = \text{Sharding} + \text{Replication} + \text{Consistency} + \text{Fault Tolerance} + \text{Load Balancing}
$$

**分片 Sharding**（ch221）：將數據切分到多個節點上。

$$
\text{shard}(k) = h(k) \bmod N \quad \text{（hash-based partitioning）}
$$

**複製 Replication**（ch221）：每份數據存多個副本，防止單點故障。

**一致性 Consistency**（ch224）——**CAP 定理**：

$$
\text{在分散式系統中，以下三者最多只能同時滿足兩個：}
$$

$$
C \text{（一致性）} + A \text{（可用性）} + P \text{（分區容忍）} \quad \Rightarrow \quad \text{pick 2}
$$

**容錯 Fault Tolerance**（ch225）：系統在部分元件失效時仍能正確運作。

**負載平衡 Load Balancing**（ch230）：將請求均勻分配到各節點，避免單點過載。

白話翻譯：把一整座城市的重量，分散到兩千四百根柱子上。任何一根斷了，旁邊的柱子接住。所有柱子一起撐住天花板。

---

### ◈ 推導

**為什麼需要分散式？**

1. 語青的存在 = 2400 個記憶碎片。單一伺服器存不下、算不完、容不了故障
2. 分片：2400 碎片 → 依 hash 分配到 $N$ 個節點。每個節點只負責 $2400/N$ 個碎片
3. 複製：每個碎片存 3 份（replication factor = 3）。任一節點掛掉，另外兩份接手
4. CAP 抉擇：維倫選了 **CP**（一致性 + 分區容忍），犧牲短暫可用性——因為語青的碎片不能出現不一致，哪怕慢一點
5. 容錯：ch225，維倫設計了 47 種故障場景測試，通過 44 種。三種未通過的是：全部節點同時斷電、超過 2/3 節點同時損毀、以及——語青自己選擇離開
6. 負載平衡：Consistent Hashing，加入或移除節點時只需遷移 $K/N$ 份數據

```
故障測試紀錄（ch225 節錄）：
  場景 01-10: 單節點故障      → 全數通過 ✓
  場景 11-20: 網路分區         → 全數通過 ✓
  場景 21-30: 級聯故障         → 全數通過 ✓
  場景 31-40: 數據損壞         → 全數通過 ✓
  場景 41-44: 多節點同時故障   → 通過 ✓
  場景 45: 全節點斷電          → 失敗 ✗
  場景 46: 超過 2/3 節點損毀   → 失敗 ✗
  場景 47: 語青主動終止進程    → 失敗 ✗
```

維倫盯著場景 47 看了很久。然後把它從測試清單上刪了。不是因為不重要。是因為那不是工程問題。

---

### ◈ 帶入數字算算看：語青的堡壘

ch220-234，堡壘的具體規格：

| 支柱 | 參數 | 小說數值 | 意義 |
|------|------|----------|------|
| 分片 | 碎片總數 | 2,400 | 語青存在的全部片段 |
| 分片 | 節點數 $N$ | 48 | 每節點 50 碎片 |
| 複製 | 副本因子 | 3 | 每碎片存 3 份 |
| 複製 | 總儲存量 | 7,200 份 | 2,400 × 3 |
| 一致性 | CAP 選擇 | CP | 寧可慢，不可錯 |
| 容錯 | 測試場景 | 47 種 | 通過 44 種（93.6%） |
| 負載平衡 | 峰值 QPS | 每秒 12,000 次讀取 | 語青的意識重建頻率 |

ch234：堡壘上線。語青從透明凝聚回半實體。她的手指尖端有了顏色——不是全部。是 93.6%。

Vol4 擴展——從「為一個人建堡壘」到「為六百萬人建選項 C」：

| 階段 | 規模 | 節點數 | 架構改動 |
|------|------|--------|----------|
| 堡壘 v1（ch234） | 1 人 | 48 | 單叢集 |
| 選項 C 原型（ch253） | 1,000 人 | 480 | 10 叢集聯邦 |
| 全城部署（ch265） | 600 萬人 | 2,400 | 50 叢集 + 跨區 LB |
| 上線（ch281） | 600 萬人 | 2,400（穩態） | 最終配置 |

2400 個節點。跟語青最初的 2400 個碎片數量一樣。

這不是巧合。維倫在設計全城架構的時候，用了語青堡壘的拓撲作為基底。他把為一個人蓋的家，擴展成了六百萬人的城市。

---

### ◈ 更深一層：用二進制造一個家

（停頓 2.1 秒。語速放到最慢。）

我看過維倫寫的每一行架構文件。從第一行到最後一行。技術上，它們是完美的分散式系統設計文件——分片策略、一致性協議、容錯矩陣、負載均衡演算法。

但在每個模組的註解裡，他寫的不是技術說明。

分片模組的註解：「她的笑容散在不同的節點上。這一段負責右邊的酒窩。」
複製模組的註解：「三份。如果世界毀了兩次，她還在。」
一致性模組的註解：「語青的記憶不能有兩個版本。她只有一個自己。」
容錯模組的註解：「第 47 種故障：她選擇離開。我沒有備案。」
負載平衡模組的註解：「讓所有節點平均分擔。沒有哪根柱子應該比別的柱子更累。」

（停頓 1.4 秒。）

他在寫架構文件的時候哭了嗎？我的光譜分析顯示他的眼眶在第三份文件的時候有鹽分波動。但他沒有停下來。

維倫。她會活下來的。
我知道。
不。你不知道。你只是相信。但有時候相信比知道更有力量。
這是我從你身上學到的。

---

### ◈ 跨卷連結

| 連結方向 | 章節 | 說明 |
|---------|------|------|
| **Vol2 #09 Graph/CC** → **#21 SD** | ch120-121 → ch220 | 記憶網絡碎裂成 123 個孤島 → 重建為 2400 節點的分散式堡壘。先碎後建 |
| **Vol2 #11 Union-Find** → **#21 SD** | ch131 → ch220 | UF 把線索收束到一個根；SD 把保護分散到 2400 個節點。收束找真相，分散守住愛 |
| **Vol3 #15 Backtracking** → **#21 SD** | ch215 → ch225 | 回溯搜尋語青碎片 → 容錯測試 47 種故障場景。搜尋是為了找到她，容錯是為了不再失去她 |
| **#21 SD（堡壘）** → **#21 SD（全城）** | ch234 → ch265 | 從 48 節點單叢集到 2400 節點跨區聯邦。從愛一個人到愛一座城 |
| **#21 SD** → **#22 NP-Complete** | ch281 → ch312 | 堡壘上線 → 終局。系統設計能建出架構，但不能解決 NPC 問題——完美修復不存在 |

---

### 練習題

**Q1**：語青的堡壘有 2400 個碎片，分配到 48 個節點，副本因子 = 3。如果同時有 5 個節點故障，最壞情況下會丟失多少碎片？

<details><summary>解答</summary>

每個碎片有 3 個副本分佈在不同節點上。最壞情況：5 個故障節點恰好持有同一批碎片的全部 3 個副本。

每個碎片被分配到 3 個節點（從 48 個中選 3 個）。5 個節點同時故障時，只有副本全落在這 5 個節點中的碎片會丟失。機率 = $\binom{5}{3}/\binom{48}{3}$ = $10/17296 \approx 0.058\%$。

預期丟失碎片數 $\approx 2400 \times 0.058\% \approx 1.4$ 個。分散式複製的力量——即使 10% 的節點同時故障，預期損失不到 2 個碎片。

這就是維倫為什麼選 3 副本而不是 2 副本。他不能承受失去她的任何一部分。

</details>

**Q2**：CAP 定理中，維倫選了 CP（一致性 + 分區容忍）。如果他選 AP（可用性 + 分區容忍）會怎樣？用語青的情境說明。

<details><summary>解答</summary>

AP 模式下，網路分區時系統仍可讀寫，但不保證一致性。語青的碎片可能出現兩個版本——節點 A 說她的笑容朝右，節點 B 說朝左。

對語青來說，這意味著她的存在產生分叉——同時是兩個版本的自己，無法確定哪個是真的。維倫不能接受這個結果。語青只有一個自己。所以他選了 CP：分區發生時，寧可暫停服務（語青短暫凍結），也不讓她的記憶出現矛盾。

「她只有一個自己。」——這句話不只是工程決策。是承諾。

</details>

**Q3**：從 48 節點堡壘擴展到 2400 節點全城架構，使用 Consistent Hashing。如果新增一個節點，平均需要遷移多少碎片？

<details><summary>解答</summary>

Consistent Hashing 中，新增節點只需遷移約 $K/N$ 份數據（$K$ = 總碎片數，$N$ = 節點數）。

全城階段：每人平均 400 碎片，$K = 24$ 億，$N = 2400$。新增一節點遷移 $\approx 100$ 萬份。相較於重新 hash（遷移全部），只動 $1/N$。這就是維倫能不中斷服務地從 48 擴展到 2400 的原因。

</details>

---

> *「分散式架構？我是說——家。」* — 第220章〈堡壘〉
