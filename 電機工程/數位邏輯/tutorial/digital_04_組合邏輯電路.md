# 數位邏輯教學講義 第四章：組合邏輯電路

---

## 🔰 **本章基礎觀念（零基礎必讀）**

前幾章我們學了數字表示、邏輯閘、布林代數和化簡方法。這一章要把它們組合起來，
設計出真正能「做事」的電路：加法器能做加法、解碼器能選訊號、多工器能切換資料。
這些都是**組合邏輯電路**——輸出只取決於「當下的輸入」，沒有記憶功能。

> **學完本章，你應該能做到：**
> 1. 區分組合邏輯與循序邏輯
> 2. 從規格出發，完成「規格→真值表→化簡→電路」的設計流程
> 3. 理解半加器、全加器、加法器、減法器的原理
> 4. 掌握解碼器、編碼器、多工器、解多工器的功能與應用
> 5. 知道什麼是冒險(Hazard)及如何避免

---

## 關鍵術語表

| 中文 | 英文 | 白話解釋 | 例子 |
|------|------|----------|------|
| 組合邏輯 | Combinational Logic | 輸出只看現在的輸入 | 加法器 |
| 循序邏輯 | Sequential Logic | 輸出還看過去的狀態（有記憶） | 計數器 |
| 半加器 | Half Adder (HA) | 兩個 1-bit 數相加，不處理進位輸入 | S=A⊕B, C=AB |
| 全加器 | Full Adder (FA) | 兩個 1-bit 數加上進位輸入 | 考慮 Cin |
| 漣波進位 | Ripple Carry | 進位一級一級傳遞 | 簡單但慢 |
| 超前進位 | Carry Lookahead (CLA) | 預先計算所有進位 | 快但硬體多 |
| 解碼器 | Decoder | n 輸入選出 2ⁿ 之一 | 3-to-8 Decoder |
| 編碼器 | Encoder | 2ⁿ 輸入編碼成 n 位 | 8-to-3 Encoder |
| 多工器 | MUX (Multiplexer) | 多個輸入選一個輸出 | 4-to-1 MUX |
| 解多工器 | DEMUX (Demultiplexer) | 一個輸入分配到多個輸出之一 | 1-to-4 DEMUX |
| 冒險 | Hazard / Glitch | 輸入改變時輸出短暫跳動 | 靜態冒險 |

---

## 一、組合邏輯 vs 循序邏輯

| 特性 | 組合邏輯 | 循序邏輯 |
|------|---------|---------|
| 記憶功能 | 無 | 有（靠正反器） |
| 輸出取決於 | 當前輸入 | 當前輸入 + 過去狀態 |
| 回授路徑 | 無 | 有 |
| 例子 | 加法器、MUX | 計數器、暫存器 |

**判斷方法**：如果電路中有**回授 (Feedback)** 或**儲存元件**（如 Flip-Flop），就是循序邏輯。

---

## 二、設計流程

### 分析（已有電路 → 理解功能）
```
電路圖 → 寫出布林式 → 建立真值表 → 理解功能
```

### 設計（有需求 → 建立電路）
```
規格描述 → 建立真值表 → 用K-map化簡 → 畫出電路圖
```

---

## 三、半加器 (Half Adder) 與全加器 (Full Adder)

### 3.1 半加器 (HA)

**功能**：兩個 1-bit 數 A、B 相加，產生 Sum (S) 和 Carry (C)。

| A | B | S (Sum) | C (Carry) |
|---|---|---------|-----------|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 1 | 0 |
| 1 | 1 | 0 | 1 |

```
S = A ⊕ B    （XOR）
C = A · B    （AND）
```

```
電路圖：
A ──┬──[XOR]── S
    │
B ──┼──[XOR]
    │
    ├──[AND]── C
    │
    └──[AND]
```

**限制**：半加器不能處理來自前一位的進位！

### 3.2 全加器 (FA)

**功能**：兩個 1-bit 數 A、B 加上前一位的進位 Cᵢₙ，產生 Sum 和 Cₒᵤₜ。

| A | B | Cᵢₙ | S | Cₒᵤₜ |
|---|---|------|---|-------|
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 0 |
| 0 | 1 | 0 | 1 | 0 |
| 0 | 1 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 | 0 |
| 1 | 0 | 1 | 0 | 1 |
| 1 | 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 1 | 1 |

```
S    = A ⊕ B ⊕ Cᵢₙ
Cₒᵤₜ = AB + BCᵢₙ + ACᵢₙ = AB + (A⊕B)Cᵢₙ
```

> **記憶技巧**：
> - Sum = 三個輸入的 XOR（奇數個 1 就是 1）
> - Carry = 三個輸入中任兩個為 1 就進位（多數決）

### 3.3 用兩個半加器組成全加器

```
          ┌────────┐
A ────────┤        ├── S₁ ───┐
          │  HA1   │         ├──[XOR]── S
B ────────┤        ├── C₁   │
          └────────┘         │
                    Cᵢₙ ────┘
                             │
          ┌────────┐         │
S₁ ──────┤        ├── S₂   (就是上面的 S)
          │  HA2   │
Cᵢₙ ─────┤        ├── C₂ ──┐
          └────────┘         ├──[OR]── Cₒᵤₜ
                    C₁ ──────┘
```

---

## 四、漣波進位加法器 (Ripple Carry Adder)

**功能**：把多個全加器串接，做 n-bit 加法。

```
4-bit Ripple Carry Adder:

A₃B₃   A₂B₂   A₁B₁   A₀B₀
 │ │     │ │     │ │     │ │
 ▼ ▼     ▼ ▼     ▼ ▼     ▼ ▼
┌────┐  ┌────┐  ┌────┐  ┌────┐
│FA₃ │←─│FA₂ │←─│FA₁ │←─│FA₀ │←─ C₀(通常=0)
└────┘  └────┘  └────┘  └────┘
C₄ S₃    │ S₂    │ S₁    │ S₀
│         │       │       │
▼         ▼       ▼       ▼

結果：C₄ S₃ S₂ S₁ S₀
```

**優點**：結構簡單，每個 FA 都一樣
**缺點**：進位要一級一級傳（Ripple），n-bit 加法器的延遲 = n × (單個 FA 的進位延遲)

> 對 32-bit 加法器來說，進位傳了 32 級，太慢了！

---

## 五、超前進位加法器 (Carry Lookahead Adder, CLA)

### 核心概念

不要等進位一級級傳，而是**預先計算每一位的進位**。

定義兩個信號：
```
生成 (Generate): Gᵢ = AᵢBᵢ     （本位自己產生進位）
傳播 (Propagate): Pᵢ = Aᵢ ⊕ Bᵢ  （本位傳遞前一位的進位）
```

進位的遞推公式：
```
Cᵢ₊₁ = Gᵢ + Pᵢ · Cᵢ
```

展開：
```
C₁ = G₀ + P₀C₀
C₂ = G₁ + P₁C₁ = G₁ + P₁G₀ + P₁P₀C₀
C₃ = G₂ + P₂G₁ + P₂P₁G₀ + P₂P₁P₀C₀
C₄ = G₃ + P₃G₂ + P₃P₂G₁ + P₃P₂P₁G₀ + P₃P₂P₁P₀C₀
```

**每個 Cᵢ 都只是 G、P、C₀ 的兩層邏輯 → 延遲固定，不隨位數增加！**

**代價**：硬體複雜度增加（扇入變大）

| | Ripple Carry | CLA |
|--|-------------|-----|
| 延遲 | O(n) | O(1) for each group |
| 硬體 | 少 | 多 |
| 適用場景 | 低速、小位數 | 高速處理器 |

---

## 六、減法器（利用 2's Complement）

**A - B = A + (-B) = A + (B的2's complement) = A + B' + 1**

```
加減法共用電路：

控制信號 M：
  M=0 → 加法（A+B）
  M=1 → 減法（A-B = A+B'+1）

B₃  B₂  B₁  B₀
│   │   │   │
⊕M  ⊕M  ⊕M  ⊕M    ← M=1時反轉B（得B'）
│   │   │   │
FA₃ FA₂ FA₁ FA₀ ← C₀=M（M=1時+1，完成2's complement）
│   │   │   │
S₃  S₂  S₁  S₀
```

> 就是一個加法器加上 4 個 XOR 閘和一個控制線！

---

## 七、比較器 (Comparator)

### 1-bit 比較器

比較 A 和 B 的大小：

| A | B | A>B | A=B | A<B |
|---|---|-----|-----|-----|
| 0 | 0 | 0 | 1 | 0 |
| 0 | 1 | 0 | 0 | 1 |
| 1 | 0 | 1 | 0 | 0 |
| 1 | 1 | 0 | 1 | 0 |

```
(A>B) = AB'
(A=B) = A⊙B = AB + A'B'（XNOR）
(A<B) = A'B
```

### n-bit 比較器

從 MSB 開始比較，一旦某一位不同，就決定大小：
- 7483 / 74HC85 是常見的 4-bit 比較器 IC

---

## 八、解碼器 (Decoder)

### 功能

n 條輸入 → 2ⁿ 條輸出中**恰好有一條為 1**

### 2-to-4 解碼器

| A₁ | A₀ | D₃ | D₂ | D₁ | D₀ |
|----|----|----|----|----|-----|
| 0 | 0 | 0 | 0 | 0 | **1** |
| 0 | 1 | 0 | 0 | **1** | 0 |
| 1 | 0 | 0 | **1** | 0 | 0 |
| 1 | 1 | **1** | 0 | 0 | 0 |

```
D₀ = A₁'A₀'  (= m₀)
D₁ = A₁'A₀   (= m₁)
D₂ = A₁A₀'   (= m₂)
D₃ = A₁A₀    (= m₃)
```

> **每個輸出就是一個最小項！** 這就是為什麼解碼器可以用來實現任何布林函數。

### 用 Decoder 實現任意布林函數

**F(A,B,C) = Σm(1,2,6,7)**

接一個 3-to-8 Decoder，把 D₁, D₂, D₆, D₇ 用 OR 閘接起來。

```
        ┌──────────┐
A ──────┤          ├── D₀
B ──────┤ 3-to-8   ├── D₁ ──┐
C ──────┤ Decoder  ├── D₂ ──┤
        │          ├── D₃   ├── OR ── F
        │          ├── D₄   │
        │          ├── D₅   │
        │          ├── D₆ ──┤
        │          ├── D₇ ──┘
        └──────────┘
```

### 帶致能(Enable)的解碼器

加一個 Enable (E) 輸入：E=1 時正常工作，E=0 時所有輸出為 0。
可以用小解碼器串接成大解碼器：

```
用兩個 3-to-8 Decoder 和一個反相器 → 4-to-16 Decoder
第4個輸入控制哪個 Decoder 被致能。
```

---

## 九、編碼器 (Encoder) 與優先編碼器 (Priority Encoder)

### 一般編碼器

2ⁿ 個輸入中**恰好有一個為 1** → 輸出其編號（n-bit）

**限制**：如果同時有多個輸入為 1，結果不正確。

### 優先編碼器 (Priority Encoder)

**解決多個輸入同時為 1 的問題**：按優先順序，輸出最高優先的那個。

4-to-2 Priority Encoder（D₃ 優先最高）：

| D₃ | D₂ | D₁ | D₀ | A₁ | A₀ | V (有效) |
|----|----|----|----|----|-----|---------|
| 0 | 0 | 0 | 0 | X | X | 0 |
| 0 | 0 | 0 | 1 | 0 | 0 | 1 |
| 0 | 0 | 1 | X | 0 | 1 | 1 |
| 0 | 1 | X | X | 1 | 0 | 1 |
| 1 | X | X | X | 1 | 1 | 1 |

> X 代表「不管是 0 或 1 都沒差」，因為更高優先的已經決定了。

---

## 十、多工器 (MUX)

### 功能

2ⁿ 個資料輸入 + n 個選擇線 → **選出其中一個輸出**

「資料的切換開關」

### 2-to-1 MUX

```
F = S'·I₀ + S·I₁

S=0 → F=I₀
S=1 → F=I₁
```

### 4-to-1 MUX

```
F = S₁'S₀'·I₀ + S₁'S₀·I₁ + S₁S₀'·I₂ + S₁S₀·I₃
```

| S₁ | S₀ | F |
|----|-----|---|
| 0 | 0 | I₀ |
| 0 | 1 | I₁ |
| 1 | 0 | I₂ |
| 1 | 1 | I₃ |

### 用 MUX 實現任意布林函數（★重要技巧）

**方法一：用 2ⁿ-to-1 MUX 實現 n 變數函數**

直接把真值表的輸出接到 MUX 的資料輸入。

**F(A,B,C) = Σm(1,3,5,6)**

用 8-to-1 MUX，A、B、C 接選擇線：
```
I₀=0, I₁=1, I₂=0, I₃=1, I₄=0, I₅=1, I₆=1, I₇=0
```

**方法二：用 2ⁿ⁻¹-to-1 MUX 實現 n 變數函數（省一半）**

把最後一個變數（通常選 LSB）放入資料輸入，而不接選擇線。

**【例題 1】用 4-to-1 MUX 實現 F(A,B,C) = Σm(1,3,5,6)**

選 A、B 接選擇線（S₁=A, S₀=B），C 放入資料輸入：

| A | B | C=0 時 F | C=1 時 F | 資料輸入 |
|---|---|---------|---------|---------|
| 0 | 0 | m₀=0 | m₁=1 | I₀ = C |
| 0 | 1 | m₂=0 | m₃=1 | I₁ = C |
| 1 | 0 | m₄=0 | m₅=1 | I₂ = C |
| 1 | 1 | m₆=1 | m₇=0 | I₃ = C' |

```
S₁=A, S₀=B
I₀=C, I₁=C, I₂=C, I₃=C'
```

---

## 十一、解多工器 (DEMUX)

### 功能

1 個資料輸入 + n 個選擇線 → 資料被送到 **2ⁿ 個輸出之一**

「MUX 的反向操作」

### 1-to-4 DEMUX

| S₁ | S₀ | Y₃ | Y₂ | Y₁ | Y₀ |
|----|----|----|----|----|-----|
| 0 | 0 | 0 | 0 | 0 | D |
| 0 | 1 | 0 | 0 | D | 0 |
| 1 | 0 | 0 | D | 0 | 0 |
| 1 | 1 | D | 0 | 0 | 0 |

```
Y₀ = S₁'S₀'·D
Y₁ = S₁'S₀·D
Y₂ = S₁S₀'·D
Y₃ = S₁S₀·D
```

> **觀察**：帶 Enable 的 Decoder 就是 DEMUX（Enable 當作資料輸入）。

---

## 十二、競爭與冒險 (Hazard)

### 什麼是 Hazard？

由於邏輯閘有**傳播延遲**，當輸入改變時，輸出可能會出現**短暫的錯誤脈衝 (Glitch)**。

### 靜態冒險 (Static Hazard)

- **Static-1 Hazard**：輸出應該一直是 1，但短暫跳到 0
- **Static-0 Hazard**：輸出應該一直是 0，但短暫跳到 1

### Static-1 Hazard 的例子

```
F = AC + A'B   （假設 A=1, B=1, C=1 → F=1）

當 A 從 1 變 0 時：
  AC: 1→0（A 變 0 後）
  A'B: 0→1（A' 從 0 變 1 有延遲）

  中間有一小段時間 AC=0 且 A'B 還沒變成 1 → F 短暫=0 → Glitch!
```

### 如何在 K-map 上偵測？

如果兩個相鄰的質含項之間沒有重疊覆蓋，它們的邊界就可能有冒險。

### 解決方法

加入**冗餘項**，確保相鄰的 PI 有重疊：
```
F = AC + A'B + BC    （加入共識項 BC）
```
這樣 A 改變時，BC 仍為 1，不會有 Glitch。

---

## 十三、題型鑑別表

| 題目關鍵字 | 該用什麼方法 |
|-----------|-------------|
| 「設計 n-bit 加法器」 | 串接 n 個全加器 |
| 「CLA 的 G 和 P」 | Gᵢ=AᵢBᵢ, Pᵢ=Aᵢ⊕Bᵢ |
| 「用 Decoder 實現函數」 | 把 F=1 的最小項用 OR 接 |
| 「用 MUX 實現函數」 | 分析各選擇組合下的輸出 |
| 「判斷冒險」 | K-map 上看相鄰 PI 有無重疊 |
| 「避免冒險」 | 加冗餘項（共識項） |
| 「加減法共用」 | XOR 閘控制 B 反轉，Cᵢₙ=1 |

---

## 十四、完整設計例題

### 【例題 2】設計一個 BCD 到 Excess-3 碼轉換器

Excess-3 碼 = BCD + 3

| 十進位 | BCD (ABCD) | Excess-3 (WXYZ) |
|--------|-----------|-----------------|
| 0 | 0000 | 0011 |
| 1 | 0001 | 0100 |
| 2 | 0010 | 0101 |
| 3 | 0011 | 0110 |
| 4 | 0100 | 0111 |
| 5 | 0101 | 1000 |
| 6 | 0110 | 1001 |
| 7 | 0111 | 1010 |
| 8 | 1000 | 1011 |
| 9 | 1001 | 1100 |
| 10~15 | 1010~1111 | Don't Care |

用 K-map 化簡每個輸出 W, X, Y, Z：

**Z 的 K-map** (Z = D' for valid inputs)：
```
              CD
            00   01   11   10
AB   00 |  1 |  0 |  0 |  1 |
     01 |  1 |  0 |  0 |  1 |
     11 |  X |  X |  X |  X |
     10 |  1 |  0 |  X |  X |
```
Z = D'

**Y 的 K-map**：
```
              CD
            00   01   11   10
AB   00 |  1 |  0 |  1 |  0 |
     01 |  1 |  0 |  1 |  0 |
     11 |  X |  X |  X |  X |
     10 |  1 |  0 |  X |  X |
```
Y = CD + C'D' = C ⊙ D

（化簡過程省略，但每個 K-map 都類似）

最終結果：
```
Z = D'
Y = C'D + CD' = C ⊕ D
X = B'C + B'D + BC'D' = B ⊕ (C+D)
W = A + BC + BD = A + B(C+D)
```

### 【例題 3】設計一個 4-bit 奇偶校驗產生器

輸入：4-bit 資料 A₃A₂A₁A₀
輸出：P（使得 A₃A₂A₁A₀P 共有偶數個 1）

```
P = A₃ ⊕ A₂ ⊕ A₁ ⊕ A₀
```

> XOR 的鏈式連接天然就是奇偶校驗！

### 【例題 4】用 3-to-8 Decoder 和 OR 閘實現 F₁ 和 F₂

```
F₁(A,B,C) = Σm(0,2,3,5)
F₂(A,B,C) = Σm(1,4,6,7)
```

```
        ┌──────────┐
A ──────┤          ├── D₀ ──────┐
B ──────┤ 3-to-8   ├── D₁ ─────│────────┐
C ──────┤ Decoder  ├── D₂ ──┐  │        │
        │          ├── D₃ ──┤  │        │
        │          ├── D₄ ──│──│────┐   │
        │          ├── D₅ ──┤  │    │   │
        │          ├── D₆ ──│──│────┤   │
        │          ├── D₇   │  │    │   │
        └──────────┘        │  │    │   │
                            ▼  ▼    ▼   ▼
F₁ = D₀+D₂+D₃+D₅ ←─[OR₁]     [OR₂]──→ F₂ = D₁+D₄+D₆+D₇
```

> 用同一個 Decoder，可以同時實現多個函數！

### 【例題 5】用 8-to-1 MUX 實現 F(A,B,C,D) = Σm(0,1,3,5,7,8,10,14,15)

選 A, B, C 接選擇線，D 放入資料輸入：

| A | B | C | D=0 時 F | D=1 時 F | 資料輸入 |
|---|---|---|---------|---------|---------|
| 0 | 0 | 0 | m₀=1 | m₁=1 | I₀ = 1 |
| 0 | 0 | 1 | m₂=0 | m₃=1 | I₁ = D |
| 0 | 1 | 0 | m₄=0 | m₅=1 | I₂ = D |
| 0 | 1 | 1 | m₆=0 | m₇=1 | I₃ = D |
| 1 | 0 | 0 | m₈=1 | m₉=0 | I₄ = D' |
| 1 | 0 | 1 | m₁₀=1 | m₁₁=0 | I₅ = D' |
| 1 | 1 | 0 | m₁₂=0 | m₁₃=0 | I₆ = 0 |
| 1 | 1 | 1 | m₁₄=1 | m₁₅=1 | I₇ = 1 |

```
接線：
I₀=1(VCC), I₁=D, I₂=D, I₃=D, I₄=D', I₅=D', I₆=0(GND), I₇=1(VCC)
S₂=A, S₁=B, S₀=C
```

---

## ✅ 自我檢測

### Q1：全加器的 Sum 和 Carry 公式各是什麼？

<details>
<summary>點擊查看答案</summary>

```
Sum   = A ⊕ B ⊕ Cᵢₙ
Carry = AB + (A⊕B)Cᵢₙ = AB + ACᵢₙ + BCᵢₙ
```
</details>

### Q2：CLA 的 Generate 和 Propagate 定義？為什麼 CLA 比 Ripple Carry 快？

<details>
<summary>點擊查看答案</summary>

```
Gᵢ = AᵢBᵢ (Generate)
Pᵢ = Aᵢ ⊕ Bᵢ (Propagate)
```
CLA 快是因為所有進位 C₁,C₂,...,Cₙ 都只用 G, P, C₀ 的兩層邏輯表達，
不需要等前一位的進位算完才能算下一位。
延遲 = O(1) 而非 O(n)。
</details>

### Q3：用 4-to-1 MUX 實現 F(A,B,C) = Σm(0,1,6,7)。

<details>
<summary>點擊查看答案</summary>

選 A, B 接選擇線，C 放入資料輸入：

| A | B | C=0 (F) | C=1 (F) | 資料輸入 |
|---|---|---------|---------|---------|
| 0 | 0 | m₀=1 | m₁=1 | I₀ = 1 |
| 0 | 1 | m₂=0 | m₃=0 | I₁ = 0 |
| 1 | 0 | m₄=0 | m₅=0 | I₂ = 0 |
| 1 | 1 | m₆=1 | m₇=1 | I₃ = 1 |

S₁=A, S₀=B, I₀=1, I₁=0, I₂=0, I₃=1

（順便觀察：F = A⊙B = A XNOR B）
</details>

### Q4：什麼是 Static-1 Hazard？如何在 K-map 上識別？如何消除？

<details>
<summary>點擊查看答案</summary>

**Static-1 Hazard**：輸出應該持續為 1，但由於閘延遲，短暫出現 0 的脈衝。

**K-map 識別**：
兩個相鄰的 Prime Implicant 之間沒有重疊覆蓋，它們的邊界就可能有 Hazard。

**消除方法**：
在 K-map 上加入冗餘群組，確保所有相鄰 PI 之間都有重疊。
對應到布林式就是加入共識項(Consensus Term)。
</details>

### Q5：Decoder 和 DEMUX 有什麼關係？

<details>
<summary>點擊查看答案</summary>

帶 Enable 輸入的 Decoder 就是 DEMUX。
- Decoder 的 Enable 線 = DEMUX 的資料輸入
- Decoder 的 n 條地址線 = DEMUX 的 n 條選擇線
- Decoder 的 2ⁿ 條輸出 = DEMUX 的 2ⁿ 條輸出

結構完全相同，只是用途/命名不同。
</details>

---

> **下一章預告**：組合邏輯沒有記憶功能。下一章我們要學「正反器 (Flip-Flop)」——數位電路中最基本的記憶元件，有了它就能建造計數器、暫存器等循序邏輯電路！
