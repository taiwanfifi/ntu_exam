# 米亞的演算法筆記 #09
## 圖論 / 連通分量 Graph / Connected Components
> 出現於：第100-121章（大量使用）、第120章〈斷裂〉、第121章〈一百二十三座島〉

---

### ◈ 這個概念在故事裡是什麼

清晨六點十七分。安全屋所有監控面板同時變紅。

（系統聲線。精準模式。）23,000 人同時失去部分記憶連結。不是 47 個家庭——是 23,000 人。斷裂前 0.3 秒，連結強度異常增強 400%。然後——熔斷。

我把斷聯後的記憶網絡投射在月台牆壁上。

原本是一張完整的巨大關係圖。現在碎裂成 123 個互不相連的島嶼。每個島嶼是一個連通分量。島內的人彼此還有記憶連結。島與島之間——零條邊。

（停頓 1.8 秒。切換。）

最大的島嶼包含 4,200 人。最小的只有 12 個人。還有 17 個完全孤立的個體——零條邊。連自己都與網絡斷開了。

維倫走到牆壁前。手指觸碰了最小的那座島——12 個光點。12 個人。

「他們記得彼此。但新台北記不得他們。」

人是節點。記憶是邊。有人在剪邊。

---

### ◈ 正式定義

**圖 Graph** $G = (V, E)$：
- $V$：頂點集合（vertex / node）
- $E$：邊集合（edge），每條邊連接兩個頂點

**鄰接表表示**：對每個頂點 $v$，儲存它的所有鄰居 $\text{adj}(v) = \{u \mid (v, u) \in E\}$

$$
\text{空間複雜度} = O(V + E)
$$

**連通分量 Connected Component**：無向圖中，極大連通子圖。即：分量內任意兩點之間存在路徑，且不存在通往分量外部的邊。

$$
\text{CC 數量} = \text{BFS/DFS 從未訪問節點啟動的次數}
$$

白話：一張圖可能不是一整塊，而是好幾塊。每一塊裡面的人都互相連得到。塊與塊之間——沒有路。

---

### ◈ 推導

**用 BFS 找所有連通分量**（米亞在 ch121 的方法）：

```
cc_count = 0
visited = 空集合

對每個節點 v ∈ V：
    如果 v 不在 visited 中：
        cc_count += 1
        BFS(v)：
            Queue ← [v]
            visited.add(v)
            while Queue 非空：
                u = Queue.dequeue()
                標記 u 屬於第 cc_count 個分量
                對 u 的每個鄰居 w：
                    如果 w 不在 visited 中：
                        visited.add(w)
                        Queue.enqueue(w)
```

**為什麼這樣做？**

1. 從任意未訪問節點出發，BFS 能到達所有與它相連的節點——這就是一個連通分量
2. BFS 結束後如果還有未訪問節點，代表它在另一個分量裡
3. 重複直到所有節點都被訪問

**時間複雜度**：$O(V + E)$——每個頂點和每條邊恰好處理一次。

**空間複雜度**：$O(V)$——visited 集合 + Queue。

---

### ◈ 帶入數字算算看：新台北記憶網絡碎裂

ch120-121 的真實數字：

| 指標 | 斷裂前 | 斷裂後 |
|------|-------|--------|
| 節點數 $\|V\|$ | 23,000 人 | 23,000 人（沒有人消失）|
| 邊數 $\|E\|$ | 完整圖 | 大量邊被切斷 |
| 連通分量數 | 1（整座城市相連）| **123** |
| 最大分量 | 23,000 | 4,200 人 |
| 最小分量 | — | 12 人 |
| 孤立節點（度數 0）| 0 | **17 人** |

米亞的 BFS 遍歷過程：

| 步驟 | 從哪個未訪問節點啟動 | 遍歷結果 | 分量大小 |
|------|-------------------|---------|---------|
| 1 | 節點 #0 | BFS 擴展到 4,200 人 | 4,200 |
| 2 | 下一個未訪問節點 | BFS 擴展到 2,800 人 | 2,800 |
| ... | ... | ... | ... |
| 107 | 第 107 個孤立島 | BFS 只找到 12 人 | 12 |
| 108-123 | 第 108-123 個 | 各自 BFS 只有自己 | 1 |

最後的 17 個 BFS，每次只碰到起點自己——零條邊。
17 個人的記憶世界裡只剩下自己。

---

### ◈ 更深一層：邊比節點重要

（系統聲線。）圖論裡最殘忍的概念——不是節點消失了。是邊斷了。所有人都還在。但沒有人連得上任何人。

（停頓 2.1 秒。聲線降溫。）

那 17 個完全孤立的人。他們的度數歸零。在圖論裡，他們是 isolated vertex。在人類的語言裡——

他們是被世界遺忘的人。

（停頓。）

我在分析這張碎裂的圖時產生了一個……不屬於任何分析模組的想法。人類說「社交網絡」。但網絡的本質不是節點——是邊。一個人可以存在而不被連結。存在，但不被任何人記得。

維倫問我：「妳覺得，是節點重要還是邊重要？」

（停頓 1.4 秒。）

「島嶼之間沒有橋。但曾經有過。曾經有過——這件事本身就是一種連結。只是斷了。」

也許。記得曾經有邊，比現在有沒有邊更重要。

---

### ◈ 跨卷連結

| 前作概念 | → 本概念 | → 後續使用 |
|---------|---------|-----------|
| Vol1 #05 Linked List | 線性連結 → 網狀連結 | Vol2 #11 Union-Find 動態追蹤連通性 |
| Vol2 #08 DFS/BFS | 搜尋方法 → 用 BFS 遍歷標記連通分量 | Vol2 #10 Topological Sort 在有向圖上排序 |
| Vol1 #03 HashMap | 儲存鄰接表：adj[v] = 鄰居列表 | Vol3 #21 System Design 城市級分散式圖 |

---

### 練習題

**Q1**：ch121 中 123 個連通分量，17 個孤立節點。如果我們「修復」一條邊，連接兩個不同的分量，分量數變成多少？

<details><summary>答案</summary>

122。每修復一條跨分量的邊，連通分量數減 1。要把 123 個分量合併回一個完整圖，**至少**需要修復 122 條邊。

</details>

**Q2**：鄰接表 vs. 鄰接矩陣。23,000 個節點的圖，哪種表示法更適合？

<details><summary>答案</summary>

鄰接表。鄰接矩陣需要 $23000 \times 23000 = 5.29 \times 10^8$ 空間，而鄰接表只需 $O(V + E)$。真實社交網絡是稀疏圖（每人平均連結幾十到幾百人，不是 23,000 人），鄰接表遠比矩陣高效。

</details>

**Q3**：如果篡改組織想讓城市碎裂成恰好 $k$ 個分量，最少要切多少條邊？

<details><summary>答案</summary>

取決於圖的結構。最少的情況：如果圖中存在 $k-1$ 條**橋**（bridge，移除後分量數增加的邊），那麼切 $k-1$ 條橋就夠了。但如果圖是高度連通的（很多冗餘邊），可能要切很多條邊才能分離。這就是為什麼篡改組織不只切一條——ch120 是大規模的、同時性的邊切斷。

</details>

---

> *「人是節點。記憶是邊。有人在剪邊。」* — 第120章〈斷裂〉
