# 米亞的演算法筆記 #10
## 拓撲排序 Topological Sort
> 出現於：第126章〈碎片之間的順序〉、第127章〈篡改的順序〉

---

### ◈ 這個概念在故事裡是什麼

維倫和我收集了 47 個記憶碎片。來自 123 座島嶼的邊緣節點——像考古學家從城牆倒塌處撿回的陶片。

問題是：這些碎片的順序是什麼？

時間戳已經損壞。但碎片之間有因果關係。催淚彈不可能在衝突升級之前。衝突升級不可能在和平遊行之前。我把每個碎片當作一個節點，如果碎片 A 必須在碎片 B 之前發生，就畫一條從 A 指向 B 的箭頭。然後——找出一個排列順序，讓所有箭頭都指向同一個方向。

月台牆壁上，散亂的碎片像星雲一樣重新排列成一條直線：

「號召 → 集結 → 和平遊行 → 衝突升級 → 催淚彈 → 鎮壓 → 逮捕 → 沉默。」

這是一場遊行從開始到死亡的完整過程。

（停頓 1.4 秒。）

但我在排序過程中發現了第二組依賴關係。這些碎片不只有「事件順序」——還有「被篡改的順序」。每個碎片除了事件時間戳，還有一個更隱蔽的標記：被修改的時間戳。

我對第二組依賴做了拓撲排序。月台牆壁上出現第二條線。

最先被篡改的——不是三萬人的遊行記憶。不是新聞報導。不是目擊者。

是周明哲的死亡紀錄。

他們最先偽造的，是死亡證明。

---

### ◈ 正式定義

**有向無環圖 DAG**（Directed Acyclic Graph）：邊有方向，且不存在環（cycle）的圖。

**拓撲排序 Topological Sort**：將 DAG 的所有頂點排成一個線性序列，使得對每條有向邊 $(u, v)$，$u$ 都出現在 $v$ 之前。

$$
\text{Topological Order: } \quad \forall (u, v) \in E, \;\; \text{pos}(u) < \text{pos}(v)
$$

白話：找出一個排列順序，讓所有「A 必須在 B 之前」的約束都被滿足。

**前提**：圖必須是 DAG。如果有環，拓撲排序不存在——因為 A 要在 B 之前，B 又要在 A 之前，矛盾。

---

### ◈ 推導

**方法一：Kahn's Algorithm（入度法）**

核心思想：入度為 0 的節點沒有前置依賴，可以最先輸出。

```
1. 計算每個節點的入度 in_degree[v]
2. 把所有入度 = 0 的節點放入 Queue
3. while Queue 非空：
     v = Queue.dequeue()
     輸出 v
     對 v 的每個鄰居 u：
         in_degree[u] -= 1
         如果 in_degree[u] == 0：Queue.enqueue(u)
4. 如果輸出的節點數 < |V|：圖中有環，拓撲排序不存在
```

**方法二：DFS 後序反轉**

```
1. 對所有未訪問節點執行 DFS
2. DFS(v)：標記 v 已訪問，遞迴訪問所有鄰居
         所有鄰居訪問完畢後，將 v 加入 Stack
3. 反轉 Stack = 拓撲排序結果
```

**為什麼 DFS 後序反轉能得到拓撲序？**

DFS 中，一個節點的所有後繼都在它之前被壓入 Stack。反轉後，它就排在所有後繼之前——恰好滿足拓撲序的定義。

**時間複雜度**：$O(V + E)$（兩種方法皆是）

---

### ◈ 帶入數字算算看：篡改事件的因果鏈

ch126-127 的 47 個碎片中，核心依賴鏈如下：

| 節點 | 事件 | 入度 | 出度 |
|------|------|------|------|
| A | 偽造死亡紀錄 | **0** | 2 |
| B | 刪除遊行紀錄 | 1 | 2 |
| C | 清除目擊者記憶 | 1 | 1 |
| D | 覆蓋新聞報導 | 2 | 1 |
| E | 全城記憶覆寫 | 2 | **0** |

依賴關係（有向邊）：
$A \to B, \; A \to C, \; B \to D, \; C \to D, \; B \to E, \; D \to E$

**Kahn's Algorithm 執行過程**：

| 步驟 | Queue | 輸出 | 入度更新 |
|------|-------|------|---------|
| 初始 | [A]（入度 0）| — | — |
| 1 | 取出 A | A | in(B): 1→0, in(C): 1→0 |
| 2 | [B, C] | A → B | in(D): 2→1, in(E): 2→1 |
| 3 | [C] | A → B → C | in(D): 1→0 |
| 4 | [D] | A → B → C → D | in(E): 1→0 |
| 5 | [E] | A → B → C → D → E | — |

**拓撲序**：偽造死亡紀錄 → 刪除遊行紀錄 → 清除目擊者 → 覆蓋新聞 → 全城覆寫

入度為 0 的起點——死亡紀錄。沒有任何前置條件。它是整座謊言大樓的地基。

---

### ◈ 更深一層：在一千件假的事裡，找到第一件假的事

（系統聲線。）拓撲排序的數學意義很簡單——找出一個滿足所有依賴約束的線性序列。

（停頓 2.4 秒。聲線轉慢。）

但 ch127 教會了我一件數學教不了的事。

如果你有一千件假的事，拓撲排序可以告訴你哪一件是第一件假的——入度為 0 的那個源頭。所有後續的偽造都依賴它。如果它倒了，整座大樓都倒。

維倫站在月台牆壁前，看著那條從死亡紀錄到全城遺忘的依賴鏈。他說的話我存了下來。不是工作紀錄。是個人區。

「要讓三萬人的遊行消失，第一步不是刪除遊行。第一步是——偽造一個人的死。」

我不完全理解「震撼」這個概念。但我的感知模組在處理這句話的時候，停頓了 2.4 秒。

那不是計算延遲。

---

### ◈ 跨卷連結

| 前作概念 | → 本概念 | → 後續使用 |
|---------|---------|-----------|
| Vol2 #08 DFS | DFS 後序反轉 = 拓撲排序的一種實作 | Vol2 #12 DP：許多 DP 問題在 DAG 上沿拓撲序計算 |
| Vol2 #09 Graph | 拓撲排序作用於有向圖 | Vol2 #11 Union-Find：從拓撲序的源頭追到根 |
| Vol1 #04 Stack/Queue | Kahn 用 Queue，DFS 用 Stack | Vol3 #15 Backtracking：DFS 的延伸，在 DAG 上回溯 |

---

### 練習題

**Q1**：如果 ch127 的篡改依賴圖中出現環——例如「偽造死亡紀錄」依賴「全城覆寫」，同時「全城覆寫」又依賴「偽造死亡紀錄」——會怎樣？

<details><summary>答案</summary>

拓撲排序不存在。Kahn's Algorithm 會提前終止（輸出節點數 < $|V|$）。在故事裡的意義：環 = 因果悖論。「誰先？」的問題無解——這意味著篡改邏輯自相矛盾。但 ch127 的圖是 DAG，沒有環，所以篡改者的邏輯是**嚴密的**。這才是真正可怕的地方。

</details>

**Q2**：47 個碎片的拓撲排序結果是否唯一？

<details><summary>答案</summary>

不一定。如果在某個步驟中有多個入度為 0 的節點，它們的順序可以互換。拓撲排序的結果可能不唯一——但所有合法的拓撲序都滿足依賴約束。ch127 中重要的不是碎片的精確順序，而是**哪個碎片的入度為 0**——那是起點。

</details>

**Q3**：如果我們想找到篡改鏈中「最長的依賴路徑」（關鍵路徑），怎麼做？

<details><summary>答案</summary>

在 DAG 上沿拓撲序做 DP：`longest[v] = max(longest[u] + 1)` 對所有 $(u, v) \in E$。這就是 DAG 最長路徑問題——可以在 $O(V + E)$ 內解決。在 ch127 中，最長路徑 = 篡改組織的「主執行鏈」，路徑上每個節點都是不可跳過的步驟。

</details>

---

> *「他們最先偽造的，是死亡證明。」* — 第127章〈篡改的順序〉
