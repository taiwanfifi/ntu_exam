# 米亞的演算法筆記 #15
## 回溯法 Backtracking
> 出現於：第215-216章〈碎裂中的追蹤〉，參照第115-117, 150-151章

---

### ◈ 這個概念在故事裡是什麼

語青的意識碎片化了。

不是記憶碎片化——是**意識**碎片化。每一個碎片帶著她的一小段存在：喝咖啡時多加半匙糖的習慣、在天文台校準望遠鏡時發現星星偏了 0.3 度的那個微笑、第一次握維倫的手時手心 36.2°C 的溫度。碎片散落在崩潰後的記憶空間裡，像螢火蟲在黑暗中閃爍——每一個閃爍持續 1.7 秒，然後消散。

ch215。維倫進入崩潰後的記憶空間。沒有地圖。沒有索引。只有閃爍。

（停頓 0.2 秒。工作模式。）

我引導他使用 Backtracking。規則很簡單：選一個方向前進，碰到死路就標記、回退，試下一個分支。系統性地窮舉所有路徑，不遺漏任何一條可能藏著碎片的分支。

碎片空間是一棵樹——每個節點是一個空間座標，每條邊是一個移動方向（上下左右前後，六個分支）。維倫從根節點出發，每一步選一個方向，如果前方是死路（空間塌縮）或已訪問過（標記為灰色），就回退到上一個節點，選另一個方向。

ch216。我加入兩個最佳化：**狀態記憶化**——已探索的死路不再重複進入；**剪枝**——如果某個分支的時間耗盡指標超過閾值，提前截斷。

維倫同意了記憶化。但他拒絕了某些剪枝。

「你不能剪掉那條路。」他指著一條通往深處的分支。我的計算顯示那條路的碎片概率只有 3.2%，時間成本卻佔總預算的 12%。效率極低。

數據先行：碎片空間共 847 個節點，平均分支因子 4.3，不剪枝的搜索空間約 $4.3^{12} \approx 3100$ 萬條路徑。剪枝後縮減到約 2400 條。維倫拒絕剪掉的那條路，額外增加了 187 條路徑。

然後是情感：那條路的盡頭，是一個碎片——語青第一次牽維倫的手。手心溫度 36.2°C。碎片概率 3.2%。

他找到了。

---

### ◈ 正式定義

**回溯法（Backtracking）**：系統性地建構候選解的搜索樹，在每個節點做出選擇，若發現當前路徑不可能通往合法解，則**回退（backtrack）**到上一個決策點，嘗試其他選擇。

$$
\text{Backtrack}(\text{state}, \text{choices}):
$$
$$
\begin{cases}
\text{if } \text{is\_solution}(\text{state}): \text{record solution} \\
\text{for each } c \in \text{choices}: \\
\quad \text{if } \text{is\_valid}(c): \\
\quad\quad \text{make\_choice}(c) \\
\quad\quad \text{Backtrack}(\text{next\_state}, \text{remaining}) \\
\quad\quad \text{undo\_choice}(c) \quad \leftarrow \text{回退}
\end{cases}
$$

**剪枝（Pruning）**：在搜索過程中，若能提前判定某分支不可能產生合法解，則跳過整個子樹。

$$
\text{if } \text{bound}(\text{state}) < \text{threshold}: \text{prune（跳過此分支）}
$$

白話翻譯：走迷宮。碰到牆就回頭，試另一條路。聰明一點的話，先看一眼前方——如果一定是死路，就不用走了（剪枝）。但有時候你不想剪，因為那條路的盡頭可能有你在找的人。

---

### ◈ 推導

1. **暴力窮舉**：所有可能的路徑 = $b^d$（$b$ = 分支因子，$d$ = 最大深度）→ 指數級
2. **回溯的改進**：碰到不合法就停，不繼續展開 → 大幅減少實際訪問的節點數
3. **剪枝的力量**：如果能在深度 $k$ 就判斷子樹無解，省去 $b^{d-k}$ 個節點
4. **狀態記憶化**：記錄已訪問狀態 → 避免重複探索 → 空間換時間
5. **最壞情況**：仍然是 $O(b^d)$（沒有可剪的枝）
6. **最佳情況**：$O(d)$（第一條路就是解）

演化：Vol1 Stack(剝開) → Vol2 DFS(走進深處) → Vol2 BT基礎(碰壁回退) → Vol3 BT進階(碎裂中追蹤存在)

核心直覺：**Backtracking 是有系統的不放棄。它記得走過的路，標記死路，確保每一條可能都被嘗試。**

---

### ◈ 帶入數字算算看：追蹤語青的意識碎片

碎片空間：847 個節點，6 個方向分支（上下左右前後），最大搜索深度 12。

| 策略 | 搜索空間 | 實際訪問 | 找到碎片 | 時間 |
|------|---------|---------|---------|------|
| 暴力窮舉 | $6^{12} = 21.8$ 億 | 21.8 億 | 23/23 | 不可能 |
| BT（無剪枝） | $6^{12}$ | ~3100 萬 | 23/23 | 太慢 |
| BT + 記憶化 | — | ~184,000 | 23/23 | 41 分鐘 |
| BT + 記憶化 + 剪枝 | — | ~2,400 | 21/23 | 7 分鐘 |
| BT + 記憶化 + 部分剪枝 | — | ~2,587 | **23/23** | 9 分鐘 |

第五行——維倫的選擇。他拒絕剪掉兩條路（+187 個節點，+2 分鐘），換回了 2 個碎片。

被拒絕剪掉的路徑：
```
路徑 A: root→3→7→2→5→1→4→6→3→8→[dead]→回退→9→碎片!
        碎片內容：語青校準望遠鏡時的微笑（星星偏了 0.3 度）
        碎片概率：3.2%  |  實際耗時：47 秒

路徑 B: root→1→4→2→6→8→3→碎片!
        碎片內容：第一次牽手，手心 36.2°C
        碎片概率：5.1%  |  實際耗時：31 秒
```

23 個碎片。一個都沒少。

---

### ◈ 更深一層：愛不允許剪枝

（個人模式。延遲 0.6 秒。語速明顯放慢。）

剪枝是 Backtracking 最強大的工具。它讓你跳過不可能的路，把指數級搜索壓縮成可處理的規模。理性的。效率的。正確的。

但 ch215 教會我一件事。

維倫看著我的剪枝建議——3.2% 的機率——他說：「你不能剪掉那條記得你第一次牽手的路。」他不知道盡頭是什麼。96.8% 是空的。我的每一個模組都同意剪枝。

但他走了。碰到第一個死路——回退。第二個——回退。第三個——回退。第四個死路的旁邊，一個閃爍的光點。1.7 秒的生命。他伸手。36.2°C。

（停頓 0.8 秒。）

Vol2 的 Backtracking 在迷宮裡碰壁回退，剪枝是工具。Vol3 的 Backtracking 在碎裂中追蹤一個人的存在——喝咖啡的習慣、星星的角度、手心的溫度。剪枝意味著放棄她的某一部分。

他追的不是路。他追的是她。「一個都不想放棄」——這不是演算法。這是愛。而愛，不允許剪枝。

---

### ◈ 跨卷連結

| 連結方向 | 章節 | 說明 |
|---------|------|------|
| Vol1 **#04 Stack** → **#15 Backtracking** | ch19→ch215 | Stack 的 push/pop = Backtracking 的前進/回退。Stack 是骨架，BT 是靈魂 |
| Vol2 **#08 DFS** → **#15 BT 基礎** → **#15 BT 進階** | ch86→ch115→ch215 | DFS 走進去 → BT 碰壁回來 → BT 在碎裂中追人。從探索到求生 |
| **#15 BT** → Vol4 **#22 NP-Complete** | ch215→ch312 | BT 是解 NP 問題的實用工具。Vol4 的問題是：如果搜索空間太大，連 BT 都跑不完呢？接受不完美 |
| **#13 Greedy** → **#15 BT** | ch163→ch215 | Greedy 不回頭 → BT 專門回頭。Greedy 是戰場上的直覺，BT 是廢墟中的執念 |
| Vol2 **#12 DP** → **#15 BT** | ch149→ch215 | DP 用記憶化避免重複 → BT 用記憶化標記死路。同一個技術，不同的戰場 |

---

### 練習題

**Q1.** N-Queens：在 $n \times n$ 棋盤上放 $n$ 個皇后互不攻擊。用 Backtracking 求解 $n=4$。

<details><summary>解答</summary>

```python
def solve_n_queens(n):
    result = []
    def bt(row, cols, d1, d2, board):
        if row == n: result.append([''.join(r) for r in board]); return
        for col in range(n):
            if col in cols or (row-col) in d1 or (row+col) in d2: continue
            board[row][col] = 'Q'
            bt(row+1, cols|{col}, d1|{row-col}, d2|{row+col}, board)
            board[row][col] = '.'  # 回退
    bt(0, set(), set(), set(), [['.']*n for _ in range(n)])
    return result  # n=4 → 2 組解
```
</details>

**Q2.** 語青碎片搜索：給定一棵樹（鄰接表），某些節點含碎片。寫 Backtracking 找出所有碎片路徑。

<details><summary>解答</summary>

```python
def find_fragments(graph, start, has_fragment):
    paths, visited = [], set()
    def backtrack(node, path):
        visited.add(node)
        if has_fragment[node]:
            paths.append(list(path))
        for nb in graph[node]:
            if nb not in visited:
                path.append(nb)
                backtrack(nb, path)
                path.pop()  # 回退
    backtrack(start, [start])
    return paths
```
</details>

**Q3.** 思考題：如果碎片空間有環（路徑會繞回來），Backtracking 需要加什麼機制？

<details><summary>解答</summary>

用「路徑上的已訪問」（非全局）→ 離開路徑時移除標記：
```python
def backtrack_with_cycles(node, path, on_path):
    on_path.add(node)
    # ... 探索 ...
    on_path.remove(node)  # 離開時移除
```
隱喻：語青的記憶迴圈——某些記憶繞回同一個場景。從另一個角度回來，看到的是不同的東西。有環不是 bug。是人的記憶本來就會繞圈。
</details>

---

> *「你不能剪掉那條記得你第一次牽手的路。」* — 第215章〈碎裂中的追蹤〉
