# EDA 06：實體設計 —— 佈局與繞線

> **目標讀者**：零基礎學生、準備 TSMC / 聯發科 P&R 工程師面試者
> **預備知識**：基礎圖論（圖、節點、邊的概念）、EDA 05 的 STA 基礎
> **學習時間**：約 120 分鐘

---

## 🔰 本章基礎觀念（零基礎必讀）

### 實體設計是什麼？一句話

把邏輯合成產生的閘級網表中的每個元件「擺」在晶片上、用金屬線「連」起來。

### 生活比喻

| 實體設計 | 蓋房子比喻 |
|---------|-----------|
| 晶片規劃（Floorplanning） | 先劃分各區域的用途（客廳、臥室、廚房） |
| 佈局（Placement） | 把傢俱一件一件擺進去 |
| 時脈樹合成（CTS） | 安裝水管系統（確保每個房間水壓一樣） |
| 繞線（Routing） | 拉電線連接各個插座和電器 |
| DRC / LVS | 驗收檢查（符合建築法規嗎？圖紙跟實物一樣嗎？） |

### 實體設計流程概覽

```
    Gate-level Netlist + SDC
              │
              ▼
    ┌─────────────────────┐
    │ ① 晶片規劃            │
    │   (Floorplanning)    │
    └─────────────────────┘
              │
              ▼
    ┌─────────────────────┐
    │ ② 佈局               │
    │   (Placement)        │
    └─────────────────────┘
              │
              ▼
    ┌─────────────────────┐
    │ ③ 時脈樹合成          │
    │   (CTS)              │
    └─────────────────────┘
              │
              ▼
    ┌─────────────────────┐
    │ ④ 繞線               │
    │   (Routing)          │
    └─────────────────────┘
              │
              ▼
    ┌─────────────────────┐
    │ ⑤ 簽核               │
    │   (DRC / LVS / STA)  │
    └─────────────────────┘
              │
              ▼
         GDS / OASIS
         (Tapeout!)
```

---

## 一、晶片規劃（Floorplanning）

### 1.1 什麼是 Floorplanning？

在開始擺放細部元件之前，先決定晶片的「大格局」：

- 晶片的總面積和形狀
- 大型模組（Hard Macro, Soft Macro）的位置
- I/O pad 的位置
- 電源環（Power Ring）和電源條（Power Stripe）的規劃

### 1.2 模組類型

| 類型 | 說明 | 範例 |
|------|------|------|
| Hard Macro | 尺寸固定、不可變動 | SRAM, ROM, PLL, ADC |
| Soft Macro | 可以調整形狀和大小 | 邏輯模組（合成後的 netlist） |
| Standard Cell | 高度固定、寬度可變 | AND, OR, FF（排成 row） |

### 1.3 面積規劃

$$\boxed{\text{Utilization} = \frac{\text{Standard Cell 面積}}{\text{可用面積（扣除 Macro）}} \times 100\%}$$

典型值：70～85%（太高 → 繞線困難，太低 → 浪費面積）

### 1.4 腳位規劃（Pin Assignment / I/O Planning）

- I/O pad 的位置會影響繞線長度和信號完整性
- 通常信號 pad 靠近對應的內部邏輯
- 電源/接地 pad 均勻分佈

### 1.5 電源規劃（Power Planning）

```
     ┌─────────────────────────────────┐
     │ VDD ═══════════════════════════ │ ← Power Ring
     │ ║                             ║ │
     │ ║  ┌───────┐   ┌───────┐     ║ │
     │ ║  │ Macro │   │ Macro │     ║ │
     │ ║  └───────┘   └───────┘     ║ │
     │ ║     ║    ║    ║    ║       ║ │ ← Power Stripes
     │ ║  Standard Cell Area        ║ │    （垂直供電條）
     │ ║     ║    ║    ║    ║       ║ │
     │ ║                             ║ │
     │ VSS ═══════════════════════════ │ ← Ground Ring
     └─────────────────────────────────┘
```

---

## 二、佈局（Placement）

### 2.1 目標

把所有標準元件放到 Floorplan 上的合法位置，使得：
- **最小化總線長**（最常用的目標）
- 滿足時序約束
- 不超出密度限制
- 支援後續繞線

### 2.2 線長估計：HPWL

$$\boxed{\text{HPWL} = (x_{max} - x_{min}) + (y_{max} - y_{min})}$$

HPWL（Half-Perimeter Wire Length）：一條網路（net）所有 pin 的最小外包矩形的半周長。

```
    y
    ▲
    │    ┌─────────────┐ ← 外包矩形
    │    │ ●           │   (Bounding Box)
    │    │      ●      │
    │    │  ●       ●  │
    │    └─────────────┘
    │
    └──────────────────▶ x

    HPWL = (x_max - x_min) + (y_max - y_min)
```

> HPWL 是線長的**下界估計**，計算快速，廣泛用於佈局演算法中。

### 2.3 佈局演算法

#### （一）Min-Cut 分割法

**核心思想**：遞迴地把晶片切成兩半，每次切割使得「跨越切線的網路數」最少。

```
    第一刀（垂直切）：
    ┌──────────┬──────────┐
    │  A 區    │  B 區    │
    │ (元件)   │ (元件)   │
    └──────────┴──────────┘

    第二刀（水平切）：
    ┌─────┬─────┬─────┬─────┐
    │  A1 │  A2 │  B1 │  B2 │
    └─────┴─────┴─────┴─────┘

    遞迴直到每個區域夠小...
```

**KL（Kernighan-Lin）演算法**：
1. 將節點分成兩組（初始隨機分）
2. 計算每對節點交換後的增益（cut size 減少量）
3. 選擇最大增益的對交換
4. 重複直到增益為負
5. 回溯到最佳的交換序列

**FM（Fiduccia-Mattheyses）演算法**：
- KL 的改良版
- 每次只移動**一個**節點（而非交換一對）
- 使用 bucket sort 加速 → 時間複雜度 **O(n)** per pass ★
- 實務上最常用的分割演算法

#### （二）模擬退火法（Simulated Annealing, SA）

**核心思想**：模仿金屬冷卻過程，從隨機解出發，逐漸降溫找到好解。

```
1. 隨機初始佈局
2. 隨機擾動（移動一個元件、交換兩個元件）
3. 計算成本變化 ΔC
4. 如果 ΔC < 0 → 接受（變好了）
   如果 ΔC > 0 → 以概率 exp(-ΔC/T) 接受（溫度高時容易接受壞的）
5. 降溫：T = α·T（α ≈ 0.95）
6. 重複 2～5 直到 T 足夠低
```

- 優點：可以跳出區域最佳解（因為概率性接受壞解）
- 缺點：速度慢
- 用途：小規模設計或 Floorplanning

#### （三）分析式佈局法（Analytical Placement）★現代主流

**核心思想**：用數學模型把佈局問題轉化為**最佳化問題**。

**QuadPlace / ePlace 等方法**：
1. 用**二次函數**近似線長目標
2. 解**稀疏線性方程組** $Ax = b$ → 得到全域最佳解
3. 加入**密度約束**（讓元件散開，不要都擠在一起）
4. 反覆求解直到收斂

$$\text{Minimize: } \sum_{\text{nets}} \text{HPWL}(net) \approx \sum_i \frac{1}{2} x^T Q x + c^T x$$

- 優點：可處理數百萬個元件、品質好
- 這是現代商用工具（ICC2, Innovus）的核心演算法

### 2.4 合法化（Legalization）

分析式佈局的結果可能有元件重疊。合法化步驟：
1. 把每個元件對齊到最近的合法位置（Row 上的 site）
2. 消除所有重疊
3. 盡量保持原本的位置

### 2.5 詳細佈局（Detailed Placement）

在合法化後，做微調：
- 交換相鄰元件以減少線長
- 調整元件以改善時序

---

### 數值例題 1：HPWL 計算

**題目**：一條 net 連接 4 個 pin，座標分別為 (2,3), (5,1), (8,6), (4,4)。計算 HPWL。

**解答**：

$$x_{min} = 2, \quad x_{max} = 8$$
$$y_{min} = 1, \quad y_{max} = 6$$

$$\text{HPWL} = (8 - 2) + (6 - 1) = 6 + 5 = \boxed{11}$$

---

### 數值例題 2：FM 演算法增益計算

**題目**：分割成 A = {1, 2, 3} 和 B = {4, 5, 6}。各節點的連線如下：
- net1: {1, 4}（跨越）
- net2: {1, 2}（在 A 內部）
- net3: {2, 5}（跨越）
- net4: {3, 5, 6}（跨越）
- net5: {4, 6}（在 B 內部）

初始 cut size = 3（net1, net3, net4 跨越分割線）。

若將節點 3 從 A 移到 B，新的 cut size？移動增益？

**解答**：

移動節點 3 到 B 後：A = {1, 2}, B = {3, 4, 5, 6}

重新檢查每條 net：
- net1: {1, 4} → 1 在 A, 4 在 B → **跨越**
- net2: {1, 2} → 都在 A → 不跨越
- net3: {2, 5} → 2 在 A, 5 在 B → **跨越**
- net4: {3, 5, 6} → 都在 B → **不跨越** ★（原本跨越，現在不了）
- net5: {4, 6} → 都在 B → 不跨越

新 cut size = 2

**增益 = 舊 cut - 新 cut = 3 - 2 = +1**（正增益，值得移動）

---

## 三、繞線（Routing）

### 3.1 繞線的兩個階段

```
    整體繞線（Global Routing）          詳細繞線（Detailed Routing）
    ━━━━━━━━━━━━━━━━━━━━              ━━━━━━━━━━━━━━━━━━━━

    把線「分配」到粗略的               在每個區域內決定
    通道 / 格子中                     線的確切位置

    ┌───┬───┬───┐                    ┌───────────────┐
    │   │ ← │   │  "這條線走          │ ┌─┐   ┌─────┐ │
    │   │   │   │   中間這格"          │ │ └───┘     │ │
    │   │   │ ↓ │                    │ │     ┌───┐ │ │
    └───┴───┴───┘                    │ └─────┘   └─┘ │
                                     └───────────────┘
    速度快、決定策略                    速度慢、決定精確位置
```

### 3.2 整體繞線（Global Routing）

**目標**：為每條 net 選擇經過哪些 GCell（全域格子），使得：
- 不超過每個 GCell 的容量限制（Overflow = 0）
- 總線長最短

### 3.3 迷宮演算法（Lee / Maze Router）★經典考題

**原理**：用 BFS（廣度優先搜尋）在格子上找**最短路徑**。

```
    步驟 1：從 Source 出發，BFS 展開

    ┌───┬───┬───┬───┬───┐
    │   │   │   │   │   │
    ├───┼───┼───┼───┼───┤
    │   │ S │ 1 │ 2 │   │  S = Source
    ├───┼───┼───┼───┼───┤
    │   │ 1 │ ■ │ 3 │   │  ■ = 障礙物
    ├───┼───┼───┼───┼───┤
    │   │ 2 │ 3 │ T │   │  T = Target
    ├───┼───┼───┼───┼───┤
    │   │   │   │   │   │  數字 = 距離
    └───┴───┴───┴───┴───┘

    步驟 2：從 Target 回溯找路徑

    ┌───┬───┬───┬───┬───┐
    │   │   │   │   │   │
    ├───┼───┼───┼───┼───┤
    │   │ S─→ 1─→ 2 │   │
    ├───┼───┼───┼───┼───┤
    │   │   │ ■ │ ↓ │   │  路徑：S → 右 → 右 → 下 → T
    ├───┼───┼───┼───┼───┤
    │   │   │   │ T │   │  長度 = 3（曼哈頓距離）
    └───┴───┴───┴───┴───┘
```

**特性**：
- **保證找到最短路徑**（如果存在的話）
- **時間複雜度**：O(W × H)，W 和 H 是格子的寬和高
- **空間複雜度**：O(W × H)（需要儲存整個格子）
- **缺點**：對大面積設計太慢（格子太大）

### 3.4 通道繞線（Channel Routing）

在兩排元件之間的「通道」中繞線。

```
    上方元件：pin 位置
    ┌───┬───┬───┬───┬───┬───┐
    │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │  ← 上方 pin
    ├───┴───┴───┴───┴───┴───┤
    │                        │  ← 通道（Channel）
    │   在這裡繞線             │     水平: trunk
    │                        │     垂直: branch
    ├───┬───┬───┬───┬───┬───┤
    │ 1 │ 0 │ 3 │ 0 │ 2 │ 4 │  ← 下方 pin
    └───┴───┴───┴───┴───┴───┘
```

需要的軌道數取決於**通道密度**（channel density）。

### 3.5 Left-Edge Algorithm ★

用來決定每條水平線段放在哪個軌道上（track）。

**步驟**：
1. 把所有水平線段按**左端點**排序
2. 對每個軌道，貪心地放入**不重疊**的線段
3. 需要新軌道時才增加

```
    線段        左端     右端
    ───────────────────────
    A           1        4
    B           2        6
    C           5        8
    D           3        5
    E           7        10

    Left-Edge 排序後：A(1-4), B(2-6), D(3-5), C(5-8), E(7-10)

    Track 1: A(1-4) → C(5-8)     （C 的左端 5 > A 的右端 4，不重疊）
    Track 2: B(2-6) → E(7-10)    （E 的左端 7 > B 的右端 6，不重疊）
    Track 3: D(3-5)

    總共需要 3 個軌道
```

---

### 數值例題 3：Left-Edge Algorithm

**題目**：給定 6 條水平線段：
- S1: [1, 5], S2: [2, 3], S3: [4, 7], S4: [6, 9], S5: [3, 6], S6: [8, 10]

用 Left-Edge Algorithm 分配軌道，最少需要幾個軌道？

**解答**：

按左端點排序：S1(1-5), S2(2-3), S5(3-6), S3(4-7), S4(6-9), S6(8-10)

**Track 1**：S1(1-5) → S4(6-9)（6 > 5，可放） → S6？（8 < 9，不可）
  → S1, S4

**Track 2**：S2(2-3) → S3(4-7)（4 > 3，可放） → S6(8-10)（8 > 7，可放）
  → S2, S3, S6

**Track 3**：S5(3-6)
  → S5

需要 $\boxed{3}$ 個軌道。

驗證：最大密度（任一 x 位置上重疊的線段數最多）：
- x=3 時：S1(1-5), S2(2-3), S5(3-6) → 3 條重疊
- 所以最少需要 3 個軌道（與結果一致）

---

## 四、時脈樹合成（Clock Tree Synthesis, CTS）

### 4.1 為什麼需要 CTS？

時脈信號需要驅動整個晶片上的所有正反器（可能數百萬個）。如果時脈到達不同 FF 的時間不一致，會產生**時脈偏移（Clock Skew）**，影響時序。

CTS 的目標：
- 最小化 **Clock Skew**
- 滿足 **Clock Latency** 要求
- 最小化功耗（時脈佔整體功耗的 30～40%）

### 4.2 H-Tree 結構

```
                    ┌─────┐
                    │ CLK │
                    │Source│
                    └──┬──┘
                       │
              ┌────────┴────────┐
              │                 │
         ┌────┴────┐       ┌────┴────┐
         │         │       │         │
      ┌──┴──┐   ┌──┴──┐ ┌──┴──┐   ┌──┴──┐
      │     │   │     │ │     │   │     │
     FF    FF  FF    FF FF   FF  FF    FF
```

H-Tree 的特性：
- 完美對稱 → **零時脈偏移**（理論上）
- 每條路徑長度相同
- 但實際上不可能完美（元件分佈不均、寄生不同）

### 4.3 有用偏移（Useful Skew）

不是所有 skew 都是壞的。如果故意讓某些 FF 的時脈延遲不同，可以幫助解決 Setup 違規：

$$\text{Setup Slack} = T_{clk} + t_{skew} - (t_{cq} + t_{logic} + t_{setup})$$

如果 $t_{skew}$ 為正（Capture FF 的時脈較晚到達），Setup Slack 增加！

這就是 **Useful Skew**：有目的地引入偏移來改善時序。

但注意：增加 Setup margin 會減少 Hold margin，需要平衡。

---

### 數值例題 4：CTS 與 Useful Skew

**題目**：兩條相鄰路徑：
- Path A（到 FF1）：$t_{cq} + t_{logic} = 3.8$ ns
- Path B（到 FF2）：$t_{cq} + t_{logic} = 2.2$ ns

$T_{clk} = 4.0$ ns, $t_{setup} = 0.15$ ns。初始 skew = 0。

(a) 計算兩條路徑的 Setup Slack
(b) 若引入 Useful Skew，讓 FF1 的時脈延遲 0.3 ns，FF2 的時脈提前 0.3 ns，新的 Slack？
(c) 檢查 Hold（假設 $t_{hold} = 0.1$ ns，最短路徑延遲 = 0.2 ns）

**解答**：

**(a)** 初始（skew = 0）：

$$\text{Slack}_A = 4.0 - 3.8 - 0.15 = +0.05 \text{ ns（很緊！）}$$
$$\text{Slack}_B = 4.0 - 2.2 - 0.15 = +1.65 \text{ ns（很鬆）}$$

**(b)** 引入 Useful Skew 後：

FF1 時脈延遲 0.3 ns → 對 Path A，$t_{skew} = +0.3$：
$$\text{Slack}_A = (4.0 + 0.3) - 3.8 - 0.15 = \boxed{+0.35 \text{ ns}}$$

FF2 時脈提前 0.3 ns → 對 Path B，$t_{skew} = -0.3$：
$$\text{Slack}_B = (4.0 - 0.3) - 2.2 - 0.15 = \boxed{+1.35 \text{ ns}}$$

Path A 的 Slack 從 0.05 改善到 0.35 ns！Path B 仍有充足的 margin。

**(c)** Hold 檢查（以 Path A，FF1 為 Capture）：

$$\text{Hold Slack} = (0.2) - (0.1 + 0.3) = 0.2 - 0.4 = \boxed{-0.2 \text{ ns (FAIL!)}}$$

Useful Skew 改善了 Setup，但導致 Hold 違規。需要在最短路徑上插入 buffer 來修復 Hold。

---

## 五、DRC 與 LVS

### 5.1 DRC（Design Rule Check，設計規則檢查）

DRC 檢查佈局是否符合晶圓廠的**製程規則**。

常見的設計規則：

| 規則類型 | 說明 | 範例 |
|---------|------|------|
| 最小寬度 | 線/區域的最小寬度 | Metal 1 寬度 ≥ 28 nm |
| 最小間距 | 兩個圖形之間的最小距離 | Metal 1 間距 ≥ 28 nm |
| 最小面積 | 圖形的最小面積 | 防止太小的金屬碎片 |
| 包圍（Enclosure） | 一層必須包住另一層的距離 | Via 必須被 Metal 包圍 ≥ 5 nm |
| 密度規則 | 每個區域的材料密度範圍 | Metal density 20%～80% |

### 5.2 LVS（Layout vs. Schematic，佈局對電路驗證）

LVS 檢查佈局提取出來的電路是否與原始的閘級網表（Schematic）一致。

```
    Gate-level Netlist        Layout
    (Schematic)               (GDS)
         │                      │
         │                      ▼
         │               ┌──────────┐
         │               │ 電路提取   │
         │               │(Extraction)│
         │               └──────────┘
         │                      │
         ▼                      ▼
    ┌──────────────────────────────┐
    │         LVS 比較              │
    │  Schematic ←→ Extracted      │
    └──────────────────────────────┘
              │
         Clean?
         ├── Yes → 可以 Tapeout
         └── No  → 修正後重跑
```

LVS 檢查項目：
- 元件數量是否一致
- 連接關係（Netlist）是否一致
- 元件參數（W/L）是否匹配

### 5.3 工具

| 檢查 | Synopsys | Cadence | Siemens EDA |
|------|----------|---------|-------------|
| DRC | IC Validator | Pegasus | **Calibre** ★ |
| LVS | IC Validator | Pegasus | **Calibre** ★ |

> **Calibre**（Siemens EDA/原 Mentor）是 DRC/LVS 的業界標準工具。

---

## 關鍵術語表

| 術語 | 英文全名 | 說明 |
|------|---------|------|
| P&R | Place and Route | 佈局與繞線 |
| Floorplan | — | 晶片規劃 |
| Placement | — | 元件佈局 |
| HPWL | Half-Perimeter Wire Length | 半周長線長估計 |
| Min-Cut | — | 最小割分割法 |
| KL | Kernighan-Lin | 圖分割演算法 |
| FM | Fiduccia-Mattheyses | 改良版分割演算法，O(n) |
| SA | Simulated Annealing | 模擬退火法 |
| Analytical | — | 分析式佈局法（現代主流） |
| Legalization | — | 合法化（消除重疊） |
| Global Routing | — | 整體繞線 |
| Detailed Routing | — | 詳細繞線 |
| Maze Router | — | 迷宮繞線器（BFS） |
| Channel Routing | — | 通道繞線 |
| Left-Edge | — | 左邊緣演算法 |
| CTS | Clock Tree Synthesis | 時脈樹合成 |
| Clock Skew | — | 時脈偏移 |
| Useful Skew | — | 有用偏移（故意偏移改善時序） |
| H-tree | — | H 型時脈樹 |
| DRC | Design Rule Check | 設計規則檢查 |
| LVS | Layout vs. Schematic | 佈局對電路驗證 |
| Calibre | — | DRC/LVS 業界標準工具 |
| Utilization | — | 面積使用率 |
| Hard Macro | — | 尺寸固定的模組 |
| GCell | Global Cell | 整體繞線的格子單元 |
| Track | — | 繞線軌道 |

---

## 題型鑑別

| 看到什麼關鍵字 | 用什麼方法 | 答題方向 |
|---------------|-----------|---------|
| HPWL、線長 | 外包矩形半周長 | 計算座標差值 |
| 分割、Min-cut | KL/FM 演算法 | 增益計算、節點移動 |
| 模擬退火 | SA 概率公式 | $\exp(-\Delta C/T)$ |
| 最短路徑、迷宮 | Lee Router / BFS | 格子上標數字、回溯 |
| 通道、Left-Edge | 軌道分配 | 按左端排序、貪心 |
| 時脈偏移、CTS | 偏移公式 | 正偏移幫 Setup 害 Hold |
| DRC 規則 | 最小寬度/間距 | 製程規則違規分析 |

---

## ✅ 自我檢測

### 基礎題

<details>
<summary>Q1：實體設計的五大步驟依序是什麼？</summary>

**答案**：
1. **Floorplanning**（晶片規劃）：決定大格局、Macro 位置、I/O
2. **Placement**（佈局）：擺放所有標準元件
3. **CTS**（時脈樹合成）：建立時脈分佈網路
4. **Routing**（繞線）：用金屬線連接所有元件
5. **Signoff**（簽核）：DRC、LVS、STA 全部通過
</details>

<details>
<summary>Q2：迷宮演算法（Maze Router）的原理是什麼？優缺點？</summary>

**答案**：
**原理**：用 BFS 從 Source 出發，逐格展開，直到到達 Target。然後從 Target 回溯找最短路徑。

**優點**：保證找到最短路徑（如果存在）
**缺點**：
- 時間和空間複雜度 O(W×H)，對大面積設計太慢
- 一次只能繞一條 net
- 先繞的 net 可能佔據好位置，影響後繞的 net
</details>

<details>
<summary>Q3：Useful Skew 是什麼？為什麼能改善 Setup 但可能惡化 Hold？</summary>

**答案**：
**Useful Skew** 是故意讓某些 FF 的時脈到達時間不同。

**改善 Setup**：如果讓 Capture FF 的時脈較晚到達（正 skew），相當於給了資料更多時間到達 → Setup Slack 增加。

**惡化 Hold**：同樣的正 skew 意味著新資料（下一個時脈週期的）也有更多時間到達 → 可能太早到達覆蓋舊資料 → Hold 違規。

公式：
- Setup: $Slack = (T_{clk} + t_{skew}) - (t_{cq} + t_{logic} + t_{setup})$ → skew 正 → Slack 增加
- Hold: $Slack = (t_{cq} + t_{logic}) - (t_{hold} + t_{skew})$ → skew 正 → Slack 減少
</details>

### 計算題

<details>
<summary>Q4：5 條水平線段：A(0-3), B(2-5), C(1-4), D(4-7), E(6-9)。用 Left-Edge 需要幾個 Track？</summary>

**答案**：

按左端排序：A(0-3), C(1-4), B(2-5), D(4-7), E(6-9)

Track 1: A(0-3) → D(4-7)（4 > 3）→ E？（6 < 7，不可）
  → A, D

Track 2: C(1-4) → E(6-9)（6 > 4）
  → C, E

Track 3: B(2-5)
  → B

需要 **3 個 Track**。

驗證：x=2 時有 A(0-3), C(1-4), B(2-5) 三條重疊 → 密度 = 3 → 至少需要 3 個 Track。結果正確。
</details>

<details>
<summary>Q5：一個設計有 100,000 個標準元件，每個元件平均面積 1 μm²。如果 utilization 設定為 80%，且有兩個 Hard Macro 各佔 5,000 μm²。求總晶片面積。</summary>

**答案**：

標準元件總面積 = $100,000 \times 1 = 100,000$ μm²

可用面積（扣除 Macro 後）需要：$100,000 / 0.80 = 125,000$ μm²

總面積 = 可用面積 + Macro 面積 = $125,000 + 2 \times 5,000 = \boxed{135,000 \text{ μm}^2}$

若為正方形：邊長 = $\sqrt{135,000} \approx 367$ μm
</details>

<details>
<summary>Q6：DRC 和 LVS 各自檢查什麼？不通過的後果？</summary>

**答案**：
**DRC（Design Rule Check）**：
- 檢查佈局是否符合晶圓廠的**製程規則**（最小寬度、間距、面積、密度等）
- 不通過 → **無法製造**（晶圓廠不接受 DRC dirty 的設計）

**LVS（Layout vs. Schematic）**：
- 檢查佈局提取出的電路是否與原始設計**一致**
- 不通過 → **功能錯誤**（佈局中的電路不是你想要的）

兩者都必須 Clean（零錯誤）才能 Tapeout。業界標準工具是 Siemens EDA 的 **Calibre**。
</details>

---

> **下一章**：[eda_07_先進製程技術.md](eda_07_先進製程技術.md) —— FinFET、GAA、先進封裝：TSMC 面試必問
