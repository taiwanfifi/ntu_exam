# Dynamic Programming 一維 (1D DP) — 完整教學

> **適用對象**：基礎較弱的初學者，準備 Google 面試
> **教學哲學**：DP 是大多數人最害怕的主題，但只要一步一步來，它其實有跡可循。
> 本教材會用「笨方法」慢慢帶你理解每一題，絕對不跳步驟。

---

## 目錄

| 章節 | 內容 | 核心題目 |
|------|------|----------|
| 第一章 | 什麼是 Dynamic Programming? | Fibonacci |
| 第二章 | DP 思考步驟 (The DP Framework) | 五步框架 |
| 第三章 | 線性 DP | LC 70, 198, 213, 91 |
| 第四章 | 子序列 DP | LC 300, 53, 139 |
| 第五章 | 股票系列 | LC 121, 309 |
| 第六章 | Coin Change 經典 | LC 322 |
| 第七章 | DP 面試心法 | 總結 |

---

## 第一章：什麼是 Dynamic Programming? — 最重要的觀念

### 1.1 DP 的本質：不要重複做同樣的事

Dynamic Programming（動態規劃）聽起來很嚇人，但它的核心思想其實非常簡單：

> **如果你已經算過某個子問題的答案，就把它記下來，下次直接查表，不要再算一次。**

這就好比你在準備考試時，做過的題目會把答案寫在筆記本上。下次遇到一模一樣的題目，直接翻筆記就好，不用重新推導。

### 1.2 DP 的兩個必要條件

一個問題能用 DP 解，必須同時滿足：

```
條件 1: Overlapping Subproblems（重疊子問題）
   → 同一個子問題會被重複計算很多次
   → 如果每個子問題只算一次，那 DP 就沒有優勢

條件 2: Optimal Substructure（最優子結構）
   → 大問題的最佳解可以由子問題的最佳解組合而來
   → 例如：最短路徑問題，A→C 的最短路 = A→B 最短路 + B→C 最短路
```

### 1.3 Top-down vs Bottom-up：同一件事，不同方向

```
┌──────────────────────────────────────────────────────────────┐
│                   兩種 DP 實作方式                             │
├─────────────────────┬────────────────────────────────────────┤
│  Top-down           │  Bottom-up                             │
│  (Memoization)      │  (Tabulation)                          │
│  記憶化搜尋          │  列表法 / 遞推法                        │
├─────────────────────┼────────────────────────────────────────┤
│  從大問題往下遞迴     │  從最小子問題往上填表                    │
│  遞迴 + memo dict    │  for 迴圈 + dp array                   │
│  寫起來比較直覺       │  通常執行更快（沒有遞迴 overhead）        │
│  可能遇到 stack      │  不會 stack overflow                    │
│  overflow (深度太深)  │                                        │
├─────────────────────┼────────────────────────────────────────┤
│  適合初學者先理解     │  面試時通常寫這個                        │
└─────────────────────┴────────────────────────────────────────┘

重要：這兩種方式得到的答案完全一樣！只是「填表順序」不同。
面試中，通常先想 top-down 理解邏輯，再轉成 bottom-up 寫程式。
```

### 1.4 Fibonacci 完整教學 — DP 的 Hello World

Fibonacci 數列：`F(0)=0, F(1)=1, F(n) = F(n-1) + F(n-2)`

#### Step 1: 暴力遞迴（為什麼慢？）

```python
def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)
```

看起來很簡潔，但問題在哪？畫出 `fib(5)` 的遞迴樹 (Recursion Tree)：

```
                          fib(5)
                        /        \
                   fib(4)          fib(3)        ← fib(3) 出現第 1 次
                  /      \        /      \
             fib(3)    fib(2)  fib(2)   fib(1)   ← fib(3) 出現第 2 次!
            /     \    /    \   /    \            ← fib(2) 出現第 2 次!
       fib(2) fib(1) fib(1) fib(0) fib(1) fib(0)← fib(2) 出現第 3 次!
       /    \
   fib(1) fib(0)

數一下：
  fib(3) 被計算了 2 次
  fib(2) 被計算了 3 次
  fib(1) 被計算了 5 次
  fib(0) 被計算了 3 次

總共呼叫了 15 次函式，只為了算 fib(5)!
```

**時間複雜度**：O(2^n) — 指數級增長，n=50 就要算非常久

**根本原因**：同一個子問題被重複計算了很多次 → 這就是「重疊子問題」!

#### Step 2: Top-down Memoization（加上備忘錄）

既然問題出在重複計算，那就把算過的結果記起來：

```python
def fib_memo(n, memo={}):
    if n <= 1:
        return n
    if n in memo:          # 查表：算過就直接回傳
        return memo[n]
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]
```

Trace `fib_memo(5)` 的執行過程：

```
呼叫 fib(5)
  → 呼叫 fib(4)
    → 呼叫 fib(3)
      → 呼叫 fib(2)
        → 呼叫 fib(1) = 1
        → 呼叫 fib(0) = 0
        → memo[2] = 1        ← 記住 fib(2)=1
      → 呼叫 fib(1) = 1
      → memo[3] = 2          ← 記住 fib(3)=2
    → 查表 fib(2) = 1        ← 直接查! 不用再算!
    → memo[4] = 3             ← 記住 fib(4)=3
  → 查表 fib(3) = 2          ← 直接查! 不用再算!
  → memo[5] = 5

只算了 6 次（n=0,1,2,3,4,5 各一次），而不是 15 次!
```

**時間複雜度**：O(n)，**空間複雜度**：O(n)（memo + call stack）

#### Step 3: Bottom-up Tabulation（從小到大填表）

不用遞迴，直接用 for 迴圈從 `dp[0]` 填到 `dp[n]`：

```python
def fib_table(n):
    if n <= 1:
        return n
    dp = [0] * (n + 1)
    dp[0] = 0
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
```

**範例 1：n = 7，逐步填表**

```
dp[0] = 0                           (base case)
dp[1] = 1                           (base case)
dp[2] = dp[1] + dp[0] = 1 + 0 = 1
dp[3] = dp[2] + dp[1] = 1 + 1 = 2
dp[4] = dp[3] + dp[2] = 2 + 1 = 3
dp[5] = dp[4] + dp[3] = 3 + 2 = 5
dp[6] = dp[5] + dp[4] = 5 + 3 = 8
dp[7] = dp[6] + dp[5] = 8 + 5 = 13

dp = [0, 1, 1, 2, 3, 5, 8, 13]
答案 = dp[7] = 13
```

**範例 2：n = 10，逐步填表**

```
dp = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

驗算:
dp[8]  = dp[7] + dp[6]  = 13 + 8  = 21   ✓
dp[9]  = dp[8] + dp[7]  = 21 + 13 = 34   ✓
dp[10] = dp[9] + dp[8]  = 34 + 21 = 55   ✓

答案 = dp[10] = 55
```

#### Step 4: Space Optimization（空間優化）

觀察：`dp[i]` 只依賴 `dp[i-1]` 和 `dp[i-2]`，不需要整個陣列!

```python
def fib_optimized(n):
    if n <= 1:
        return n
    prev2, prev1 = 0, 1       # prev2 = dp[i-2], prev1 = dp[i-1]
    for i in range(2, n + 1):
        curr = prev1 + prev2
        prev2 = prev1
        prev1 = curr
    return prev1
```

```
n=7 的過程:
i=2: prev2=0, prev1=1 → curr=1  → prev2=1, prev1=1
i=3: prev2=1, prev1=1 → curr=2  → prev2=1, prev1=2
i=4: prev2=1, prev1=2 → curr=3  → prev2=2, prev1=3
i=5: prev2=2, prev1=3 → curr=5  → prev2=3, prev1=5
i=6: prev2=3, prev1=5 → curr=8  → prev2=5, prev1=8
i=7: prev2=5, prev1=8 → curr=13 → prev2=8, prev1=13

答案 = prev1 = 13  ✓
空間從 O(n) 降到 O(1)!
```

#### 四種解法比較

```
┌────────────────────┬──────────┬──────────┐
│ 方法                │ Time     │ Space    │
├────────────────────┼──────────┼──────────┤
│ Brute Force 暴力   │ O(2^n)   │ O(n)     │
│ Memoization 記憶化  │ O(n)     │ O(n)     │
│ Tabulation 列表法   │ O(n)     │ O(n)     │
│ Optimized 空間優化  │ O(n)     │ O(1)     │
└────────────────────┴──────────┴──────────┘
```

---

## 第二章：DP 思考步驟 (The DP Framework)

面試時拿到一道 DP 題，按照這五個步驟走：

### 五步框架

```
Step 1: 定義狀態 (State Definition)
        → dp[i] 代表什麼？
        → 這是最關鍵的一步！狀態定義對了，後面就順了。

Step 2: 寫轉移方程 (Transition / Recurrence)
        → dp[i] = f(dp[i-1], dp[i-2], ...)
        → 問自己：到達 dp[i] 的「最後一步」是什麼？

Step 3: 確定初始條件 (Base Case)
        → dp[0] = ? dp[1] = ?
        → 最小的子問題，直接知道答案的那些。

Step 4: 確定計算順序 (Iteration Order)
        → 通常是 left to right（i 從小到大）
        → 確保計算 dp[i] 時，所需的 dp[j] (j < i) 都已經算好。

Step 5: 回傳答案 (Return Value)
        → 是 dp[n]？還是 max(dp)？還是 dp[-1]？
```

### 狀態定義的常見模式

```
┌──────────────────┬───────────────────────────────────────┐
│ 問題模式          │ dp[i] 通常代表                         │
├──────────────────┼───────────────────────────────────────┤
│ 到達某個位置的方法 │ 到達位置 i 的方法數                     │
│ 搶不搶/選不選     │ 考慮前 i 個元素的最優值                  │
│ 湊出某個目標      │ 湊出目標 i 所需的最少/最多次數            │
│ 子序列問題        │ 以 nums[i] 結尾的最長/最大子序列         │
│ 字串分割問題      │ s[0:i] 是否滿足某個條件                  │
│ 狀態機問題        │ 在狀態 X 時的最優值 (多個 dp 陣列)       │
└──────────────────┴───────────────────────────────────────┘
```

### 轉移方程的思考技巧

核心問題：**「到達 dp[i] 的最後一步是什麼？」**

```
例 1: Climbing Stairs
     到達第 i 階的最後一步 → 從第 i-1 階爬 1 步 OR 從第 i-2 階爬 2 步
     dp[i] = dp[i-1] + dp[i-2]

例 2: House Robber
     對第 i 間房子的最後決策 → 搶(拿 dp[i-2]+nums[i]) OR 不搶(拿 dp[i-1])
     dp[i] = max(dp[i-1], dp[i-2] + nums[i])

例 3: Coin Change
     湊出金額 i 的最後一步 → 放入某枚面額為 c 的硬幣
     dp[i] = min(dp[i-c] + 1) for each coin c
```

---

## 第三章：線性 DP (Linear DP)

### 3.1 Climbing Stairs (LC 70) — DP 入門第一題

**題目**：你要爬 n 階樓梯，每次可以爬 1 階或 2 階，問有幾種不同的方法？

**DP 五步框架**：

```
Step 1 — 狀態: dp[i] = 爬到第 i 階的方法數
Step 2 — 轉移: dp[i] = dp[i-1] + dp[i-2]
               （從 i-1 爬 1 步，或從 i-2 爬 2 步）
Step 3 — Base: dp[1] = 1, dp[2] = 2
               （1 階只有 [1] 一種，2 階有 [1,1] 和 [2] 兩種）
Step 4 — 順序: i 從 3 到 n（左到右）
Step 5 — 答案: dp[n]
```

**為什麼是 dp[i-1] + dp[i-2]？**

```
想像你站在第 i 階，你是怎麼到這裡的？只有兩種可能：
  1. 你從第 i-1 階爬了 1 步上來 → 這時到第 i-1 階有 dp[i-1] 種走法
  2. 你從第 i-2 階爬了 2 步上來 → 這時到第 i-2 階有 dp[i-2] 種走法

這兩種情況互斥（不重複），所以加起來！
```

```python
def climbing_stairs(n):
    if n <= 2:
        return n
    prev2, prev1 = 1, 2
    for i in range(3, n + 1):
        curr = prev1 + prev2
        prev2, prev1 = prev1, curr
    return prev1
```

**範例 1：n = 5，逐步填表**

```
dp[1] = 1                              方法: [1]
dp[2] = 2                              方法: [1,1], [2]
dp[3] = dp[2] + dp[1] = 2 + 1 = 3     方法: [1,1,1], [1,2], [2,1]
dp[4] = dp[3] + dp[2] = 3 + 2 = 5     方法: [1,1,1,1], [1,1,2], [1,2,1], [2,1,1], [2,2]
dp[5] = dp[4] + dp[3] = 5 + 3 = 8

dp = [_, 1, 2, 3, 5, 8]
答案 = 8
```

**範例 2：n = 3，逐步填表**

```
dp[1] = 1
dp[2] = 2
dp[3] = dp[2] + dp[1] = 2 + 1 = 3

dp = [_, 1, 2, 3]
答案 = 3

所有方法列舉: [1,1,1], [1,2], [2,1] — 確實 3 種 ✓
```

**複雜度**：Time O(n), Space O(1)（只需要兩個變數）

---

### 3.2 House Robber (LC 198) — 經典「搶或不搶」

**題目**：你是一個小偷，一排房子各有不同金額。不能搶相鄰的兩間（否則觸發警報），求最大金額。

**DP 五步框架**：

```
Step 1 — 狀態: dp[i] = 考慮前 i+1 間房子 (0..i) 能搶到的最大金額
Step 2 — 轉移: dp[i] = max(dp[i-1], dp[i-2] + nums[i])
                        不搶第i間    搶第i間
Step 3 — Base: dp[0] = nums[0], dp[1] = max(nums[0], nums[1])
Step 4 — 順序: i 從 2 到 n-1
Step 5 — 答案: dp[n-1]
```

**口訣：搶這家 or 不搶這家**

```
對每一間房子，只有兩個選擇：

選擇 A — 不搶第 i 間:
  那最大金額就跟考慮前 i 間（不含第 i 間）一樣 = dp[i-1]

選擇 B — 搶第 i 間:
  因為不能搶相鄰的，所以第 i-1 間不能搶
  最大金額 = dp[i-2] + nums[i]（前 i-1 間的最大 + 第 i 間的錢）

取兩者較大值: dp[i] = max(dp[i-1], dp[i-2] + nums[i])
```

```python
def house_robber(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    prev2, prev1 = nums[0], max(nums[0], nums[1])
    for i in range(2, len(nums)):
        curr = max(prev1, prev2 + nums[i])
        prev2, prev1 = prev1, curr
    return prev1
```

**範例 1：nums = [1, 2, 3, 1]，逐步追蹤每一個決策**

```
房子金額:  [1,  2,  3,  1]
index:      0   1   2   3

dp[0] = nums[0] = 1
dp[1] = max(nums[0], nums[1]) = max(1, 2) = 2

dp[2] = max(dp[1], dp[0] + nums[2])
      = max(  2,     1   +   3    )
      = max(2, 4)
      = 4                            ← 搶第 0 間 + 第 2 間 (1+3=4)

dp[3] = max(dp[2], dp[1] + nums[3])
      = max(  4,     2   +   1    )
      = max(4, 3)
      = 4                            ← 不搶第 3 間，維持 4

dp = [1, 2, 4, 4]
答案 = 4（搶第 0, 2 間: 1+3=4）
```

**範例 2：nums = [2, 7, 9, 3, 1]，逐步追蹤**

```
房子金額:  [2,  7,  9,  3,  1]
index:      0   1   2   3   4

dp[0] = 2
dp[1] = max(2, 7) = 7

dp[2] = max(dp[1], dp[0] + nums[2])
      = max(  7,     2   +   9    )
      = max(7, 11)
      = 11                           ← 搶第 0, 2 間 (2+9=11)

dp[3] = max(dp[2], dp[1] + nums[3])
      = max( 11,     7   +   3    )
      = max(11, 10)
      = 11                           ← 不搶第 3 間

dp[4] = max(dp[3], dp[2] + nums[4])
      = max( 11,    11   +   1    )
      = max(11, 12)
      = 12                           ← 搶第 2, 4 間

dp = [2, 7, 11, 11, 12]
答案 = 12（搶第 0, 2, 4 間: 2+9+1=12）
```

**複雜度**：Time O(n), Space O(1)

---

### 3.3 House Robber II (LC 213) — 環形版本

**題目**：跟 House Robber I 一樣，但房子排成一圈（第一間和最後一間相鄰）。

**關鍵洞見**：

```
第一間和最後一間不能同時搶！

所以拆成兩個子問題：
  Case A: 只考慮 nums[0 .. n-2]（可能搶第一間，但不搶最後一間）
  Case B: 只考慮 nums[1 .. n-1]（不搶第一間，可能搶最後一間）

答案 = max(Case A, Case B)

每個子問題都是一個標準的 House Robber I！
```

```python
def house_robber_ii(nums):
    if len(nums) == 1:
        return nums[0]

    def rob_linear(arr):
        if len(arr) == 1:
            return arr[0]
        prev2, prev1 = arr[0], max(arr[0], arr[1])
        for i in range(2, len(arr)):
            curr = max(prev1, prev2 + arr[i])
            prev2, prev1 = prev1, curr
        return prev1

    return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))
```

**範例 1：nums = [2, 3, 2]**

```
房子排成圈: 2 — 3 — 2 — (回到 2)
                          第 0 間和第 2 間相鄰!

Case A: nums[0..1] = [2, 3]
  dp[0] = 2, dp[1] = max(2,3) = 3
  → max = 3

Case B: nums[1..2] = [3, 2]
  dp[0] = 3, dp[1] = max(3,2) = 3
  → max = 3

答案 = max(3, 3) = 3（搶第 1 間: 金額 3）
```

**範例 2：nums = [1, 2, 3, 1]**

```
Case A: nums[0..2] = [1, 2, 3]
  dp[0] = 1
  dp[1] = max(1, 2) = 2
  dp[2] = max(2, 1+3) = 4
  → max = 4（搶第 0, 2 間）

Case B: nums[1..3] = [2, 3, 1]
  dp[0] = 2
  dp[1] = max(2, 3) = 3
  dp[2] = max(3, 2+1) = 3
  → max = 3（搶第 1 間）

答案 = max(4, 3) = 4
```

**複雜度**：Time O(n), Space O(1)

---

### 3.4 Decode Ways (LC 91)

**題目**：A=1, B=2, ..., Z=26。給一串數字字串，問有幾種解碼方式。
例如 "12" 可以解碼為 "AB"(1,2) 或 "L"(12)，共 2 種。

**DP 五步框架**：

```
Step 1 — 狀態: dp[i] = 字串 s[0..i-1]（前 i 個字元）的解碼方法數
Step 2 — 轉移:
   如果 s[i-1] != '0':              dp[i] += dp[i-1]  ← 單獨解碼一位
   如果 10 <= int(s[i-2:i]) <= 26:  dp[i] += dp[i-2]  ← 兩位一起解碼
Step 3 — Base: dp[0] = 1（空字串有一種「什麼都不解」的方式）
               dp[1] = 1 if s[0] != '0' else 0
Step 4 — 順序: i 從 2 到 n
Step 5 — 答案: dp[n]
```

**為什麼這樣轉移？**

```
看字串的最後一部分怎麼解碼：

情況 1: 最後一個字元 s[i-1] 單獨解碼成一個字母
        → 前提: s[i-1] != '0'（'0' 無法單獨對應任何字母）
        → 這時前 i-1 個字元有 dp[i-1] 種解法

情況 2: 最後兩個字元 s[i-2:i] 合在一起解碼成一個字母
        → 前提: 組成的數字在 10~26 之間
        → 這時前 i-2 個字元有 dp[i-2] 種解法

兩種情況加起來 = dp[i]
```

```python
def decode_ways(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    prev2, prev1 = 1, 1  # dp[0], dp[1]
    for i in range(2, n + 1):
        curr = 0
        if s[i-1] != '0':
            curr += prev1
        two_digit = int(s[i-2:i])
        if 10 <= two_digit <= 26:
            curr += prev2
        prev2, prev1 = prev1, curr
    return prev1
```

**範例 1：s = "226"，逐步追蹤**

```
s = "226"

dp[0] = 1  (base case)
dp[1] = 1  (s[0]='2' != '0', 可以解碼為 'B')

i=2, 看 s[0:2] = "22":
  s[1]='2' != '0'    → dp[2] += dp[1] = 1    (把 '2' 單獨解碼為 B)
  s[0:2]="22", 10<=22<=26 → dp[2] += dp[0] = 1+1 = 2  (把 "22" 解碼為 V)
  dp[2] = 2

i=3, 看 s[0:3] = "226":
  s[2]='6' != '0'    → dp[3] += dp[2] = 2    (把 '6' 單獨解碼為 F)
  s[1:3]="26", 10<=26<=26 → dp[3] += dp[1] = 2+1 = 3  (把 "26" 解碼為 Z)
  dp[3] = 3

dp = [1, 1, 2, 3]
答案 = 3

三種解碼方式:
  "2","2","6" → B, B, F
  "22","6"    → V, F
  "2","26"    → B, Z
```

**範例 2：s = "106"，逐步追蹤（含 '0' 的棘手情況）**

```
s = "106"

dp[0] = 1  (base case)
dp[1] = 1  (s[0]='1' != '0')

i=2, 看 s[0:2] = "10":
  s[1]='0' == '0'    → 不加 dp[1]（'0' 無法單獨解碼!）
  s[0:2]="10", 10<=10<=26 → dp[2] += dp[0] = 1  (把 "10" 解碼為 J)
  dp[2] = 1

i=3, 看 s[0:3] = "106":
  s[2]='6' != '0'    → dp[3] += dp[2] = 1    (把 '6' 單獨解碼為 F)
  s[1:3]="06", 6 < 10 → 不加（"06" 不是有效的兩位數解碼）
  dp[3] = 1

dp = [1, 1, 1, 1]
答案 = 1

唯一解碼: "10","6" → J, F
```

**複雜度**：Time O(n), Space O(1)

---

## 第四章：子序列 DP (Subsequence DP)

### 4.1 Longest Increasing Subsequence — LIS (LC 300) — Google 高頻

**題目**：給一個整數陣列，找最長嚴格遞增子序列的長度。子序列不需要連續。

#### 方法 1: O(n^2) DP

**DP 五步框架**：

```
Step 1 — 狀態: dp[i] = 以 nums[i] 結尾的 LIS 長度
Step 2 — 轉移: dp[i] = max(dp[j] + 1) for all j < i where nums[j] < nums[i]
               （找所有在 i 前面且比 nums[i] 小的元素，取最長的 +1）
Step 3 — Base: dp[i] = 1（每個元素自己就是長度 1 的 LIS）
Step 4 — 順序: i 從左到右，內層 j 遍歷 0 到 i-1
Step 5 — 答案: max(dp)（LIS 不一定以最後一個元素結尾!）
```

```python
def lis(nums):
    n = len(nums)
    dp = [1] * n
    for i in range(1, n):
        for j in range(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
```

**範例 1：nums = [10, 9, 2, 5, 3, 7, 101, 18]，逐步追蹤每一次比較**

```
初始: dp = [1, 1, 1, 1, 1, 1, 1, 1]

i=0: nums[0]=10, 沒有前面的元素
     dp[0] = 1

i=1: nums[1]=9
     j=0: nums[0]=10 > 9? 不是 < 9，跳過
     dp[1] = 1

i=2: nums[2]=2
     j=0: nums[0]=10 > 2? 不是 < 2，跳過
     j=1: nums[1]=9 > 2?  不是 < 2，跳過
     dp[2] = 1

i=3: nums[3]=5
     j=0: nums[0]=10, 10 < 5? No，跳過
     j=1: nums[1]=9,  9 < 5?  No，跳過
     j=2: nums[2]=2,  2 < 5?  Yes! dp[3] = max(1, dp[2]+1) = max(1, 2) = 2
     dp[3] = 2                    ← LIS: [2, 5]

i=4: nums[4]=3
     j=0: 10 < 3? No
     j=1: 9 < 3?  No
     j=2: 2 < 3?  Yes! dp[4] = max(1, dp[2]+1) = max(1, 2) = 2
     j=3: 5 < 3?  No
     dp[4] = 2                    ← LIS: [2, 3]

i=5: nums[5]=7
     j=0: 10 < 7? No
     j=1: 9 < 7?  No
     j=2: 2 < 7?  Yes! dp[5] = max(1, dp[2]+1) = max(1, 2) = 2
     j=3: 5 < 7?  Yes! dp[5] = max(2, dp[3]+1) = max(2, 3) = 3
     j=4: 3 < 7?  Yes! dp[5] = max(3, dp[4]+1) = max(3, 3) = 3
     dp[5] = 3                    ← LIS: [2, 5, 7] 或 [2, 3, 7]

i=6: nums[6]=101
     j=0: 10 < 101? Yes! dp[6] = max(1, dp[0]+1) = 2
     j=1: 9 < 101?  Yes! dp[6] = max(2, dp[1]+1) = 2
     j=2: 2 < 101?  Yes! dp[6] = max(2, dp[2]+1) = 2
     j=3: 5 < 101?  Yes! dp[6] = max(2, dp[3]+1) = 3
     j=4: 3 < 101?  Yes! dp[6] = max(3, dp[4]+1) = 3
     j=5: 7 < 101?  Yes! dp[6] = max(3, dp[5]+1) = 4
     dp[6] = 4                    ← LIS: [2, 5, 7, 101] 或 [2, 3, 7, 101]

i=7: nums[7]=18
     j=0: 10 < 18? Yes! dp[7] = max(1, dp[0]+1) = 2
     j=1: 9 < 18?  Yes! dp[7] = max(2, dp[1]+1) = 2
     j=2: 2 < 18?  Yes! dp[7] = max(2, dp[2]+1) = 2
     j=3: 5 < 18?  Yes! dp[7] = max(2, dp[3]+1) = 3
     j=4: 3 < 18?  Yes! dp[7] = max(3, dp[4]+1) = 3
     j=5: 7 < 18?  Yes! dp[7] = max(3, dp[5]+1) = 4
     j=6: 101<18?  No
     dp[7] = 4                    ← LIS: [2, 3, 7, 18] 或 [2, 5, 7, 18]

最終 dp = [1, 1, 1, 2, 2, 3, 4, 4]
答案 = max(dp) = 4
```

**範例 2：nums = [0, 1, 0, 3, 2, 3]，逐步追蹤**

```
初始: dp = [1, 1, 1, 1, 1, 1]

i=0: dp[0] = 1

i=1: nums[1]=1
     j=0: 0 < 1? Yes! dp[1] = max(1, dp[0]+1) = 2
     dp[1] = 2                    ← LIS: [0, 1]

i=2: nums[2]=0
     j=0: 0 < 0? No (嚴格遞增，不能等於)
     j=1: 1 < 0? No
     dp[2] = 1                    ← LIS: [0]

i=3: nums[3]=3
     j=0: 0 < 3? Yes! dp[3] = max(1, 1+1) = 2
     j=1: 1 < 3? Yes! dp[3] = max(2, 2+1) = 3
     j=2: 0 < 3? Yes! dp[3] = max(3, 1+1) = 3
     dp[3] = 3                    ← LIS: [0, 1, 3]

i=4: nums[4]=2
     j=0: 0 < 2? Yes! dp[4] = max(1, 1+1) = 2
     j=1: 1 < 2? Yes! dp[4] = max(2, 2+1) = 3
     j=2: 0 < 2? Yes! dp[4] = max(3, 1+1) = 3
     j=3: 3 < 2? No
     dp[4] = 3                    ← LIS: [0, 1, 2]

i=5: nums[5]=3
     j=0: 0 < 3? Yes! dp[5] = max(1, 1+1) = 2
     j=1: 1 < 3? Yes! dp[5] = max(2, 2+1) = 3
     j=2: 0 < 3? Yes! dp[5] = max(3, 1+1) = 3
     j=3: 3 < 3? No (嚴格遞增)
     j=4: 2 < 3? Yes! dp[5] = max(3, 3+1) = 4
     dp[5] = 4                    ← LIS: [0, 1, 2, 3]

最終 dp = [1, 2, 1, 3, 3, 4]
答案 = max(dp) = 4
LIS: [0, 1, 2, 3]
```

#### 方法 2: O(n log n) Binary Search

```
維護一個 tails 陣列:
  tails[k] = 長度為 k+1 的所有遞增子序列中，末尾元素的最小值

對每個數字 num:
  - 如果 num 比 tails 裡所有元素都大 → append（LIS 變長了!）
  - 否則 → 用 binary search 找到第一個 >= num 的位置，替換掉
    （讓末尾元素盡可能小，給後面更多「成長空間」）

最後 len(tails) 就是 LIS 長度。
注意: tails 的內容不一定是真正的 LIS，但長度是正確的!
```

```python
import bisect

def lis_binary_search(nums):
    tails = []
    for num in nums:
        pos = bisect.bisect_left(tails, num)
        if pos == len(tails):
            tails.append(num)
        else:
            tails[pos] = num
    return len(tails)
```

以 nums = [10, 9, 2, 5, 3, 7, 101, 18] 為例 trace tails：

```
處理 10:  tails = [], 10 append         → tails = [10]
處理 9:   bisect_left([10], 9) = 0
          9 < 10, 替換 tails[0]          → tails = [9]
處理 2:   bisect_left([9], 2) = 0
          2 < 9, 替換 tails[0]           → tails = [2]
處理 5:   bisect_left([2], 5) = 1
          pos == len, append             → tails = [2, 5]
處理 3:   bisect_left([2, 5], 3) = 1
          3 < 5, 替換 tails[1]           → tails = [2, 3]
處理 7:   bisect_left([2, 3], 7) = 2
          pos == len, append             → tails = [2, 3, 7]
處理 101: bisect_left([2, 3, 7], 101) = 3
          pos == len, append             → tails = [2, 3, 7, 101]
處理 18:  bisect_left([2, 3, 7, 101], 18) = 3
          18 < 101, 替換 tails[3]        → tails = [2, 3, 7, 18]

len(tails) = 4 → 答案 = 4   ✓
```

**複雜度對比**：

```
┌──────────────────┬──────────┬──────────┐
│ 方法              │ Time     │ Space    │
├──────────────────┼──────────┼──────────┤
│ DP (O(n^2))      │ O(n^2)   │ O(n)     │
│ Binary Search    │ O(n logn)│ O(n)     │
└──────────────────┴──────────┴──────────┘
面試時: 先說 O(n^2) 解法展示 DP 思維，再優化到 O(n log n)。
```

---

### 4.2 Maximum Subarray / Kadane's Algorithm (LC 53)

**題目**：找連續子陣列的最大和。

**DP 五步框架**：

```
Step 1 — 狀態: dp[i] = 以 nums[i] 結尾的最大連續子陣列和
Step 2 — 轉移: dp[i] = max(nums[i], dp[i-1] + nums[i])
Step 3 — Base: dp[0] = nums[0]
Step 4 — 順序: 左到右
Step 5 — 答案: max(dp)
```

**口訣：接著前面 or 重新開始**

```
對每個元素 nums[i]，只有兩個選擇：
  1. 把 nums[i] 「接到」前面的子陣列後面 → dp[i-1] + nums[i]
  2. 以 nums[i] 「重新開始」一個新的子陣列 → nums[i]

如果前面的子陣列和是負數，那接上只會拖累，不如重新開始!
```

```python
def max_subarray(nums):
    current_sum = max_sum = nums[0]
    for i in range(1, len(nums)):
        current_sum = max(nums[i], current_sum + nums[i])
        max_sum = max(max_sum, current_sum)
    return max_sum
```

**範例 1：nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]，逐步追蹤**

```
i=0: num=-2, cur_sum=-2,                              best=-2
i=1: num= 1, cur_sum=max(1, -2+1)=max(1, -1)=1,      best=1   ← 重新開始!
i=2: num=-3, cur_sum=max(-3, 1+(-3))=max(-3, -2)=-2,  best=1
i=3: num= 4, cur_sum=max(4, -2+4)=max(4, 2)=4,        best=4   ← 重新開始!
i=4: num=-1, cur_sum=max(-1, 4+(-1))=max(-1, 3)=3,    best=4
i=5: num= 2, cur_sum=max(2, 3+2)=max(2, 5)=5,         best=5
i=6: num= 1, cur_sum=max(1, 5+1)=max(1, 6)=6,         best=6   ← 最大!
i=7: num=-5, cur_sum=max(-5, 6+(-5))=max(-5, 1)=1,    best=6
i=8: num= 4, cur_sum=max(4, 1+4)=max(4, 5)=5,         best=6

答案 = 6，對應子陣列 = [4, -1, 2, 1]（index 3~6）
```

**範例 2：nums = [5, 4, -1, 7, 8]，逐步追蹤**

```
i=0: num=5,  cur_sum=5,                           best=5
i=1: num=4,  cur_sum=max(4, 5+4)=max(4, 9)=9,    best=9
i=2: num=-1, cur_sum=max(-1, 9-1)=max(-1, 8)=8,  best=9
i=3: num=7,  cur_sum=max(7, 8+7)=max(7, 15)=15,  best=15
i=4: num=8,  cur_sum=max(8, 15+8)=max(8, 23)=23, best=23

答案 = 23，子陣列 = [5, 4, -1, 7, 8]（整個陣列!）
```

**複雜度**：Time O(n), Space O(1)

---

### 4.3 Word Break (LC 139)

**題目**：判斷字串 s 能否被分割成字典 wordDict 中的單字（單字可重複使用）。

**DP 五步框架**：

```
Step 1 — 狀態: dp[i] = s[0:i]（前 i 個字元）能否被拆成字典中的單字
Step 2 — 轉移: dp[i] = True if any(dp[j]==True AND s[j:i] in wordSet)
               for j from 0 to i-1
               （存在某個分割點 j，使得前 j 個字元能拆，且 s[j:i] 是字典字）
Step 3 — Base: dp[0] = True（空字串可以）
Step 4 — 順序: i 從 1 到 n
Step 5 — 答案: dp[n]
```

```python
def word_break(s, wordDict):
    word_set = set(wordDict)
    n = len(s)
    dp = [False] * (n + 1)
    dp[0] = True
    for i in range(1, n + 1):
        for j in range(i):
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break
    return dp[n]
```

**範例 1：s = "leetcode", wordDict = ["leet", "code"]**

```
word_set = {"leet", "code"}

dp[0] = True  (base case)

dp[1]: j=0, dp[0]=T, s[0:1]="l" in set? No → dp[1] = False

dp[2]: j=0, dp[0]=T, s[0:2]="le" in set? No
       j=1, dp[1]=F → 跳過
       dp[2] = False

dp[3]: j=0, dp[0]=T, s[0:3]="lee" in set? No
       j=1, dp[1]=F → 跳過
       j=2, dp[2]=F → 跳過
       dp[3] = False

dp[4]: j=0, dp[0]=T, s[0:4]="leet" in set? Yes! → dp[4] = True ✓

dp[5]: j=0, dp[0]=T, s[0:5]="leetc" in set? No
       j=1~3, dp[1]~dp[3]=F → 跳過
       j=4, dp[4]=T, s[4:5]="c" in set? No
       dp[5] = False

dp[6]: 類似，全部 False → dp[6] = False

dp[7]: 類似，全部 False → dp[7] = False

dp[8]: j=0, dp[0]=T, s[0:8]="leetcode" in set? No
       j=1~3, F → 跳過
       j=4, dp[4]=T, s[4:8]="code" in set? Yes! → dp[8] = True ✓

dp = [T, F, F, F, T, F, F, F, T]
答案 = dp[8] = True

拆法: "leet" + "code"
```

**範例 2：s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]**

```
word_set = {"cats", "dog", "sand", "and", "cat"}

dp[0] = True

dp[3]: j=0, dp[0]=T, s[0:3]="cat" in set? Yes! → dp[3] = True
dp[4]: j=0, dp[0]=T, s[0:4]="cats" in set? Yes! → dp[4] = True
dp[7]: j=3, dp[3]=T, s[3:7]="sand" in set? Yes! → dp[7] = True
       (也可以 j=4, dp[4]=T, s[4:7]="and" in set? Yes!)

dp[9]: 檢查所有 j:
       j=7, dp[7]=T, s[7:9]="og" in set? No
       j=6, dp[6]=?
         dp[6]: j=3, dp[3]=T, s[3:6]="san" No
                j=4, dp[4]=T, s[4:6]="an" No
                dp[6] = False → 跳過
       ...其他 j 也找不到匹配
       dp[9] = False

答案 = False（"andog" 無法用字典拆分）
```

**複雜度**：Time O(n^2 * m)（m 為平均字長），Space O(n)

---

## 第五章：股票系列 (Stock Problems)

### 5.1 Best Time to Buy and Sell Stock (LC 121)

**題目**：給每天股票價格，只能買賣一次，求最大利潤。

**核心想法**：遍歷價格時，追蹤「到目前為止的最低價」，每天算「今天賣的利潤」。

```
為什麼這樣做是對的？
  - 要最大化利潤 = 賣價 - 買價
  - 賣出的那天之前，一定要先買入
  - 所以對每個可能的賣出日 i，最佳買入日一定是 i 之前價格最低的那天
  - 我們用 min_price 追蹤「到 i 之前的最低價」
```

```python
def max_profit(prices):
    min_price = float('inf')
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit
```

**範例 1：prices = [7, 1, 5, 3, 6, 4]，逐步追蹤**

```
day 0: price=7, min_price=min(inf, 7)=7, profit=7-7=0,  best=0
day 1: price=1, min_price=min(7, 1)=1,   profit=1-1=0,  best=0   ← 新最低價!
day 2: price=5, min_price=min(1, 5)=1,   profit=5-1=4,  best=4
day 3: price=3, min_price=min(1, 3)=1,   profit=3-1=2,  best=4
day 4: price=6, min_price=min(1, 6)=1,   profit=6-1=5,  best=5   ← 最大利潤!
day 5: price=4, min_price=min(1, 4)=1,   profit=4-1=3,  best=5

答案 = 5（day 1 買入 price=1, day 4 賣出 price=6, 利潤 6-1=5）
```

**範例 2：prices = [7, 6, 4, 3, 1]，逐步追蹤**

```
day 0: price=7, min=7, profit=0, best=0
day 1: price=6, min=6, profit=0, best=0
day 2: price=4, min=4, profit=0, best=0
day 3: price=3, min=3, profit=0, best=0
day 4: price=1, min=1, profit=0, best=0

答案 = 0（價格一路下跌，不要買!）
```

**複雜度**：Time O(n), Space O(1)

---

### 5.2 Best Time to Buy and Sell Stock with Cooldown (LC 309)

**題目**：可以買賣無限次，但賣出後隔天必須冷卻（不能買），求最大利潤。

**核心想法**：用狀態機 (State Machine) 來思考。

#### 狀態機圖解

```
三個狀態:
  hold  — 手上持有股票（之前某天買了，還沒賣）
  sold  — 今天剛賣出（明天要冷卻）
  rest  — 空手（可以買或繼續等）

狀態之間的轉移:

          ┌─────── 繼續持有 ──────┐
          ↓                       │
  rest ──買入──→ hold ──賣出──→ sold
   ↑                               │
   │                               │
   └───── 維持空手 ←── 冷卻結束 ────┘

轉移方程:
  hold[i] = max(hold[i-1],  rest[i-1] - prices[i])
            繼續持有         冷卻完後今天買入

  sold[i] = hold[i-1] + prices[i]
            今天把手上的股票賣掉

  rest[i] = max(rest[i-1],  sold[i-1])
            繼續空手          昨天賣的，今天冷卻完成
```

```python
def max_profit_cooldown(prices):
    if len(prices) <= 1:
        return 0
    hold = -prices[0]   # day 0 買入
    sold = 0
    rest = 0
    for i in range(1, len(prices)):
        prev_hold = hold
        hold = max(hold, rest - prices[i])
        rest = max(rest, sold)
        sold = prev_hold + prices[i]
    return max(sold, rest)
```

**範例 1：prices = [1, 2, 3, 0, 2]，逐步追蹤三個狀態**

```
初始 (day 0, price=1):
  hold = -1  (買入第 0 天的股票)
  sold = 0
  rest = 0

day 1, price=2:
  prev_hold = -1
  hold = max(-1, 0-2)  = max(-1, -2) = -1     ← 繼續持有(比今天買好)
  rest = max(0, 0)      = 0                     ← 繼續空手
  sold = -1+2           = 1                     ← 今天賣(買價1,賣價2)

  三個狀態: hold=-1, sold=1, rest=0

day 2, price=3:
  prev_hold = -1
  hold = max(-1, 0-3)  = max(-1, -3) = -1     ← 繼續持有
  rest = max(0, 1)      = 1                     ← 昨天賣的冷卻完
  sold = -1+3           = 2                     ← 今天賣(買價1,賣價3)

  三個狀態: hold=-1, sold=2, rest=1

day 3, price=0:
  prev_hold = -1
  hold = max(-1, 1-0)  = max(-1, 1) = 1       ← 冷卻完後今天買(超便宜!)
  rest = max(1, 2)      = 2                     ← 前天賣的冷卻完
  sold = -1+0           = -1                    ← 虧損(不好)

  三個狀態: hold=1, sold=-1, rest=2

day 4, price=2:
  prev_hold = 1
  hold = max(1, 2-2)   = max(1, 0) = 1        ← 繼續持有
  rest = max(2, -1)     = 2                     ← 繼續空手
  sold = 1+2            = 3                     ← 今天賣!

  三個狀態: hold=1, sold=3, rest=2

答案 = max(sold, rest) = max(3, 2) = 3

最佳操作: day 0 買(1) → day 1 賣(2) → day 2 冷卻 → day 3 買(0) → day 4 賣(2)
利潤: (2-1) + (2-0) = 1 + 2 = 3
```

**範例 2：prices = [1, 2, 4]，逐步追蹤**

```
初始 (day 0): hold=-1, sold=0, rest=0

day 1, price=2:
  prev_hold = -1
  hold = max(-1, 0-2) = -1     ← 繼續持有
  rest = max(0, 0) = 0
  sold = -1+2 = 1              ← 今天賣

  三個狀態: hold=-1, sold=1, rest=0

day 2, price=4:
  prev_hold = -1
  hold = max(-1, 0-4) = -1     ← 繼續持有
  rest = max(0, 1) = 1         ← 冷卻完
  sold = -1+4 = 3              ← 今天賣

  三個狀態: hold=-1, sold=3, rest=1

答案 = max(3, 1) = 3

最佳操作: day 0 買(1) → day 2 賣(4)，利潤 = 4-1 = 3
（不用中間賣再買，直接持有到最高價!）
```

**複雜度**：Time O(n), Space O(1)

---

## 第六章：Coin Change (LC 322) — DP 經典中的經典

**題目**：給定不同面額的硬幣和一個目標金額，求湊出目標金額的最少硬幣數。每種硬幣可以無限使用。

### 為什麼 Greedy（貪心）會失敗？

```
coins = [1, 3, 4], amount = 6

Greedy 策略: 每次拿最大的硬幣
  → 4 + 1 + 1 = 6，用了 3 枚

DP 最優解:
  → 3 + 3 = 6，只用 2 枚!

Greedy 不一定能找到最優解，因為「先拿最大的」可能讓你走進死胡同。
所以我們需要 DP 來考慮所有可能的組合!
```

### DP 五步框架

```
Step 1 — 狀態: dp[i] = 湊出金額 i 的最少硬幣數
Step 2 — 轉移: dp[i] = min(dp[i - coin] + 1) for each coin in coins
               （最後一枚放什麼硬幣？放 coin，那剩下的金額 i-coin 需要 dp[i-coin] 枚）
Step 3 — Base: dp[0] = 0（金額 0 不需要任何硬幣）
               dp[i] = infinity for i > 0（初始假設湊不出）
Step 4 — 順序: i 從 1 到 amount
Step 5 — 答案: dp[amount]（如果是 infinity 則回傳 -1）
```

```python
def coin_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i and dp[i - coin] != float('inf'):
                dp[i] = min(dp[i], dp[i - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1
```

### 範例 1：coins = [1, 2, 5], amount = 11，完整追蹤

```
初始: dp = [0, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf]

dp[1]:
  coin=1: 1<=1, dp[1-1]=dp[0]=0 → dp[1]=min(inf, 0+1)=1
  coin=2: 2>1, 跳過
  coin=5: 5>1, 跳過
  dp[1] = 1                     ← 用 1 枚: [1]

dp[2]:
  coin=1: dp[2-1]=dp[1]=1 → dp[2]=min(inf, 1+1)=2
  coin=2: dp[2-2]=dp[0]=0 → dp[2]=min(2, 0+1)=1
  coin=5: 5>2, 跳過
  dp[2] = 1                     ← 用 1 枚: [2]

dp[3]:
  coin=1: dp[3-1]=dp[2]=1 → dp[3]=min(inf, 1+1)=2
  coin=2: dp[3-2]=dp[1]=1 → dp[3]=min(2, 1+1)=2
  coin=5: 5>3, 跳過
  dp[3] = 2                     ← 用 2 枚: [1,2]

dp[4]:
  coin=1: dp[3]=2 → dp[4]=min(inf, 2+1)=3
  coin=2: dp[2]=1 → dp[4]=min(3, 1+1)=2
  coin=5: 5>4, 跳過
  dp[4] = 2                     ← 用 2 枚: [2,2]

dp[5]:
  coin=1: dp[4]=2 → dp[5]=min(inf, 2+1)=3
  coin=2: dp[3]=2 → dp[5]=min(3, 2+1)=3
  coin=5: dp[0]=0 → dp[5]=min(3, 0+1)=1
  dp[5] = 1                     ← 用 1 枚: [5]

dp[6]:
  coin=1: dp[5]=1 → dp[6]=min(inf, 1+1)=2
  coin=2: dp[4]=2 → dp[6]=min(2, 2+1)=2
  coin=5: dp[1]=1 → dp[6]=min(2, 1+1)=2
  dp[6] = 2                     ← 用 2 枚: [5,1]

dp[7]:
  coin=1: dp[6]=2 → dp[7]=min(inf, 2+1)=3
  coin=2: dp[5]=1 → dp[7]=min(3, 1+1)=2
  coin=5: dp[2]=1 → dp[7]=min(2, 1+1)=2
  dp[7] = 2                     ← 用 2 枚: [5,2]

dp[8]:
  coin=1: dp[7]=2 → dp[8]=min(inf, 2+1)=3
  coin=2: dp[6]=2 → dp[8]=min(3, 2+1)=3
  coin=5: dp[3]=2 → dp[8]=min(3, 2+1)=3
  dp[8] = 3                     ← 用 3 枚: [5,2,1]

dp[9]:
  coin=1: dp[8]=3 → dp[9]=min(inf, 3+1)=4
  coin=2: dp[7]=2 → dp[9]=min(4, 2+1)=3
  coin=5: dp[4]=2 → dp[9]=min(3, 2+1)=3
  dp[9] = 3                     ← 用 3 枚: [5,2,2]

dp[10]:
  coin=1: dp[9]=3 → dp[10]=min(inf, 3+1)=4
  coin=2: dp[8]=3 → dp[10]=min(4, 3+1)=4
  coin=5: dp[5]=1 → dp[10]=min(4, 1+1)=2
  dp[10] = 2                    ← 用 2 枚: [5,5]

dp[11]:
  coin=1: dp[10]=2 → dp[11]=min(inf, 2+1)=3
  coin=2: dp[9]=3  → dp[11]=min(3, 3+1)=3
  coin=5: dp[6]=2  → dp[11]=min(3, 2+1)=3
  dp[11] = 3                    ← 用 3 枚: [5,5,1]

最終 dp = [0, 1, 1, 2, 2, 1, 2, 2, 3, 3, 2, 3]
答案 = 3（5 + 5 + 1 = 11）
```

### 範例 2：coins = [2], amount = 3（不可能的情況）

```
dp[0] = 0
dp[1]: coin=2, 2>1, 跳過 → dp[1] = inf（湊不出 1!）
dp[2]: coin=2, dp[0]=0 → dp[2] = 1
dp[3]: coin=2, dp[1]=inf → 跳過 → dp[3] = inf（湊不出 3!）

dp = [0, inf, 1, inf]
dp[3] = inf → 回傳 -1

原因: 只有面額 2 的硬幣，永遠湊不出奇數金額!
```

**複雜度**：Time O(amount * len(coins)), Space O(amount)

---

## 第七章：DP 面試心法

### 7.1 如何辨識 DP 問題

```
看到這些關鍵字，腦中要響起 DP 警報:

┌────────────────────────────────────────────────────────┐
│ 關鍵字                     │ DP 類型                    │
├────────────────────────────┼────────────────────────────┤
│ "最少/最多/最大/最小"       │ 最佳化 DP (Optimization)   │
│ "有幾種方法/方式"           │ 計數 DP (Counting)         │
│ "能不能/是否可以"           │ 可行性 DP (Feasibility)    │
│ "連續子陣列" + 最大/最小    │ Kadane's / 線性 DP         │
│ "子序列" (不用連續)         │ 子序列 DP                   │
│ "用...湊出..."             │ 背包 / Coin Change          │
│ "不能選相鄰的"             │ House Robber 型              │
└────────────────────────────┴────────────────────────────┘

但要注意: 並非所有最佳化問題都用 DP!
  - 如果沒有「重疊子問題」→ 考慮 Greedy
  - 如果需要「所有組合」→ 考慮 Backtracking
```

### 7.2 狀態定義的常見模式

```
模式 1: dp[i] 依賴 dp[i-1], dp[i-2]
  → Fibonacci, Climbing Stairs, House Robber, Decode Ways
  → 可以用 2 個變數優化空間

模式 2: dp[i] 依賴所有 dp[j] (j < i)
  → LIS, Word Break
  → 需要一層內部迴圈

模式 3: dp[i] 依賴 dp[i-coin] for each coin
  → Coin Change
  → 對每個「選項」遍歷

模式 4: 多狀態 DP（狀態機）
  → Stock with Cooldown (hold/sold/rest)
  → 定義多個 dp 陣列，互相轉移
```

### 7.3 轉移方程的常見類型

```
類型 1: 累加型（計數問題）
  dp[i] = dp[i-1] + dp[i-2]
  → 有幾種方法？加起來!

類型 2: 取 max/min 型（最佳化問題）
  dp[i] = max(dp[i-1], dp[i-2] + nums[i])
  → 哪個選擇更好？取最大/最小!

類型 3: 遍歷所有選項型
  dp[i] = min/max(dp[i-option] + cost) for each option
  → 嘗試每個可能的「最後一步」

類型 4: 布林型（可行性問題）
  dp[i] = any(dp[j] and condition(j, i))
  → 存在某個 j 使得條件成立嗎？
```

### 7.4 空間優化技巧

```
觀察 dp[i] 依賴哪些之前的值:

┌─────────────────────────┬───────────────────────────────┐
│ 依賴關係                 │ 優化方式                       │
├─────────────────────────┼───────────────────────────────┤
│ 只依賴 dp[i-1], dp[i-2] │ 用 prev1, prev2 兩個變數      │
│ 例: Fibonacci, Stairs,  │ O(n) → O(1)                   │
│     House Robber         │                               │
├─────────────────────────┼───────────────────────────────┤
│ 依賴 dp[0..i-1] 全部    │ 無法優化，保留整個陣列          │
│ 例: LIS, Word Break     │ 維持 O(n)                     │
├─────────────────────────┼───────────────────────────────┤
│ 狀態機（多個狀態）       │ 每個狀態用一個變數             │
│ 例: Stock+Cooldown      │ hold, sold, rest 三個 O(1)    │
└─────────────────────────┴───────────────────────────────┘
```

### 7.5 面試時的解題流程

```
Step 1: 聽完題目，判斷是不是 DP
  → 有「最佳化/計數/可行性」+ 「重疊子問題」?

Step 2: 跟面試官確認理解
  → 釐清邊界條件 (edge cases)

Step 3: 先寫暴力遞迴解法
  → 展示你理解問題
  → 畫遞迴樹，指出重疊子問題

Step 4: 加 Memoization → Top-down DP
  → 直接在遞迴上加 memo
  → 複雜度分析

Step 5: 轉成 Bottom-up Tabulation
  → 用 for 迴圈 + dp array
  → 這是面試最常寫的版本

Step 6: 問面試官要不要優化空間
  → 如果只依賴前幾個狀態，可以用 O(1)

Google 面試 tip:
  - 通常不會只問 DP 原題，而是變形題
  - 重點是展示「DP 思考過程」，而不只是背答案
  - 能清楚解釋「狀態定義」和「轉移方程」最重要
```

### 7.6 本章所有題目速查表

```
┌───────────────────────┬──────────────────────────┬────────────┐
│ 題目                   │ 轉移方程                  │ 複雜度      │
├───────────────────────┼──────────────────────────┼────────────┤
│ Fibonacci (概念)       │ dp[i-1] + dp[i-2]       │ O(n)/O(1)  │
│ LC 70 Climbing Stairs │ dp[i-1] + dp[i-2]       │ O(n)/O(1)  │
│ LC 198 House Robber   │ max(skip, rob)           │ O(n)/O(1)  │
│ LC 213 House Robber II│ 拆成兩個 HR I            │ O(n)/O(1)  │
│ LC 91 Decode Ways     │ 一位 or 兩位解碼         │ O(n)/O(1)  │
│ LC 300 LIS (DP)       │ max(dp[j]+1) for j<i    │ O(n^2)/O(n)│
│ LC 300 LIS (BS)       │ tails + binary search    │O(nlogn)/O(n)|
│ LC 53 Max Subarray    │ max(num, cur+num)        │ O(n)/O(1)  │
│ LC 139 Word Break     │ dp[j] && s[j:i] in dict │ O(n^2)/O(n)│
│ LC 121 Stock I        │ track min_price          │ O(n)/O(1)  │
│ LC 309 Stock Cooldown │ hold/sold/rest 狀態機    │ O(n)/O(1)  │
│ LC 322 Coin Change    │ min(dp[i-c]+1) for c    │O(n*k)/O(n) │
└───────────────────────┴──────────────────────────┴────────────┘

其中 n = 輸入大小, k = coins 數量
```

### 7.7 常見錯誤與陷阱

```
陷阱 1: Base case 搞錯
  → Climbing Stairs: dp[0] 到底是 0 還是 1?
  → Coin Change: dp[0] = 0（金額 0 需要 0 枚硬幣）
  → Word Break: dp[0] = True（空字串算成功）
  建議: 手動驗算 dp[0], dp[1] 是否正確

陷阱 2: 計算順序錯誤
  → 填 dp[i] 時，dp[j] (j<i) 必須已經算好
  → 通常左到右就對了

陷阱 3: 忘記處理不可能的情況
  → Coin Change: dp[amount] 可能是 infinity → 回傳 -1
  → Decode Ways: 遇到 '0' 要特殊處理

陷阱 4: 混淆「子陣列」和「子序列」
  → 子陣列 (Subarray): 連續的 — Kadane's Algorithm
  → 子序列 (Subsequence): 不連續 — LIS

陷阱 5: 空間優化時覆蓋了還需要的值
  → 用 prev_hold = hold 暫存（Stock Cooldown）
  → 或用 tmp 變數保存上一步的值
```

> **最後鼓勵**：DP 確實是面試中最難的主題，但它也是有規律的。只要你掌握了
> 「定義狀態 → 寫轉移方程 → 確定 base case → 填表 → 回傳答案」這五步，
> 大部分 1D DP 題目都能迎刃而解。多練習、多畫表格，你會慢慢建立 DP 直覺!
