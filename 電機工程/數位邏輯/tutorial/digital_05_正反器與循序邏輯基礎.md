# 數位邏輯教學講義 第五章：正反器與循序邏輯基礎

---

## 🔰 **本章基礎觀念（零基礎必讀）**

前面學的加法器、解碼器、MUX 都是「組合邏輯」——輸出只看當下的輸入，沒有記憶。
但很多應用需要「記住」東西：計數器要記住數到哪、暫存器要存資料。
**正反器 (Flip-Flop)** 就是數位電路中最基本的記憶元件，它能儲存 1 個 bit。
千億個正反器組合起來，就是你電腦裡的記憶體和暫存器。

> **學完本章，你應該能做到：**
> 1. 區分 Latch 和 Flip-Flop（位準觸發 vs 邊緣觸發）
> 2. 畫出 SR、D、JK、T 四種正反器的特性表和電路
> 3. 理解 Setup Time、Hold Time、Clock-to-Q Delay
> 4. 知道 Metastability 是什麼以及為什麼危險
> 5. 理解暫存器和移位暫存器的結構

---

## 關鍵術語表

| 中文 | 英文 | 白話解釋 | 例子 |
|------|------|----------|------|
| 鎖存器 | Latch | 位準觸發的記憶元件 | SR Latch, D Latch |
| 正反器 | Flip-Flop (FF) | 邊緣觸發的記憶元件 | D FF, JK FF |
| 位準觸發 | Level-Triggered | 在時脈為高(或低)的整段時間內都可以改值 | Latch |
| 邊緣觸發 | Edge-Triggered | 只在時脈的上升(或下降)瞬間才取樣 | Flip-Flop |
| 特性表 | Characteristic Table | 列出輸入→下一狀態的關係 | Q(t+1) = f(輸入, Q(t)) |
| 激勵表 | Excitation Table | 想要某個狀態轉移，需要什麼輸入 | Q→Q+1 需要 J=?, K=? |
| 建立時間 | Setup Time (tsu) | 資料必須在時脈邊緣**之前**穩定的最短時間 | 違反→不確定 |
| 保持時間 | Hold Time (th) | 資料必須在時脈邊緣**之後**維持的最短時間 | 違反→不確定 |
| 傳播延遲 | Clock-to-Q Delay (tcq) | 時脈邊緣到輸出穩定的時間 | 決定最高時脈速度 |
| 亞穩態 | Metastability | FF 進入既不是 0 也不是 1 的不穩定狀態 | 非常危險的故障 |
| 暫存器 | Register | 多個 FF 並排，同時儲存多個 bit | 8-bit Register |
| 移位暫存器 | Shift Register | FF 串接，資料逐步移動 | SISO, PIPO 等 |

---

## 一、鎖存器 (Latch)

### 1.1 SR Latch（用 NOR 閘實現）

```
            ┌────┐
S ──────────┤NOR ├──┬── Q
        ┌───┤    │  │
        │   └────┘  │
        │           │（交叉回授）
        │   ┌────┐  │
        └───┤NOR ├──┴── Q'
R ──────────┤    │
            └────┘
```

**特性表**：

| S | R | Q(t+1) | 說明 |
|---|---|--------|------|
| 0 | 0 | Q(t) | **保持** (Hold) |
| 0 | 1 | 0 | **重設** (Reset) |
| 1 | 0 | 1 | **設定** (Set) |
| 1 | 1 | **禁止** | Q=Q'=0，不合法！ |

> **S=R=1 是禁止狀態**：Q 和 Q' 都變 0，不再互補，而且放開後結果不確定。

### 1.2 SR Latch（用 NAND 閘實現）

```
            ┌─────┐
S' ─────────┤NAND ├──┬── Q
        ┌───┤     │  │
        │   └─────┘  │
        │             │
        │   ┌─────┐   │
        └───┤NAND ├───┴── Q'
R' ─────────┤     │
            └─────┘
```

注意：NAND 型 SR Latch 的輸入是**低態動作 (Active Low)**。

| S' | R' | Q(t+1) | 說明 |
|----|----|--------|------|
| 1 | 1 | Q(t) | 保持 |
| 1 | 0 | 0 | Reset |
| 0 | 1 | 1 | Set |
| 0 | 0 | **禁止** | 不合法 |

### 1.3 D Latch（消除禁止狀態）

**核心想法**：用一個反相器確保 S 和 R 永遠互補，就不可能 S=R=1 了！

```
D ──────┬──[AND]─── S ──┐
        │               │
CLK ────┼──[AND]    SR Latch ── Q
        │               │
D' ─────┴──[AND]─── R ──┘
```

**特性表**：

| CLK | D | Q(t+1) | 說明 |
|-----|---|--------|------|
| 0 | X | Q(t) | 保持（不透通） |
| 1 | 0 | 0 | 跟隨 D |
| 1 | 1 | 1 | 跟隨 D |

> **D Latch 是「透明的 (Transparent)」**：當 CLK=1 時，Q 直接跟著 D 走。
> 這在某些場景會造成問題（資料穿透），所以我們需要 Flip-Flop。

---

## 二、正反器 (Flip-Flop)：邊緣觸發

### Latch vs Flip-Flop：最關鍵的差異

| | Latch | Flip-Flop |
|--|-------|-----------|
| 觸發方式 | **位準觸發** (Level) | **邊緣觸發** (Edge) |
| 取樣時機 | CLK=1 的整段時間 | 只在 CLK 的上升/下降**瞬間** |
| 透明性 | 透明（D 改變會穿透） | 不透明（取樣後鎖住） |
| 設計偏好 | 少用 | **同步設計主流** |

```
Latch:      ┌──────────┐
CLK ════════╡  透通區間  ╞════
D   ──╲╱──╲╱──╲╱──╲╱──
Q     ──╲╱──╲╱──╲╱──     Q 隨 D 改變

Flip-Flop:  ↑         ↑         ↑
CLK ════╗  ╔══╗  ╔══╗
        ╚══╝  ╚══╝  ╚══╝
D   ──╲╱──╲╱──╲╱──╲╱──
Q     ────────╱──────╲──  Q 只在 ↑ 瞬間取樣
```

### 2.1 D Flip-Flop（最常用！）

**Master-Slave 結構**：用兩個 D Latch 串接。

```
D ──→ [D Latch 1 (Master)] ──→ [D Latch 2 (Slave)] ──→ Q
       CLK (原始)                  CLK' (反相)

CLK=0: Master 透通(存入D)，Slave 鎖住(保持)
CLK=1: Master 鎖住(保持)，Slave 透通(將Master值送出)
```

**效果**：Q 只在 CLK 的上升邊緣(positive edge)更新。

**特性表**：

| CLK | D | Q(t+1) |
|-----|---|--------|
| ↑ | 0 | 0 |
| ↑ | 1 | 1 |
| 其他 | X | Q(t) |

**特性方程**：
```
Q(t+1) = D
```

**激勵表**（設計循序電路時用）：

| Q(t) | Q(t+1) | D |
|------|--------|---|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

> **D = Q(t+1)**，設計最直覺！

### 2.2 SR Flip-Flop

**特性表**：

| S | R | Q(t+1) | 說明 |
|---|---|--------|------|
| 0 | 0 | Q(t) | 保持 |
| 0 | 1 | 0 | Reset |
| 1 | 0 | 1 | Set |
| 1 | 1 | 禁止 | 不允許 |

**特性方程**：
```
Q(t+1) = S + R'Q(t)    （條件：SR=0）
```

**激勵表**：

| Q(t) | Q(t+1) | S | R |
|------|--------|---|---|
| 0 | 0 | 0 | X |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 0 | 1 |
| 1 | 1 | X | 0 |

### 2.3 JK Flip-Flop

**解決 SR FF 的禁止問題**：J=K=1 時做「切換 (Toggle)」。

**特性表**：

| J | K | Q(t+1) | 說明 |
|---|---|--------|------|
| 0 | 0 | Q(t) | 保持 |
| 0 | 1 | 0 | Reset |
| 1 | 0 | 1 | Set |
| 1 | 1 | Q'(t) | **切換 (Toggle)** |

**特性方程**：
```
Q(t+1) = JQ'(t) + K'Q(t)
```

**激勵表**：

| Q(t) | Q(t+1) | J | K |
|------|--------|---|---|
| 0 | 0 | 0 | X |
| 0 | 1 | 1 | X |
| 1 | 0 | X | 1 |
| 1 | 1 | X | 0 |

> **JK FF 的激勵表有很多 X（Don't Care）**，設計時可以多利用 K-map 化簡。

### 2.4 T Flip-Flop（Toggle FF）

**功能**：T=1 時切換，T=0 時保持。

**特性表**：

| T | Q(t+1) | 說明 |
|---|--------|------|
| 0 | Q(t) | 保持 |
| 1 | Q'(t) | 切換 |

**特性方程**：
```
Q(t+1) = T ⊕ Q(t) = TQ'(t) + T'Q(t)
```

**激勵表**：

| Q(t) | Q(t+1) | T |
|------|--------|---|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

> **T = Q(t) ⊕ Q(t+1)**

### 四種 FF 比較總表

| FF 類型 | 特性方程 | 輸入數 | 禁止狀態？ | 常用場景 |
|---------|---------|--------|-----------|---------|
| SR | Q+ = S + R'Q | 2 | S=R=1 禁止 | 基本分析 |
| D | Q+ = D | 1 | 無 | **暫存器（最常用）** |
| JK | Q+ = JQ' + K'Q | 2 | 無（J=K=1→Toggle） | 計數器 |
| T | Q+ = T⊕Q | 1 | 無 | **計數器（最簡單）** |

---

## 三、時序參數（★IC 設計面試重點）

### 3.1 三個關鍵時間

```
          tsu       th
         ←──→     ←──→
D ═══════╳───────────╳═══════
              ↑
         ┌────┤
CLK ─────┘    │
              │
              ├─── tcq ───→
              │            │
Q ════════════╳════════════╳═══ (新值穩定)
```

**Setup Time (tsu)**：
資料 D 必須在時脈上升邊緣**之前** tsu 時間就穩定。
如果 D 在上升邊緣前 tsu 內還在變化 → 可能取樣到錯誤值。

**Hold Time (th)**：
資料 D 必須在時脈上升邊緣**之後** th 時間內保持穩定。
如果 D 在上升邊緣後太早改變 → 可能污染已取樣的值。

**Clock-to-Q Delay (tcq)**：
從時脈上升邊緣到 Q 輸出穩定的延遲時間。

### 3.2 最大時脈頻率

```
組合邏輯的延遲 = tcomb

時序約束：tcq + tcomb + tsu ≤ T (時脈週期)

最大頻率：fmax = 1 / (tcq + tcomb + tsu)
```

> **這是 IC 設計中最重要的時序公式之一！**
> 面試一定會問：「你的電路最高能跑多快？」

### 3.3 亞穩態 (Metastability)

**什麼時候發生？**
當 D 在 setup time 或 hold time 的禁區內改變時，FF 無法確定要取樣 0 還是 1，
就會進入一個**既不是 0 也不是 1 的中間態**。

```
正常：  Q →   ─── 1 ───
或       Q →   ─── 0 ───

亞穩態：Q →   ───╱╲───   （在中間擺盪，不確定何時解析）
                 ????
```

**為什麼危險？**
1. 亞穩態可能持續很長時間（理論上無限，但機率指數遞減）
2. 下一級電路可能把它判讀成 0 或 1 → **不同電路判讀不同 → 系統行為不可預測**
3. 在跨時脈域(CDC)設計中特別容易發生

**如何降低風險？**
→ 詳見第八章的兩級 FF 同步器

---

## 四、暫存器 (Register)

### n-bit 暫存器

n 個 D FF 並排，共用同一個 CLK。

```
4-bit Register:

D₃ → [D FF] → Q₃
D₂ → [D FF] → Q₂     所有 FF 共用 CLK
D₁ → [D FF] → Q₁
D₀ → [D FF] → Q₀
         ↑
        CLK
```

**功能**：在時脈邊緣同時存入 n-bit 資料。

### 帶載入控制的暫存器

加一個 Load 信號，決定是要存入新值還是保持舊值。

```
每個 bit 的輸入：
D_FF_input = Load · D_new + Load' · Q_current

（用 2-to-1 MUX 選擇：Load=1 存新值，Load=0 保持）
```

---

## 五、移位暫存器 (Shift Register)

### 基本概念

FF 串接，每個時脈邊緣，資料向右（或向左）移動一位。

### 4-bit 右移暫存器 (Right Shift Register)

```
Serial_In → [D FF₃] → [D FF₂] → [D FF₁] → [D FF₀] → Serial_Out
                ↑          ↑          ↑          ↑
               CLK        CLK        CLK        CLK
```

每個 CLK 邊緣：
- Q₃ = Serial_In
- Q₂ = Q₃ (舊值)
- Q₁ = Q₂ (舊值)
- Q₀ = Q₁ (舊值)

### 四種移位暫存器

| 類型 | 英文 | 輸入 | 輸出 | 特性 |
|------|------|------|------|------|
| SISO | Serial In, Serial Out | 串列 | 串列 | 資料延遲線 |
| SIPO | Serial In, Parallel Out | 串列 | 並列 | 串轉並 |
| PISO | Parallel In, Serial Out | 並列 | 串列 | 並轉串 |
| PIPO | Parallel In, Parallel Out | 並列 | 並列 | 通用暫存器 |

### 移位暫存器的應用

1. **串列↔並列轉換**：通訊介面（UART、SPI）
2. **乘以2 / 除以2**：左移 = ×2，右移 = ÷2
3. **資料延遲**：延遲 n 個時脈週期
4. **環形計數器 (Ring Counter)**：最後一位接回第一位
5. **強森計數器 (Johnson Counter)**：最後一位反相接回第一位

### 環形計數器 (Ring Counter)

```
初始值：1000

CLK1: 0100
CLK2: 0010
CLK3: 0001
CLK4: 1000  ← 回到初始

4-bit Ring Counter 有 4 個狀態（不是 16 個）
```

### 強森計數器 (Johnson Counter / Twisted Ring Counter)

```
Q₀' 接回 Serial_In

初始值：0000

CLK1: 1000
CLK2: 1100
CLK3: 1110
CLK4: 1111
CLK5: 0111
CLK6: 0011
CLK7: 0001
CLK8: 0000  ← 回到初始

4-bit Johnson Counter 有 2×4 = 8 個狀態
```

---

## 六、題型鑑別表

| 題目關鍵字 | 該用什麼方法 |
|-----------|-------------|
| 「Latch vs FF 差異」 | 位準觸發 vs 邊緣觸發 |
| 「畫特性表/方程」 | 列出所有輸入組合的 Q(t+1) |
| 「畫激勵表」 | 從 Q(t)→Q(t+1) 反推需要的輸入 |
| 「求最大時脈頻率」 | fmax = 1/(tcq + tcomb + tsu) |
| 「Metastability」 | 違反 setup/hold time → 中間態 |
| 「設計 n-bit 暫存器」 | n 個 D FF 並排，共用 CLK |
| 「移位暫存器設計」 | FF 串接，判斷是 SISO/SIPO/PISO/PIPO |
| 「Ring Counter 幾個狀態」 | n-bit → n 個狀態 |
| 「Johnson Counter 幾個狀態」 | n-bit → 2n 個狀態 |

---

## ✅ 自我檢測

### Q1：SR Latch 用 NOR 閘實現時，S=1, R=1 會怎樣？為什麼是「禁止」？

<details>
<summary>點擊查看答案</summary>

S=1, R=1 時，兩個 NOR 閘的輸出都被強制為 0（因為至少一個輸入為 1）。
所以 Q=0, Q'=0，違反了 Q 和 Q' 互補的要求。

更大的問題：如果 S 和 R 同時放開（回到 00），最終結果取決於閘的延遲差異，
是不可預測的。所以稱為「禁止狀態」。
</details>

### Q2：寫出 JK FF 的特性方程和激勵表。

<details>
<summary>點擊查看答案</summary>

**特性方程**：Q(t+1) = JQ'(t) + K'Q(t)

**激勵表**：

| Q(t) → Q(t+1) | J | K |
|----------------|---|---|
| 0 → 0 | 0 | X |
| 0 → 1 | 1 | X |
| 1 → 0 | X | 1 |
| 1 → 1 | X | 0 |

記憶技巧：
- 要保持 0 → J 不能 Set，J=0，K 無所謂
- 要從 0 變 1 → J 要 Set，J=1，K 無所謂
- 要從 1 變 0 → K 要 Reset，K=1，J 無所謂
- 要保持 1 → K 不能 Reset，K=0，J 無所謂
</details>

### Q3：某 D FF 的 tsu=2ns, th=1ns, tcq=3ns，組合邏輯延遲 tcomb=5ns。求最大時脈頻率。

<details>
<summary>點擊查看答案</summary>

```
T_min = tcq + tcomb + tsu
      = 3 + 5 + 2
      = 10 ns

fmax = 1 / T_min = 1 / 10ns = 100 MHz
```

注意：hold time 通常不影響最大頻率（它影響的是最小延遲約束）。
但如果 tcq_min < th，需要加入緩衝器確保不違反 hold time。
</details>

### Q4：D Latch 和 D FF 的最大差異是什麼？為什麼同步設計偏好 D FF？

<details>
<summary>點擊查看答案</summary>

**最大差異**：
- D Latch 是**位準觸發**：CLK=1 時透明，D 的改變直接穿透到 Q
- D FF 是**邊緣觸發**：只在 CLK 上升邊緣取樣一次

**為什麼偏好 D FF？**
1. 邊緣觸發可以明確定義取樣時間點，便於時序分析
2. 避免資料穿透(Transparency)問題
3. 同步設計方法學(Synchronous Design)都建立在邊緣觸發上
4. 現代 EDA 工具都針對 FF-based 設計最佳化
</details>

### Q5：一個 4-bit 強森計數器有幾個有效狀態？列出狀態序列。

<details>
<summary>點擊查看答案</summary>

有效狀態數 = 2 × 4 = **8 個**

狀態序列（Q₃Q₂Q₁Q₀）：
```
0000 → 1000 → 1100 → 1110 → 1111
→ 0111 → 0011 → 0001 → 0000（回到起始）
```

每次只有一個 bit 改變（格雷碼特性），非常適合避免冒險。
</details>

### Q6：什麼是亞穩態 (Metastability)？什麼情況下會發生？

<details>
<summary>點擊查看答案</summary>

**亞穩態**：Flip-Flop 的輸出停留在 0 和 1 之間的不穩定狀態。

**發生情況**：
當資料 D 在 Setup Time 或 Hold Time 的禁區視窗內改變時，
FF 無法判斷要鎖存 0 還是 1，就會進入亞穩態。

**後果**：
- 輸出電壓處於 VIL 和 VIH 之間
- 可能持續不確定的時間（通常很短，但不保證）
- 下游電路可能判讀出不同的值 → 系統行為不可預測

**最常見場景**：
跨時脈域(CDC)信號傳遞，因為兩個時脈沒有同步關係，
資料改變的時機可能恰好落在接收端 FF 的禁區內。
</details>

---

> **下一章預告**：有了正反器（記憶）和組合邏輯（運算），我們就能設計完整的循序電路了。下一章將學習同步循序電路的系統化設計流程——從狀態圖到電路圖！
