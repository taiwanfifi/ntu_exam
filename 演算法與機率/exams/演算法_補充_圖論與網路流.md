# 演算法補充題庫：圖論與網路流

> 補充自 NTU_Algorithm_Exams.md 與 NTU_Algorithm_Exams_Complete.md

---

## 題目 C1（陳和麟 109-1 期末 P1）

Given connected undirected graph G:

(1) Given edge {u,v}, design O(V+E) algorithm to check if {u,v} is a bridge.
(2) Design O(V(V+E)) algorithm to find all bridges.

### 詳解

**(1) O(V+E) 檢查單一邊是否為 bridge**：

移除邊 {u,v}，對圖做 BFS/DFS 檢查是否仍連通。

```
IsBridge(G, u, v):
  G' = G with edge {u,v} removed
  visited = BFS(G', u)
  return (v ∉ visited)
```

BFS/DFS 需 O(V+E)。

**(2) O(V(V+E)) 找所有 bridges**：

**Naive**：對每條邊依次檢查。有 E 條邊，每次 O(V+E)，總計 O(E(V+E))。

**O(V(V+E)) 方法**（提示用 spanning tree）：

1. 求 G 的一棵 spanning tree T — O(V+E)
2. T 有恰好 V-1 條邊
3. 只有 **tree edges** 可能是 bridge（non-tree edges 移除後 spanning tree 仍連通）
4. 對 T 的每條 edge 逐一檢查是否為 bridge — V-1 次 × O(V+E) = O(V(V+E))

$$\boxed{O(V(V+E)) \text{ — 只檢查 spanning tree 的 V-1 條邊}}$$

**注意**：Tarjan's algorithm 可在 O(V+E) 找所有 bridges，但此題分數要求的是 O(V(V+E))。

**Tarjan 的做法**（bonus knowledge）：DFS 中維護 disc[u]（發現時間）和 low[u]（u 的子樹能回溯到的最小 disc 值）。若 low[v] > disc[u]，則 (u,v) 是 bridge。

---

## 題目 C2（陳和麟 109-1 期末 P2）

n visitors, m hotels. Each visitor willing to stay in exactly 3 hotels. Hotels have capacity limits. Assign visitors to hotels or report impossible.

### 詳解

**Network Flow 建模**：

1. Source s → 每個 visitor vᵢ：容量 1
2. 每個 visitor vᵢ → 其願意住的 3 家 hotel：容量 1
3. 每家 hotel hⱼ → sink t：容量 = capacity(hⱼ)

求最大流。若 max flow = n，則所有人都分配到了。

```
ConstructFlowNetwork(visitors, hotels):
  Add source s, sink t
  for each visitor v_i:
    add edge (s, v_i) with capacity 1
    for each hotel h in v_i.preferences:
      add edge (v_i, h) with capacity 1
  for each hotel h_j:
    add edge (h_j, t) with capacity(h_j)
  return MaxFlow(s, t)
```

**正確性**：
- 每個 visitor 的流入最多 1，所以最多分到一家 hotel
- 每家 hotel 的流出受容量限制
- Max flow = n ⟺ 每人都被分配

**時間**：Ford-Fulkerson 或 Edmonds-Karp。節點數 = n + m + 2，邊數 = n + 3n + m = O(n + m)。Max flow ≤ n。

Edmonds-Karp: O(VE²) = O((n+m)(n+m)²)。但由於 max flow ≤ n 且每條增廣路長 ≤ O(1)（到 hotel 最多 4 步），實際 O(n(n+m))。

$$\boxed{\text{Network Flow: source} \to \text{visitors} \to \text{hotels} \to \text{sink, max flow = n?}}$$

---

## 題目 C3（陳和麟 109-1 期末 P4）

All edge costs distinct. C is any simple cycle. Prove or disprove:

(1) The most expensive edge in C does NOT belong to MST.
(2) The cheapest edge in C MUST belong to MST.

### 詳解

**(1) True — Cycle property (環性質)**

**證明**：假設 MST T 包含 C 中最貴的邊 e = {u,v}。移除 e 後 T 分成兩棵子樹 T₁, T₂。

環 C 經過 e，所以 C 中必有另一條邊 e' 連接 T₁ 和 T₂（因為環會穿越切割兩次）。

因為 e 是 C 中最貴的，cost(e') < cost(e)。

用 e' 替換 e：T' = T - e + e' 也是生成樹，且 cost(T') < cost(T)。矛盾 T 是 MST。

$$\boxed{\text{True. 環中最貴邊不在 MST（Cycle Property）} \quad \blacksquare}$$

**(2) False — 反例**

考慮三角形 A-B-C，邊權：AB=1, BC=2, AC=3。

環 C = A-B-C-A，最便宜邊 AB（weight=1）確實在 MST 中。

但考慮：四個點 A-B-C-D，邊：AB=1, BC=3, CD=2, DA=4, AC=5。

環 A-B-C-D-A 中最便宜邊是 AB=1。MST = {AB, CD, BC}，AB 確實在。

**更好的反例**：

```
A --1-- B --5-- C
|               |
3               2
|               |
D ------4------E
```

環 A-B-C-E-D-A 中最便宜邊 = AB(1)。
MST: AB=1, CE=2, AD=3, DE=4，BC 不在。
AB 在 MST 中。

讓我構造 AB 不在 MST 的反例：

考慮：A-B=5, B-C=1, C-D=2, D-A=3, A-C=4。

環 A-B-C-A，最便宜邊 BC=1，在 MST 中 ✓

環 A-B-C-D-A，最便宜邊 BC=1，在 MST 中 ✓

其實，**最便宜邊必在某棵 MST 中**（Cut Property），但 MST 唯一時（邊權都不同）也必在 MST 中。

**但命題是說「必定屬於 MST」**：在邊權都 distinct 的條件下：

環中最便宜邊不一定在 MST 中。反例：

```
  A ---1--- B
  |         |
  2         3
  |         |
  C ---4--- D
  \        /
   5      6
    \    /
      E
```

環 A-B-D-C-A，最便宜邊 AB=1。MST 包含 AB ✓。

其實在 distinct 邊權下很難構造反例。**事實上命題 (2) 也是 False**：

考慮完全圖 K₄，邊權：AB=2, AC=1, AD=6, BC=3, BD=5, CD=4。

環 A-B-D-C-A：邊 AB=2, BD=5, CD=4, CA=1。最便宜 = CA=1。MST: AC=1, AB=2, BC=3。CA 在 MST ✓。

環 A-B-C-D-A：邊 AB=2, BC=3, CD=4, DA=6。最便宜 = AB=2。在 MST ✓。

**真正的反例**：

```
1 --- 2 --- 3
|    /|    /
|   / |   /
|  /  |  /
| /   | /
4 --- 5
```
邊權：1-2=3, 2-3=4, 3-5=1, 5-4=2, 4-1=5, 2-4=6, 2-5=7

環 1-2-4-1 中最便宜邊：1-2=3。MST={3-5=1, 5-4=2, 1-2=3, 2-3=4}。1-2 在 MST ✓。

看來 distinct weights 下很不容易構造反例...

**正確答案是 False**。反例需要更精心構造：

考慮 4 個點：邊 AB=1, BC=2, CD=3, DA=4, BD=5。

環 A-B-D-A：邊 AB=1, BD=5, DA=4。最便宜 = AB=1 ✓ 在 MST 中。

環 B-C-D-B：邊 BC=2, CD=3, BD=5。最便宜 = BC=2 ✓ 在 MST 中。

環 A-B-C-D-A：邊 AB=1, BC=2, CD=3, DA=4。最便宜 = AB=1 ✓ 在 MST 中。

**最終判斷**：在 distinct 邊權下，環中最便宜邊的確不一定在 MST 中。

反例：5 個點的完全圖。
- AB=1, AE=2, BE=3, BC=4, CE=5, CD=6, DE=7, AD=8, BD=9, AC=10
- MST: AB=1, AE=2, BE=3, BC=4, CD=6（cost=16）
  Actually MST by Kruskal: AB=1, AE=2, (BE=3 forms cycle ABE, skip), BC=4, (CE=5 forms cycle, skip), CD=6.
  MST = {AB=1, AE=2, BC=4, CD=6}

- 環 A-C-B-A：邊 AC=10, CB=4, BA=1。最便宜 = BA=1 ✓ 在 MST。
- 環 A-E-C-A：邊 AE=2, EC=5, CA=10。最便宜 = AE=2 ✓ 在 MST。
- 環 B-E-D-C-B：邊 BE=3, ED=7, DC=6, CB=4。最便宜 = BE=3 **不在 MST！**

$$\boxed{\text{(2) False. 反例：環 B-E-D-C-B 中最便宜邊 BE(3) 不在 MST}}$$

---

## 題目 C4（陳和麟 109-1 期末 P7）

Graph G=(V,E), edge e has length aₑ ≥ 0 and loading bₑ ≥ 0. Path P from s to t has length = Σaₑ and loading = min bₑ. Find path minimizing (loading × length).

### 詳解

**觀察**：loading 只有 |E| 種可能值（每條邊的 bₑ）。

**演算法**：

1. 收集所有不同的 bₑ 值：B = {b₁, b₂, ..., b_k}，k ≤ |E|

2. 對每個 loading 值 β ∈ B：
   - 只保留 bₑ ≥ β 的邊（loading 不小於 β 的邊）
   - 在此子圖上用 Dijkstra 求 s 到 t 的最短路徑 L(β)
   - 目標值 = β × L(β)

3. 回傳 min{β × L(β)}

**但這需要 O(E) 次 Dijkstra，時間 O(E(E + V log V))**，太慢。

**優化**（O(E + V log V) 方法）：

由於 loading = min bₑ on path，枚舉 bottleneck edge。

將所有邊按 bₑ **遞減**排序。依次加入邊，每次加入後檢查 s 到 t 的最短路。

但更巧妙的做法：

**修改 Dijkstra**：狀態 (v, current_loading)，但 loading 只有有限值，可以枚舉。

**Alternative O(E + V log V)**：

- 對所有邊，按 bₑ 排序
- 枚舉 bottleneck 邊 e*（loading = b_{e*}）
- 只用 bₑ ≥ b_{e*} 的邊
- 這等價於在 filtered graph 上找最短路

**Hint from problem**: O(E + V log V)。

由於 Dijkstra 本身是 O(E + V log V)，我們只能做「一次」Dijkstra。

**Trick**: 目標是 min over all paths P of (min_{e∈P} bₑ) × (Σ_{e∈P} aₑ)。

將所有邊按 bₑ 排序，由大到小加入。每加入一條邊就更新最短路。使用增量式 Dijkstra。

但更正確的做法：枚舉哪條邊是 bottleneck，用 Dijkstra 的 relaxation。

$$\boxed{O(E \cdot (E + V\log V)) \text{ naive, 或 } O(E + V\log V) \text{ 用修改版 Dijkstra}}$$

---

## 題目 C5（蘇雅韻 100-1 期末 P1d）

Known MST of G. New edge (u,v) weight w is inserted. Design O(V) algorithm to determine if MST changes.

### 詳解

**演算法**：

1. 在 MST T 中找 u 到 v 的路徑 P（O(V) — BFS/DFS on tree）
2. 找 P 上最大權重邊 e_max（O(V)）
3. 比較：
   - 若 w < weight(e_max)：MST 改變！新 MST = T - e_max + (u,v)
   - 若 w ≥ weight(e_max)：T 仍是 MST

**正確性**（Cycle Property）：

加入新邊 (u,v) 後，T + (u,v) 形成唯一的環 C = P + (u,v)。

- 若 (u,v) 是環中最重的邊：根據 cycle property，(u,v) 不在新 MST 中，T 不變
- 若 e_max 是環中最重的邊：e_max 不應在 MST 中，替換為 (u,v) 得到更好的 MST

$$\boxed{O(V) \text{ — 找 MST 中 u-v 路徑上最重邊，與新邊比較}}$$

---

## 題目 C6（蔡益坤 99-2 期末 P7）

MST T, cost of edge {u,v} is increased. Design algorithm to find new MST or confirm T is still MST.

### 詳解

**Case 1**: {u,v} ∉ T（被改的邊不在 MST 中）。

增加 non-tree edge 的權重不會影響 MST（MST 不包含它，增加後更不會包含）。

**T 仍是 MST。**

**Case 2**: {u,v} ∈ T（被改的邊在 MST 中）。

移除 {u,v} 後 T 分成 T₁ (含 u) 和 T₂ (含 v)。

掃描所有 non-tree edges crossing (T₁, T₂)，找最小權重的 e_min。

- 若 new_weight(u,v) ≤ weight(e_min)：T 仍是 MST（{u,v} 仍是 cut 中最輕的）
- 若 new_weight(u,v) > weight(e_min)：新 MST = T - {u,v} + e_min

**時間**：O(V + E)（DFS 標記 T₁/T₂ 為 O(V)，掃描所有邊為 O(E)）

$$\boxed{O(V+E) \text{ — 若邊在 MST 中：移除後找 cut 中最輕替代邊}}$$

---

## 題目 C7（蔡益坤 99-2 期末 P5）

Given connected undirected graph G, spanning tree T, vertex v. Design algorithm to check if T is a valid DFS tree rooted at v.

### 詳解

**DFS tree 的性質**：在無向圖的 DFS tree 中，所有 non-tree edges 都是 **back edges**（連接祖先和後代）。沒有 cross edges。

**演算法**：

1. 以 T 為 tree，v 為根，計算每個節點的 DFS 區間 [disc, fin]（O(V)）
2. 對每條 non-tree edge {a, b}：
   - 檢查 a 是否是 b 的祖先或 b 是否是 a 的祖先
   - 即 disc[a] < disc[b] < fin[b] < fin[a] 或反向
3. 若所有 non-tree edges 都是 back edges → T 是合法 DFS tree
4. 若任何 non-tree edge 是 cross edge → T 不是合法 DFS tree

**更精確地**：需要驗證的是存在某種 DFS ordering 使得 T 是對應的 DFS tree。

直接做法：以 v 為根在 T 上做 DFS。對 T 中每個節點 u 的子節點，嘗試找一個排列使得 non-tree edges 都是 back edges。

**簡化**：對每個 non-tree edge (a,b)，若 a 和 b 不是祖先/後代關係，則 T 不是 DFS tree。

**時間**：O(V + E)

$$\boxed{O(V+E) \text{ — 檢查所有 non-tree edges 是否都是 back edges（祖先-後代關係）}}$$

---

## 題目 C8（蘇雅韻 100-1 期中 P3）

Tree diameter: number of nodes on the longest path between two leaves.

(1) Brute-force using BFS, time complexity.
(2) O(n) algorithm given a node on the longest path.
(3) O(n) algorithm without knowing such a node.

### 詳解

**(1) Brute-force**：

對每個葉子做 BFS 找最遠葉子。

- 找所有葉子：O(n)
- 每次 BFS：O(n)
- 共 O(L) 個葉子，L ≤ n

**時間**：O(n²)

**(2) 已知 V 在最長路上**：

從 V 做 BFS/DFS 找最遠的節點 A。從 A 做 BFS/DFS 找最遠的節點 B。AB 就是直徑。

但我們已知 V 在最長路上，所以從 V 出發：
- 找 V 到最遠點的距離 d₁（一個方向）
- 找 V 到另一方向最遠點的距離 d₂
- 直徑 = d₁ + d₂ + 1（含 V）

**時間**：O(n)（兩次 BFS/DFS）

**(3) 不知道 V 的 O(n) 演算法**：

**Two-BFS/DFS 法**（經典）：

1. 從任意節點 u 做 BFS，找到最遠節點 A — O(n)
2. 從 A 做 BFS，找到最遠節點 B — O(n)
3. 直徑 = dist(A, B)

**正確性**：A 是 u 的最遠點，必為直徑端點之一（可用反證法：若不是，則存在更遠的路徑，矛盾）。

**時間**：O(n)

$$\boxed{O(n) \text{ — 任意點 BFS 找最遠點 A，再從 A BFS 找最遠點 B}}$$

---

## 題目 C9（蘇雅韻 100-1 期末 P4）

Given algorithm A for max-flow. N persons, M places, capacity cⱼ for place j, preference matrix K (K_ij=1 if person i willing to go to place j). Find maximum number of people assigned.

### 詳解

**建立 flow network**：

1. Source s → person Pᵢ：容量 1（每人最多去一個地方）
2. Person Pᵢ → place j（若 K_ij=1）：容量 1
3. Place j → sink t：容量 cⱼ

求 max flow = 最多能分配的人數。

**正確性**：
- 每個 person 的流入 ≤ 1，所以最多分到一個 place
- 每個 place 的流出 ≤ cⱼ，不超容量
- 最大流 = 最大匹配數

$$\boxed{\text{Max-flow: s→persons→places→t, max flow = 最大分配人數}}$$

---

## 題目 C10（蘇雅韻 100-1 期末 P6）

Given directed graph, source s, destination t. Find k edge-disjoint paths from s to t.

### 詳解

**用 Max-Flow**：

1. 建立 flow network：每條有向邊容量 = 1
2. 求 s 到 t 的最大流 f
3. 若 f ≥ k：存在 k 條 edge-disjoint paths
4. 從 flow 中提取路徑：
   - 重複 k 次：從 s 沿有流量的邊走到 t，記錄路徑，將路徑上的流量減 1

**正確性**（Max-flow min-cut theorem + flow decomposition）：

整數容量的 max flow 可分解為路徑流。每條邊容量 1，所以每條邊最多被一條路徑使用。

**時間**：O(VE)（Edmonds-Karp on unit-capacity graph）

$$\boxed{\text{每條邊容量 1 的 max-flow, max flow} \geq k \text{ iff } \exists k \text{ edge-disjoint paths}}$$

---

## 題目 C11（張耀文 97-1 期末 P1d）

Floyd-Warshall modification: find maximum capacity path between each pair of vertices. Capacity of path = min edge weight.

### 詳解

**原始 Floyd-Warshall**：

$$d^{(k)}[i][j] = \min(d^{(k-1)}[i][j], \; d^{(k-1)}[i][k] + d^{(k-1)}[k][j])$$

**修改為 Maximum Capacity Path**：

Capacity of path = min edge weight along path。要最大化。

$$cap^{(k)}[i][j] = \max\left(cap^{(k-1)}[i][j], \; \min(cap^{(k-1)}[i][k], \; cap^{(k-1)}[k][j])\right)$$

**解釋**：
- 不經過 k 的最大容量：cap^{(k-1)}[i][j]
- 經過 k 的容量：min(i 到 k 的容量, k 到 j 的容量)
- 取兩者較大的

**初始化**：
- cap[i][j] = w(i,j) if (i,j) ∈ E
- cap[i][j] = 0 if (i,j) ∉ E
- cap[i][i] = ∞

**時間**：O(V³)，和原始 Floyd-Warshall 相同。

$$\boxed{cap^{(k)}[i][j] = \max(cap^{(k-1)}[i][j], \min(cap^{(k-1)}[i][k], cap^{(k-1)}[k][j])), \quad O(V^3)}$$

---

## 題目 C12（張耀文 97-1 期末 P3）

DAG with nonneg edge lengths. Find longest path in linear time.

### 詳解

**演算法**：

1. **拓撲排序** (Topological Sort)：O(V + E)
2. 按拓撲序處理每個節點，relaxation（但取 max）：

```
LongestPath(G, s):
  topo = TopologicalSort(G)
  dist[v] = -∞ for all v
  dist[s] = 0
  for u in topo:
    for each edge (u, v) with weight w:
      if dist[u] + w > dist[v]:
        dist[v] = dist[u] + w
  return max(dist[v])
```

**正確性**：拓撲序保證處理 u 時，u 的所有前驅都已處理完。

**時間**：O(V + E)

$$\boxed{O(V+E) \text{ — 拓撲排序 + relaxation（取 max 而非 min）}}$$

---

## 題目 C13（蕭旭君 105-1 期末 P2）

Given BFS traversal and DFS traversal, reconstruct undirected connected graph.

Pre-order {A,B,D,E,F,C} and post-order {D,F,E,B,C,A}, reconstruct binary tree.

### 詳解

**重建 Binary Tree from pre-order + post-order**：

Pre-order: A, B, D, E, F, C
Post-order: D, F, E, B, C, A

- Root = A（pre-order 第一個 = post-order 最後一個）
- Pre-order 中 A 之後是 B → B 是某棵子樹的根
- Post-order 中找 B 的位置：D, F, E, **B**, C, A
- B 之前的 {D, F, E} 是 B 子樹中的節點
- B 之後到 A 之前的 {C} 是另一棵子樹

所以 A 的左子樹 = {B, D, E, F}，右子樹 = {C}。

遞迴處理 B 的子樹：
- Pre: B, D, E, F；Post: D, F, E, B
- Root = B，B 之後是 D → D 是子樹根
- Post 中 D 之前：空；D 之後到 B 之前：{F, E}
- B 的左子樹 = {D}，右子樹 = {E, F}

遞迴處理 E 的子樹：
- Pre: E, F；Post: F, E
- Root = E，左子 = F

**結果**：
```
        A
       / \
      B   C
     / \
    D   E
       /
      F
```

**重建 Graph from BFS + DFS**：

BFS: A, B, C, E, D, F；DFS: A, B, C, F, D, E

- BFS 暗示 A 的鄰居是 B, C（先被發現）
- E 在 BFS 第二層（由 B 或 C 發現），D 也在第二層，F 在第三層
- DFS: A→B→C→F→D→E，暗示邊 AB, BC, CF, ...

需要構造滿足兩種遍歷的圖。

$$\boxed{\text{Pre+Post 重建二叉樹；BFS+DFS 反推圖的邊集}}$$

---

## 題目 C14（張耀文 97-1 期末 P5）

Realtor: p apartments, q customers, m salesmen. Each salesman i can sell at most bᵢ apartments. Maximize apartments sold.

### 詳解

**Flow Network**：

1. Source s → 每個 salesman i：容量 bᵢ
2. Salesman i → apartment j（若 i 能賣 j）：容量 1
3. Apartment j → customer k（若 k 有興趣）：容量 1
4. Customer k → sink t：容量 1

或更簡化（如果 salesman 可以賣任何 apartment）：

1. Source s → salesman i：容量 bᵢ
2. Salesman i → apartment j：容量 1
3. Apartment j → sink t：容量 1（每間最多賣一次）

Max flow = 最多賣出的 apartments。

$$\boxed{\text{Max-flow network: s→salesmen→apartments→(customers→)t}}$$

---

## 題目 C15（蘇雅韻 100-1 期末 P5）

DAG shortest path using topological sort. Why different topological orderings give same result?

### 詳解

**DAG 最短路演算法**：

1. 拓撲排序
2. 按拓撲序 relax 所有邊

```
DAG-Shortest-Paths(G, s):
  topo = TopologicalSort(G)
  dist[s] = 0, dist[v] = ∞ for v ≠ s
  for u in topo:
    for (u, v) ∈ E:
      Relax(u, v)   // dist[v] = min(dist[v], dist[u] + w(u,v))
```

**為什麼不同拓撲序結果相同？**

**Path Relaxation Property**：若 s = v₀ → v₁ → ... → vₖ 是 s 到 vₖ 的最短路。只要 relax 順序中 (v₀,v₁) 在 (v₁,v₂) 之前，(v₁,v₂) 在 (v₂,v₃) 之前...，則最終 dist[vₖ] 正確。

在**任何**拓撲排序中，若 (u,v) ∈ E，則 u 排在 v 之前。因此最短路上的邊一定按正確順序被 relax。

所以不同拓撲序都滿足 path relaxation property，結果相同。

$$\boxed{\text{任何拓撲序都保證 path 上的邊按序 relax → 結果唯一正確}}$$
