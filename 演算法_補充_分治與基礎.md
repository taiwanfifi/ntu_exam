# 演算法補充題庫：分治法與基礎分析

> 補充自 NTU_Algorithm_Exams.md 與 NTU_Algorithm_Exams_Complete.md

---

## 題目 A1（陳和麟 109-1 期中 P1）

Let all functions be positive functions. Prove or disprove:

1. log₂ n ∈ O(log₁₀ n)
2. If f(n) ∈ Ω(g(n)), then either f(n) ∈ ω(g(n)) or f(n) ∈ Θ(g(n)).
3. If f(n) ∈ Ω(h(n)) and g(n) ∈ o(h(n)), then f(n) - g(n) ∈ Ω(h(n)).

### 詳解

**(1) True**

log₂ n = log₁₀ n / log₁₀ 2 = (1/log₁₀ 2) · log₁₀ n

取 c = 1/log₁₀ 2 ≈ 3.32，對所有 n ≥ 1：

$$\log_2 n = c \cdot \log_{10} n \leq c \cdot \log_{10} n$$

所以 log₂ n ∈ O(log₁₀ n)。（事實上 log₂ n ∈ Θ(log₁₀ n)，不同底的對數只差常數倍。）

$$\boxed{\text{True. } \log_2 n = \frac{1}{\log_{10} 2} \cdot \log_{10} n = O(\log_{10} n)}$$

**(2) True**

設 f(n) ∈ Ω(g(n))，即 ∃ c > 0, n₀ 使得 f(n) ≥ c·g(n) 對 ∀n ≥ n₀。

考慮 lim inf 和 lim sup of f(n)/g(n)：

- 若 lim f(n)/g(n) = ∞，則 f(n) ∈ ω(g(n))
- 若 lim f(n)/g(n) 存在且為有限正常數，則 f(n) ∈ Θ(g(n))
- 若極限不存在但 lim sup 有限，則 f(n) ∈ O(g(n)) 且 f(n) ∈ Ω(g(n))，故 f(n) ∈ Θ(g(n))

**但這個命題其實是 False！**

反例：令 f(n) = n(1 + sin n), g(n) = n。

- f(n) ∈ Ω(g(n))？不一定，因為 sin n = -1 時 f(n) = 0。

更好的反例：令
$$f(n) = \begin{cases} 2n & \text{if } n \text{ is even} \\ n & \text{if } n \text{ is odd} \end{cases}$$

g(n) = n。那麼 f(n) ∈ Ω(n)（取 c=1），但：
- f(n) ∉ ω(n)（因為 f(n)/n = 1 當 n 為奇數，不趨向 ∞）
- f(n) ∉ Θ(n)？不對，f(n) ≤ 2n = O(n)，所以 f(n) ∈ Θ(n)。

**再想：**  f(n) ∈ Ω(g(n)) 意味著 f(n) ≥ c·g(n)。如果同時 f(n) ∉ ω(g(n))，則 lim inf f(n)/g(n) < ∞，即存在子序列使得 f(n)/g(n) 有界。但這意味著存在常數 C 使得 f(n) ≤ C·g(n) 嗎？不一定！

反例：
$$f(n) = \begin{cases} n^2 & \text{if } n = 2^k \\ n & \text{otherwise} \end{cases}$$

g(n) = n。

- f(n) ∈ Ω(n)：因為 f(n) ≥ n 對所有 n ✓
- f(n) ∉ ω(n)：因為在 n ≠ 2^k 時 f(n)/n = 1 不趨向 ∞ ✓
- f(n) ∉ Θ(n)：因為在 n = 2^k 時 f(n)/n = n → ∞，不存在常數 c 使 f(n) ≤ c·n ✓

$$\boxed{\text{False. 反例：} f(n) = n^2 \text{ when } n=2^k, \text{ else } n; \quad g(n) = n}$$

**(3) True**

已知 f(n) ∈ Ω(h(n))：∃ c₁ > 0, n₁ 使得 f(n) ≥ c₁·h(n) 對 ∀n ≥ n₁。

已知 g(n) ∈ o(h(n))：對任意 ε > 0，∃ n₂ 使得 g(n) < ε·h(n) 對 ∀n ≥ n₂。

取 ε = c₁/2，則 ∃ n₂ 使得 g(n) < (c₁/2)·h(n) 對 ∀n ≥ n₂。

對所有 n ≥ max(n₁, n₂)：

$$f(n) - g(n) \geq c_1 \cdot h(n) - \frac{c_1}{2} \cdot h(n) = \frac{c_1}{2} \cdot h(n)$$

取 c = c₁/2 > 0，得 f(n) - g(n) ≥ c·h(n)。

$$\boxed{\text{True. } f(n) - g(n) \geq \frac{c_1}{2} h(n) = \Omega(h(n)) \quad \blacksquare}$$

---

## 題目 A2（陳和麟 109-1 期中 P2）

1. Solve T(n) = 4T(n/2) + n²ln n, T(1) = 1.
2. Let T(n) = 4T(⌊n/2⌋ + 1) + n, for all n ≥ 8. T(5)=T(6)=T(7)=1. Prove T(n) ∈ O(n²).

### 詳解

**(1)** Master Theorem: a=4, b=2, f(n)=n²ln n

$n^{\log_b a} = n^{\log_2 4} = n^2$

f(n) = n²ln n 與 n² 比較：f(n)/n² = ln n → ∞，但增長不到多項式。

這是 Master Theorem **Case 2 的擴展**（CLRS 中的 case 2 extended / Akra-Bazzi）：

$$f(n) = \Theta(n^2 \log^1 n)$$

即 f(n) = Θ(n^{log_b a} · log^k n)，k=1。

$$\boxed{T(n) = \Theta(n^2 \log^2 n) = \Theta(n^2 \ln^2 n)}$$

**(2)** 用代入法（substitution method）證明 T(n) ∈ O(n²)。

**猜測**：T(n) ≤ c·n² - d·n（需要減去低階項來使歸納成功）。

**歸納步驟**：假設對所有 m < n，T(m) ≤ c·m² - d·m。

$$T(n) = 4T(\lfloor n/2 \rfloor + 1) + n$$

令 m = ⌊n/2⌋ + 1 ≤ n/2 + 1。

$$T(n) \leq 4[c(n/2+1)^2 - d(n/2+1)] + n$$
$$= 4c \cdot \frac{(n+2)^2}{4} - 4d \cdot \frac{n+2}{2} + n$$
$$= c(n+2)^2 - 2d(n+2) + n$$
$$= c(n^2 + 4n + 4) - 2dn - 4d + n$$
$$= cn^2 + (4c - 2d + 1)n + 4c - 4d$$

我們需要 T(n) ≤ cn² - dn，即：

$$cn^2 + (4c - 2d + 1)n + 4c - 4d \leq cn^2 - dn$$
$$(4c - 2d + 1)n + 4c - 4d \leq -dn$$
$$(4c - d + 1)n + 4c - 4d \leq 0$$

取 d = 4c + 2，則 4c - d + 1 = 4c - 4c - 2 + 1 = -1 < 0。

殘餘項：$-n + 4c - 4(4c+2) = -n + 4c - 16c - 8 = -n - 12c - 8 < 0$ ✓

**基底**：取 c 足夠大使得 T(5), T(6), T(7) ≤ c·n² - d·n。

$$\boxed{T(n) \in O(n^2) \quad \blacksquare}$$

---

## 題目 A3（陳和麟 109-1 期中 P3）

Given n distinct real numbers a₁, a₂, ..., aₙ (not sorted), a₁ = 0 and a₂ = n. Find a pair (aᵢ, aⱼ) such that |aᵢ - aⱼ| > 1 but there is no other aₖ with value in between. Design an O(n)-time algorithm.

### 詳解

**鴿巢原理分析**：n 個數分布在 [0, n] 中，分成 n-1 個區間 [0,1], [1,2], ..., [n-2, n-1] 加上 [n-1, n]。共 n 個區間，n 個數。但因為 a₁=0 在 [0,1] 中，a₂=n 在 [n-1,n] 中，中間有些區間可能是空的。

**演算法**（Bucket Sort 概念）：

1. 建立 n 個 bucket：Bucket[i] 對應區間 [i, i+1)，i = 0, 1, ..., n-1
2. 將每個 aⱼ 放入 Bucket[⌊aⱼ⌋] 中
3. 對每個 bucket 只記錄**最小值**和**最大值**
4. 掃描所有 bucket：對每對**相鄰非空 bucket**，比較前一個 bucket 的最大值和後一個 bucket 的最小值

**正確性**：
- 每個 bucket 的寬度為 1，所以同一 bucket 內的元素差距 < 1
- 答案一定跨越至少一個空 bucket（否則所有相鄰元素差 ≤ 1）
- 跨越空 bucket 的最小 gap 就是相鄰非空 bucket 的 max 與 min 的差

**複雜度**：建 bucket O(n)，掃描 bucket O(n)。

$$\boxed{O(n) \text{ — 用 bucket 分組後掃描相鄰非空 bucket 的 max/min 差}}$$

---

## 題目 A4（陳和麟 109-1 期中 P4）

Given k sorted arrays of n/k elements each. Prove that any comparison-based algorithm to merge all k arrays into one sorted array requires Ω(n log k) comparisons.

### 詳解

**Information-theoretic lower bound**：

n 個元素來自 k 個已排序陣列，各有 n/k 個元素。合併結果是一個長度 n 的排列。

總共可能的合併結果數 = 多項式係數（multinomial coefficient）：

$$\binom{n}{n/k, n/k, \ldots, n/k} = \frac{n!}{((n/k)!)^k}$$

任何比較排序的決策樹高度 ≥ log₂(葉子數)：

$$h \geq \log_2 \frac{n!}{((n/k)!)^k}$$

利用 Stirling 近似 log₂(m!) ≈ m log₂ m - m log₂ e：

$$h \geq n \log_2 n - n \log_2 e - k \left(\frac{n}{k} \log_2 \frac{n}{k} - \frac{n}{k} \log_2 e\right)$$

$$= n \log_2 n - n \log_2 e - n \log_2 \frac{n}{k} + n \log_2 e$$

$$= n \log_2 n - n(\log_2 n - \log_2 k) = n \log_2 k$$

$$\boxed{\Omega(n \log k) \quad \blacksquare}$$

---

## 題目 A5（蔡欣穆 100-1 期中 P6）

Given sorted array A[1..n] that has been circularly shifted k positions. Design an O(log n) algorithm to find the largest element.

Example: [35, 42, 5, 15, 27, 29] is shifted k=2, largest is 42.

### 詳解

**觀察**：陣列原本是遞增的，循環位移後有一個「斷點」，斷點左邊是最大值。

**Binary Search 演算法**：

```
FindMax(A, lo, hi):
  if lo == hi: return A[lo]
  if A[lo] < A[hi]: return A[hi]    // 沒有斷點，最大在最右
  mid = (lo + hi) / 2
  if A[mid] > A[mid+1]:             // mid 就是斷點
    return A[mid]
  if A[lo] <= A[mid]:               // 斷點在右半
    return FindMax(A, mid+1, hi)
  else:                             // 斷點在左半
    return FindMax(A, lo, mid)
```

**正確性**：
- 若 A[lo] < A[hi]：這段是純遞增的，最大值在 A[hi]
- 若 A[mid] > A[mid+1]：找到斷點，A[mid] 是最大值
- 若 A[lo] ≤ A[mid]：左半段連續遞增（沒斷），斷點必在右半
- 否則：斷點在左半

**時間複雜度**：每次縮小一半，T(n) = T(n/2) + O(1) = **O(log n)**

$$\boxed{O(\log n) \text{ — 修改版 Binary Search 找循環陣列斷點}}$$

---

## 題目 A6（蔡欣穆 101-1 期中 P6）

Array A[1..n] of n elements. A majority element occurs in more than n/2 positions. Elements cannot be ordered, only compared for equality. Design an efficient divide-and-conquer algorithm.

### 詳解

**分治策略**（Boyer-Moore Voting 的 D&C 版本）：

```
Majority(A, lo, hi):
  if lo == hi: return A[lo]
  mid = (lo + hi) / 2
  left_maj  = Majority(A, lo, mid)
  right_maj = Majority(A, mid+1, hi)
  if left_maj == right_maj: return left_maj
  // count occurrences of each candidate
  left_count  = Count(A, lo, hi, left_maj)
  right_count = Count(A, lo, hi, right_maj)
  if left_count > (hi - lo + 1) / 2: return left_maj
  if right_count > (hi - lo + 1) / 2: return right_maj
  return NULL  // no majority
```

**正確性**：
- 如果整體有 majority element x（出現 > n/2 次），那麼 x 必定是左半或右半的 majority
  - 反證：若 x 不是左半也不是右半的 majority，則 x 在左半出現 ≤ n/4 次，在右半出現 ≤ n/4 次，總共 ≤ n/2 次，矛盾

**時間複雜度**：

$$T(n) = 2T(n/2) + O(n)$$

（Count 需要 O(n) 時間掃描）

$$\boxed{T(n) = O(n \log n)}$$

---

## 題目 A7（蘇雅韻 100-1 期中 P1）

Solve T(n) = T(n/2) + T(n/4) + n.

(a) Draw recursion tree to derive guess.
(b) Prove using substitution method.

### 詳解

**(a) 遞迴樹**：

Level 0: n
Level 1: n/2 + n/4 = 3n/4
Level 2: n/4 + n/8 + n/8 + n/16 = 9n/16 = (3/4)²n
Level k: (3/4)^k · n

總和 = n · Σᵢ₌₀^∞ (3/4)^i = n · 1/(1-3/4) = **4n**

猜測：T(n) = **Θ(n)**

**(b) 代入法證明 O(n)**：

猜測 T(n) ≤ cn（需要 T(n) ≤ cn - d 的形式更容易，但試 cn）

$$T(n) = T(n/2) + T(n/4) + n \leq c \cdot n/2 + c \cdot n/4 + n = \frac{3c}{4}n + n$$

需要 3cn/4 + n ≤ cn，即 n ≤ cn/4，即 c ≥ 4。

取 c = 4：T(n) ≤ 4n。✓

**證明 Ω(n)**：顯然 T(n) ≥ n（因為 T(n) = T(n/2) + T(n/4) + n ≥ n）。

$$\boxed{T(n) = \Theta(n)}$$

---

## 題目 A8（蔡欣穆 102-1 期中 P6）

Solve T(n) = √n · T(√n) + n. Give Θ-notation.

### 詳解

**變數替換**：令 n = 2^m，則 √n = 2^{m/2}。

令 S(m) = T(2^m)，則：

$$S(m) = 2^{m/2} \cdot S(m/2) + 2^m$$

兩邊除以 2^m：

$$\frac{S(m)}{2^m} = \frac{S(m/2)}{2^{m/2}} + 1$$

令 R(m) = S(m)/2^m，則：

$$R(m) = R(m/2) + 1$$

解為 R(m) = Θ(log m)，所以 S(m) = Θ(2^m · log m)。

回代 m = log n：

$$T(n) = \Theta(n \log \log n)$$

$$\boxed{T(n) = \Theta(n \log \log n)}$$

---

## 題目 A9（張耀文 97-1 期中 P3）

Array A₀ of length n, sorted in ascending order. k entries are overwritten, producing array A. Given boolean array B where B[i] = true if A[i] was overwritten.

(a) Give a fast algorithm to sort A.
(b) Time complexity.

### 詳解

**演算法**：

1. 用 B 將 A 分成兩組：
   - 未修改組 U（B[i] = false）：n-k 個元素，**已排序**
   - 已修改組 M（B[i] = true）：k 個元素，**未排序**
   （分離：O(n)）

2. 排序已修改組 M：O(k log k)

3. **合併** U 和 M（兩個已排序陣列）：O(n)

**總複雜度**：O(n + k log k)

- 比 O(nk)（如每次插入一個修改元素到已排序陣列）好得多
- 比 O(n log n)（完全重排）也好（當 k 小時）

$$\boxed{O(n + k \log k)}$$

---

## 題目 A10（蕭旭君 103-1 期中 P5）

Counting inversions: Design an O(n log n) algorithm. An inversion is a pair (bᵢ, bⱼ) where i < j and bᵢ > bⱼ.

**Bonus**: A significant inversion is (bᵢ, bⱼ) where i < j and bᵢ > 2bⱼ. Count these in O(n log n).

### 詳解

**Merge Sort 變形**：

```
CountInversions(A, lo, hi):
  if lo >= hi: return 0
  mid = (lo + hi) / 2
  count = CountInversions(A, lo, mid) + CountInversions(A, mid+1, hi)
  count += MergeCount(A, lo, mid, hi)
  return count

MergeCount(A, lo, mid, hi):
  // Standard merge, but count inversions:
  // When we pick from right array (A[j]), all remaining elements
  // in left array (A[i..mid]) form inversions with A[j]
  inversions = 0
  i = lo, j = mid+1, k = 0
  while i <= mid and j <= hi:
    if A[i] <= A[j]:
      temp[k++] = A[i++]
    else:
      inversions += (mid - i + 1)  // all A[i..mid] > A[j]
      temp[k++] = A[j++]
  // copy remaining...
  return inversions
```

**正確性**：在 merge 時，若選了右邊的 A[j]，代表左邊剩下的 A[i..mid] 都 > A[j]，這些都是跨越兩半的 inversions。

**T(n) = 2T(n/2) + O(n) = O(n log n)**

**Bonus: Significant inversions (bᵢ > 2bⱼ)**

在 merge 之前，**先單獨計算 significant inversions**：

用兩個指標 i, j 分別掃描左右兩半（都已排序）。對每個 j，找最小的 i 使得 A[i] > 2·A[j]，則 mid-i+1 個元素都是 significant inversions。因為左半已排序，i 只會往右移，所以總共 O(n)。

然後再正常 merge。

$$\boxed{O(n \log n) \text{ — Merge Sort 在合併時統計逆序對}}$$

---

## 題目 A11（蕭旭君 103-1 期中 P6）

n points in 2D, distance d(i,j) = min{|xᵢ-xⱼ|, |yᵢ-yⱼ|}. Given sorted arrays Xₙ and Yₙ, design O(n) greedy algorithm to find closest pair.

### 詳解

**觀察**：d(i,j) = min{|xᵢ-xⱼ|, |yᵢ-yⱼ|}。

如果兩個點的 x 座標很近 或 y 座標很近，距離就很小。

**1D 情況**：在一維中找最近對，只需掃描排序陣列中相鄰元素的差。

**2D 情況**：

- 在 Xₙ（按 x 排序）中，掃描相鄰元素的 x 差：δ_x = min{x_{i+1} - x_i}
- 在 Yₙ（按 y 排序）中，掃描相鄰元素的 y 差：δ_y = min{y_{i+1} - y_i}

因為 d(i,j) = min{|xᵢ-xⱼ|, |yᵢ-yⱼ|}：

- 如果某兩點 x 座標差最小（相鄰於 Xₙ），它們的距離 ≤ δ_x
- 如果某兩點 y 座標差最小（相鄰於 Yₙ），它們的距離 ≤ δ_y

最近對距離 = min(δ_x, δ_y)。

**演算法**：
1. 掃描 Xₙ 找 x 座標最近的一對及其距離 δ_x — O(n)
2. 掃描 Yₙ 找 y 座標最近的一對及其距離 δ_y — O(n)
3. 回傳距離較小的那對

$$\boxed{O(n) \text{ — 分別掃描 X 和 Y 排序陣列的相鄰差}}$$

**正確性**：令最近對為 (p, q)。d(p,q) = min{|xp-xq|, |yp-yq|}。

若 d(p,q) = |xp-xq|，則 |xp-xq| ≤ |yp-yq|，且 |xp-xq| 是所有 x 相鄰差中最小的之一（因為 Xₙ 已排序，最小 x 差一定出現在排序後相鄰的點之間）。同理若 d(p,q) = |yp-yq|。

---

## 題目 A12（張耀文 98-1 期中 P3）

X[1..n] and Y[1..n] are two sorted arrays. Find the median of all 2n elements.

### 詳解

**O(log n) 演算法**（同蕭旭君 103-1 P2）：

```
FindMedian(X, Y, n):
  if n == 1: return min(X[1], Y[1])
  m = ⌊n/2⌋
  if X[m] == Y[m]: return X[m]
  if X[m] < Y[m]:
    return FindMedian(X[m..n], Y[1..n-m+1], n-m+1)
  else:
    return FindMedian(X[1..n-m+1], Y[m..n], n-m+1)
```

**思路**：
- 若 X[m] < Y[m]，則中位數不可能在 X[1..m-1] 或 Y[m+1..n] 中
  - X[1..m-1] 中的元素至多大於 m-1 個 X 元素和 m-1 個 Y 元素（共 < n 個），太小
  - Y[m+1..n] 中的元素至少大於 m 個 Y 元素和 m 個 X 元素（共 > n 個），太大
- 每次刪掉一半的元素

**T(n) = T(n/2) + O(1) = O(log n)**

$$\boxed{O(\log n) \text{ — Binary Search: 比較兩陣列中位數並刪半}}$$
