# 二維 DP 與背包問題 完全教學手冊

> **適用對象**：基礎較弱、準備 Google 面試的工程師
> **教學風格**：大學教科書等級，每個觀念都有 2+ 組完整數值追蹤，每張 DP 表格逐格解釋
> **語言**：繁體中文解說 + English technical terms
> **配套程式**：`12_DP_2D_Knapsack.py`（可直接執行驗證所有範例）

---

## 第一章：二維 DP 概念

### 1.1 什麼時候需要二維 DP？

一維 DP 的狀態只靠一個參數就能描述（例如 `dp[i]` = 前 i 個元素的最佳解）。
但很多問題的狀態取決於**兩個維度**，一個參數不夠用：

```
情境 1: 網格問題
  狀態 = (目前在第幾列, 目前在第幾行)  →  dp[i][j]

情境 2: 兩個字串比對
  狀態 = (字串1考慮到第幾個字元, 字串2考慮到第幾個字元)  →  dp[i][j]

情境 3: 背包問題
  狀態 = (考慮到第幾個物品, 目前背包剩餘容量)  →  dp[i][w]

情境 4: 區間問題
  狀態 = (區間左端點, 區間右端點)  →  dp[i][j]
```

**判斷標準**：如果你定義 `dp[i]` 時發現，光靠 `i` 這一個維度無法完整描述「現在在哪個子問題」，就需要加第二個維度。

### 1.2 dp[i][j] 的含義

`dp[i][j]` 的具體意思**因題目而異**，沒有統一定義：

| 問題類型 | dp[i][j] 代表的意思 |
|---------|-------------------|
| Unique Paths | 從 (0,0) 走到 (i,j) 的路徑數 |
| Min Path Sum | 從 (0,0) 走到 (i,j) 的最小路徑和 |
| LCS | text1 前 i 個字元 vs text2 前 j 個字元的 LCS 長度 |
| Edit Distance | word1 前 i 個字元轉換成 word2 前 j 個字元的最少操作 |
| 0/1 Knapsack | 考慮前 i 個物品、容量為 j 時的最大價值 |

### 1.3 怎麼填表？

通常是 **row by row, left to right**（由上到下、由左到右）。因為 `dp[i][j]` 依賴的是：
- 上一列 `dp[i-1][...]`（上方的 cell）
- 同列但更左邊 `dp[i][j-1]`（左邊的 cell）

只要我們從上到下、從左到右填，所有依賴的 cell 都已經算好了。

```
填表順序示意：

  dp[0][0] → dp[0][1] → dp[0][2] → ...    (第一列從左到右)
  dp[1][0] → dp[1][1] → dp[1][2] → ...    (第二列從左到右)
  dp[2][0] → dp[2][1] → dp[2][2] → ...    (第三列從左到右)
  ...

  例外：區間 DP 是按「區間長度」從小到大填，第六章會講。
```

---

## 第二章：網格型 2D DP

### 2.1 Unique Paths -- LeetCode 62

#### 問題描述

一個 m x n 的網格，從左上角 (0,0) 走到右下角 (m-1, n-1)，每步只能往**右**或往**下**，問共有幾條不同路徑？

#### 狀態定義與轉移

```
dp[i][j] = 從 (0,0) 走到 (i,j) 的路徑數

走到 (i,j) 只有兩種方式：
  1. 從上方 (i-1, j) 往下走一步
  2. 從左邊 (i, j-1) 往右走一步

所以：dp[i][j] = dp[i-1][j] + dp[i][j-1]

Base case:
  第一列: dp[0][j] = 1 (只能一直往右，只有一條路)
  第一行: dp[i][0] = 1 (只能一直往下，只有一條路)
```

#### 範例 1：m=3, n=3

```
3x3 網格：
  ┌───┬───┬───┐
  │ S │   │   │     S = Start
  ├───┼───┼───┤
  │   │   │   │
  ├───┼───┼───┤
  │   │   │ E │     E = End
  └───┴───┴───┘

填表過程：

       j=0   j=1   j=2
i=0  [  1  |  1  |  1  ]
i=1  [  1  |  2  |  3  ]
i=2  [  1  |  3  |  6  ]  ← 答案 = 6

逐格計算：
  dp[0][0] = 1  (起點)
  dp[0][1] = 1  (第一列，只能從左邊來，只有 1 條路)
  dp[0][2] = 1  (同上)
  dp[1][0] = 1  (第一行，只能從上面來，只有 1 條路)
  dp[1][1] = dp[0][1] + dp[1][0] = 1 + 1 = 2
             ↑ 從上方     ↑ 從左邊
  dp[1][2] = dp[0][2] + dp[1][1] = 1 + 2 = 3
  dp[2][0] = 1
  dp[2][1] = dp[1][1] + dp[2][0] = 2 + 1 = 3
  dp[2][2] = dp[1][2] + dp[2][1] = 3 + 3 = 6  ← 答案

6 條路徑分別是：
  RRD D, RDR D, RDDR, DRRD, DRDR, DDRR
  (R=右, D=下)
```

#### 範例 2：m=3, n=7

```
       j=0  j=1  j=2  j=3  j=4  j=5  j=6
i=0  [  1  | 1  | 1  | 1  | 1  | 1  | 1  ]
i=1  [  1  | 2  | 3  | 4  | 5  | 6  | 7  ]
i=2  [  1  | 3  | 6  | 10 | 15 | 21 | 28 ]  ← 答案 = 28

重點 cell 計算：
  dp[1][3] = dp[0][3] + dp[1][2] = 1 + 3 = 4
  dp[2][3] = dp[1][3] + dp[2][2] = 4 + 6 = 10
  dp[2][6] = dp[1][6] + dp[2][5] = 7 + 21 = 28

規律觀察：dp[i][j] 其實就是組合數 C(i+j, i)
  dp[2][6] = C(8, 2) = 8!/(2!*6!) = 28 ✓
```

#### Python 程式碼

```python
def uniquePaths(m: int, n: int) -> int:
    dp = [[1] * n for _ in range(m)]   # 初始全填 1
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[m-1][n-1]

# Time: O(m*n) | Space: O(m*n)，可優化到 O(n)
```

---

### 2.2 Minimum Path Sum -- LeetCode 64

#### 問題描述

m x n 的網格，每格有一個非負整數。從左上走到右下，只能往右或往下，求路徑上數字之和的最小值。

#### 狀態定義與轉移

```
dp[i][j] = 從 (0,0) 走到 (i,j) 的最小路徑和

轉移：dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
                  ↑ 目前格子的值     ↑ 從上方來    ↑ 從左邊來

Base case:
  dp[0][0] = grid[0][0]
  dp[0][j] = dp[0][j-1] + grid[0][j]   (第一列只能從左累加)
  dp[i][0] = dp[i-1][0] + grid[i][0]   (第一行只能從上累加)
```

#### 範例 1：grid = [[1,3,1],[1,5,1],[4,2,1]]

```
原始網格:
       j=0  j=1  j=2
i=0  [  1  | 3  | 1  ]
i=1  [  1  | 5  | 1  ]
i=2  [  4  | 2  | 1  ]

DP 表格（最小路徑和）:
       j=0  j=1  j=2
i=0  [  1  | 4  | 5  ]
i=1  [  2  | 7  | 6  ]
i=2  [  6  | 8  | 7  ]  ← 答案 = 7

逐格計算：
  dp[0][0] = grid[0][0] = 1
  dp[0][1] = dp[0][0] + grid[0][1] = 1 + 3 = 4
  dp[0][2] = dp[0][1] + grid[0][2] = 4 + 1 = 5
  dp[1][0] = dp[0][0] + grid[1][0] = 1 + 1 = 2
  dp[1][1] = grid[1][1] + min(dp[0][1], dp[1][0])
           = 5 + min(4, 2)
           = 5 + 2 = 7
  dp[1][2] = grid[1][2] + min(dp[0][2], dp[1][1])
           = 1 + min(5, 7)
           = 1 + 5 = 6
  dp[2][0] = dp[1][0] + grid[2][0] = 2 + 4 = 6
  dp[2][1] = grid[2][1] + min(dp[1][1], dp[2][0])
           = 2 + min(7, 6)
           = 2 + 6 = 8
  dp[2][2] = grid[2][2] + min(dp[1][2], dp[2][1])
           = 1 + min(6, 8)
           = 1 + 6 = 7  ← 答案

最短路徑：(0,0)→(1,0)→(1,1)→... 不對，追蹤一下：
  dp[2][2]=7 來自 dp[1][2]=6（上方）
  dp[1][2]=6 來自 dp[0][2]=5（上方）
  dp[0][2]=5 來自 dp[0][1]=4（左邊）
  dp[0][1]=4 來自 dp[0][0]=1（左邊）
  路徑：(0,0)→(0,1)→(0,2)→(1,2)→(2,2) = 1+3+1+1+1 = 7 ✓
```

#### 範例 2：grid = [[1,2,3],[4,5,6]]

```
原始網格:
       j=0  j=1  j=2
i=0  [  1  | 2  | 3  ]
i=1  [  4  | 5  | 6  ]

DP 表格:
       j=0  j=1  j=2
i=0  [  1  | 3  | 6  ]
i=1  [  5  | 8  | 12 ]  ← 答案 = 12

逐格計算：
  dp[0][0] = 1
  dp[0][1] = 1 + 2 = 3
  dp[0][2] = 3 + 3 = 6
  dp[1][0] = 1 + 4 = 5
  dp[1][1] = 5 + min(3, 5) = 5 + 3 = 8
  dp[1][2] = 6 + min(6, 8) = 6 + 6 = 12

路徑：(0,0)→(0,1)→(0,2)→(1,2) = 1+2+3+6 = 12 ✓
```

#### Python 程式碼

```python
def minPathSum(grid: list) -> int:
    m, n = len(grid), len(grid[0])
    dp = [[0] * n for _ in range(m)]
    dp[0][0] = grid[0][0]
    for j in range(1, n):
        dp[0][j] = dp[0][j-1] + grid[0][j]
    for i in range(1, m):
        dp[i][0] = dp[i-1][0] + grid[i][0]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
    return dp[m-1][n-1]

# Time: O(m*n) | Space: O(m*n)
```

---

## 第三章：字串型 2D DP -- Google 最愛

字串比對是 Google 面試的高頻題型。兩個字串之間的關係天然形成二維狀態。

### 3.1 Longest Common Subsequence (LCS) -- LeetCode 1143

#### 問題描述

給定兩個字串 text1 和 text2，找出它們的最長公共子序列（Longest Common Subsequence）的長度。子序列不要求連續，但要保持原始順序。

#### 狀態定義與轉移

```
dp[i][j] = text1 的前 i 個字元 vs text2 的前 j 個字元的 LCS 長度

轉移：
  如果 text1[i-1] == text2[j-1]（最後一個字元相同）:
    dp[i][j] = dp[i-1][j-1] + 1
    ← 兩邊各去掉最後一個字元的 LCS + 1（把這個匹配的字元加入 LCS）

  如果 text1[i-1] != text2[j-1]（最後一個字元不同）:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    ← 要嘛丟掉 text1 的最後一個字元，要嘛丟掉 text2 的最後一個字元
    ← 取兩者中較大的

Base case: dp[0][j] = 0, dp[i][0] = 0（空字串跟任何字串的 LCS = 0）
```

#### 範例 1："abcde" vs "ace"，答案 = 3 (LCS = "ace")

```
建立 DP 表格（多一列多一行代表空字串 ""）:

           ""    a    c    e
    ""  [  0  |  0  |  0  |  0  ]
     a  [  0  |  1  |  1  |  1  ]
     b  [  0  |  1  |  1  |  1  ]
     c  [  0  |  1  |  2  |  2  ]
     d  [  0  |  1  |  2  |  2  ]
     e  [  0  |  1  |  2  |  3  ]  ← 答案 = 3

逐格計算（只列重要的 cell）：

  dp[1][1]: text1[0]='a' == text2[0]='a' ✓
            → dp[0][0] + 1 = 0 + 1 = 1
            意思：LCS("a", "a") = 1

  dp[1][2]: text1[0]='a' != text2[1]='c'
            → max(dp[0][2], dp[1][1]) = max(0, 1) = 1
            意思：LCS("a", "ac") = 1（只有 'a' 匹配）

  dp[2][1]: text1[1]='b' != text2[0]='a'
            → max(dp[1][1], dp[2][0]) = max(1, 0) = 1
            意思：LCS("ab", "a") = 1（只有 'a' 匹配）

  dp[3][2]: text1[2]='c' == text2[1]='c' ✓
            → dp[2][1] + 1 = 1 + 1 = 2
            意思：LCS("abc", "ac") = 2（'a' 和 'c' 匹配）

  dp[5][3]: text1[4]='e' == text2[2]='e' ✓
            → dp[4][2] + 1 = 2 + 1 = 3
            意思：LCS("abcde", "ace") = 3（'a','c','e' 匹配）

  回溯找出 LCS 字串：
    dp[5][3]=3 ← match 'e'，走到 dp[4][2]
    dp[4][2]=2 ← not match，dp[3][2] >= dp[4][1]，走到 dp[3][2]
    dp[3][2]=2 ← match 'c'，走到 dp[2][1]
    dp[2][1]=1 ← not match，dp[1][1] >= dp[2][0]，走到 dp[1][1]
    dp[1][1]=1 ← match 'a'，走到 dp[0][0]
    LCS = "ace" ✓
```

#### 範例 2："abc" vs "def"，答案 = 0（完全沒有共同字元）

```
           ""    d    e    f
    ""  [  0  |  0  |  0  |  0  ]
     a  [  0  |  0  |  0  |  0  ]
     b  [  0  |  0  |  0  |  0  ]
     c  [  0  |  0  |  0  |  0  ]  ← 答案 = 0

每一格的 text1[i-1] 都 != text2[j-1]，所以每格都是 max(上, 左) = max(0, 0) = 0。
```

#### Python 程式碼

```python
def longestCommonSubsequence(text1: str, text2: str) -> int:
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[m][n]

# Time: O(m*n) | Space: O(m*n)
```

---

### 3.2 Edit Distance -- LeetCode 72 (Google Hard 經典)

#### 問題描述

給定兩個字串 word1 和 word2，你可以對 word1 執行三種操作：
1. **Insert** 一個字元
2. **Delete** 一個字元
3. **Replace** 一個字元

求把 word1 轉換成 word2 所需的**最少操作次數**。

#### 狀態定義與轉移

```
dp[i][j] = 把 word1 的前 i 個字元轉換成 word2 的前 j 個字元所需的最少操作數

轉移：
  如果 word1[i-1] == word2[j-1]（最後一個字元相同，不用做任何操作）:
    dp[i][j] = dp[i-1][j-1]

  如果 word1[i-1] != word2[j-1]（最後一個字元不同，三選一）:
    dp[i][j] = 1 + min(
        dp[i-1][j],      ← Delete:  刪掉 word1[i-1]，然後把 word1[:i-1] 轉成 word2[:j]
        dp[i][j-1],      ← Insert:  在 word1 末尾插入 word2[j-1]，然後把 word1[:i] 轉成 word2[:j-1]
        dp[i-1][j-1]     ← Replace: 把 word1[i-1] 替換成 word2[j-1]，然後處理剩下的
    )

Base case:
  dp[0][j] = j   （空字串變成長度 j 的字串，需要 j 次 insert）
  dp[i][0] = i   （長度 i 的字串變成空字串，需要 i 次 delete）
```

#### 範例 1："horse" -> "ros"，答案 = 3

```
建立 DP 表格:

           ""    r    o    s
    ""  [  0  |  1  |  2  |  3  ]
     h  [  1  |  1  |  2  |  3  ]
     o  [  2  |  2  |  1  |  2  ]
     r  [  3  |  2  |  2  |  2  ]
     s  [  4  |  3  |  3  |  2  ]
     e  [  5  |  4  |  4  |  3  ]  ← 答案 = 3

逐格計算：

  Base case:
  dp[0][0]=0, dp[0][1]=1, dp[0][2]=2, dp[0][3]=3  (""→"r"需1步, ""→"ro"需2步...)
  dp[1][0]=1, dp[2][0]=2, dp[3][0]=3, dp[4][0]=4, dp[5][0]=5

  dp[1][1]: word1[0]='h' != word2[0]='r'
    delete:  dp[0][1] = 1
    insert:  dp[1][0] = 1
    replace: dp[0][0] = 0
    → 1 + min(1, 1, 0) = 1 + 0 = 1  (replace 'h' → 'r')

  dp[1][2]: word1[0]='h' != word2[1]='o'
    delete:  dp[0][2] = 2
    insert:  dp[1][1] = 1
    replace: dp[0][1] = 1
    → 1 + min(2, 1, 1) = 1 + 1 = 2

  dp[2][2]: word1[1]='o' == word2[1]='o' ✓
    → dp[1][1] = 1  (字元相同，不需操作)

  dp[3][1]: word1[2]='r' == word2[0]='r' ✓
    → dp[2][0] = 2

  dp[4][3]: word1[3]='s' == word2[2]='s' ✓
    → dp[3][2] = 2

  dp[5][3]: word1[4]='e' != word2[2]='s'
    delete:  dp[4][3] = 2
    insert:  dp[5][2] = 4
    replace: dp[4][2] = 3
    → 1 + min(2, 4, 3) = 1 + 2 = 3

回溯最佳操作路徑：
  dp[5][3]=3 ← delete 'e'     → "hors" → "ros" (還需 2 步)
  dp[4][3]=2 ← keep 's'       → "hor"  → "ro"  (還需 2 步)
  dp[3][2]=2 ← delete 'r'     → "ho"   → "ro"  (還需 1 步)
  dp[2][2]=1 ← keep 'o'       → "h"    → "r"   (還需 1 步)
  dp[1][1]=1 ← replace 'h'->'r' → ""  → ""    (完成!)

操作順序：replace h→r, delete r, delete e  (共 3 步)
  horse → rorse → rose → ros ✓
```

#### 範例 2："intention" -> "execution"，答案 = 5

```
           ""   e   x   e   c   u   t   i   o   n
    ""  [  0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ]
     i  [  1 | 1 | 2 | 3 | 4 | 5 | 6 | 6 | 7 | 8 ]
     n  [  2 | 2 | 2 | 3 | 4 | 5 | 6 | 7 | 7 | 7 ]
     t  [  3 | 3 | 3 | 3 | 4 | 5 | 5 | 6 | 7 | 8 ]
     e  [  4 | 3 | 4 | 3 | 4 | 5 | 6 | 6 | 7 | 8 ]
     n  [  5 | 4 | 4 | 4 | 4 | 5 | 6 | 7 | 7 | 7 ]
     t  [  6 | 5 | 5 | 5 | 5 | 5 | 5 | 6 | 7 | 8 ]
     i  [  7 | 6 | 6 | 6 | 6 | 6 | 6 | 5 | 6 | 7 ]
     o  [  8 | 7 | 7 | 7 | 7 | 7 | 7 | 6 | 5 | 6 ]
     n  [  9 | 8 | 8 | 8 | 8 | 8 | 8 | 7 | 6 | 5 ]
                                                  ↑ 答案 = 5

重點 cell 解釋：
  dp[4][1]: word1[3]='e' == word2[0]='e' ✓ → dp[3][0] = 3
  dp[4][3]: word1[3]='e' == word2[2]='e' ✓ → dp[3][2] = 3
  dp[7][7]: word1[6]='i' == word2[6]='i' ✓ → dp[6][6] = 5 (不用操作)
  dp[8][8]: word1[7]='o' == word2[7]='o' ✓ → dp[7][7] = 5
  dp[9][9]: word1[8]='n' == word2[8]='n' ✓ → dp[8][8] = 5

操作：
  intention → inention (delete t)
  → enention (replace i → e)
  → exention (replace n → x)
  → exection (replace n → c)
  → execution (insert u)
  共 5 步 ✓
```

#### Python 程式碼

```python
def minDistance(word1: str, word2: str) -> int:
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j],      # delete
                                   dp[i][j-1],       # insert
                                   dp[i-1][j-1])     # replace
    return dp[m][n]

# Time: O(m*n) | Space: O(m*n)
```

#### 面試對話範例

```
面試官: "How would you convert 'horse' to 'ros'?"

你: "I'd use dynamic programming. dp[i][j] represents the minimum edits
     to convert the first i characters of word1 to the first j characters
     of word2. For each pair of characters, if they match, no operation
     is needed. Otherwise, I take the minimum of delete, insert, or
     replace, each costing 1 operation."

面試官: "What's the time and space complexity?"

你: "Time is O(m*n) where m and n are the lengths of the two words.
     Space is also O(m*n) for the DP table, but we can optimize to
     O(min(m,n)) since we only need the previous row."
```

---

### 3.3 Longest Palindromic Substring -- LeetCode 5

#### 問題描述

給定字串 s，找出最長的回文子字串（palindromic substring）。注意是**子字串（連續）**，不是子序列。

#### 狀態定義與轉移

```
dp[i][j] = True 表示 s[i..j] 是回文

轉移（由短到長建構）：
  長度 1: dp[i][i] = True  (單一字元一定是回文)
  長度 2: dp[i][i+1] = (s[i] == s[i+1])
  長度 >= 3: dp[i][j] = (s[i] == s[j]) and dp[i+1][j-1]
             ← 頭尾相同，且去掉頭尾後仍是回文

填表順序：按長度從小到大（長度 1 → 2 → 3 → ...）
  這確保算 dp[i][j] 時 dp[i+1][j-1]（更短的子字串）已經算好。
```

#### 範例 1：s = "babad"，答案 = "bab" 或 "aba"

```
DP 表格 (T=True 是回文, .=False 不是回文):

        b    a    b    a    d
  b  [  T  | .  | T  | .  | .  ]
  a  [     | T  | .  | T  | .  ]
  b  [     |    | T  | .  | .  ]
  a  [     |    |    | T  | .  ]
  d  [     |    |    |    | T  ]

只看上三角 (i <= j)

長度 1: dp[0][0]=T, dp[1][1]=T, dp[2][2]=T, dp[3][3]=T, dp[4][4]=T
        (所有單一字元都是回文)

長度 2: dp[0][1]: s[0]='b' != s[1]='a' → False
        dp[1][2]: s[1]='a' != s[2]='b' → False
        dp[2][3]: s[2]='b' != s[3]='a' → False
        dp[3][4]: s[3]='a' != s[4]='d' → False

長度 3: dp[0][2]: s[0]='b' == s[2]='b' and dp[1][1]=T → True!  ← "bab" 是回文
        dp[1][3]: s[1]='a' == s[3]='a' and dp[2][2]=T → True!  ← "aba" 是回文
        dp[2][4]: s[2]='b' != s[4]='d' → False

長度 4: dp[0][3]: s[0]='b' != s[3]='a' → False
        dp[1][4]: s[1]='a' != s[4]='d' → False

長度 5: dp[0][4]: s[0]='b' != s[4]='d' → False

最長回文子字串長度 = 3，可以是 "bab" 或 "aba"
```

#### 範例 2：s = "cbbd"，答案 = "bb"

```
DP 表格:

        c    b    b    d
  c  [  T  | .  | .  | .  ]
  b  [     | T  | T  | .  ]
  b  [     |    | T  | .  ]
  d  [     |    |    | T  ]

長度 1: 全部 T
長度 2: dp[0][1]: 'c'!='b' → F
        dp[1][2]: 'b'=='b' → T!  ← "bb" 是回文
        dp[2][3]: 'b'!='d' → F
長度 3: dp[0][2]: 'c'!='b' → F
        dp[1][3]: 'b'!='d' → F
長度 4: dp[0][3]: 'c'!='d' → F

最長回文 = "bb" (長度 2) ✓
```

#### Python 程式碼

```python
def longestPalindrome(s: str) -> str:
    n = len(s)
    if n <= 1:
        return s
    dp = [[False] * n for _ in range(n)]
    start, max_len = 0, 1

    # 長度 1
    for i in range(n):
        dp[i][i] = True

    # 長度 2
    for i in range(n - 1):
        if s[i] == s[i + 1]:
            dp[i][i + 1] = True
            start, max_len = i, 2

    # 長度 >= 3
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j] and dp[i + 1][j - 1]:
                dp[i][j] = True
                if length > max_len:
                    start, max_len = i, length

    return s[start:start + max_len]

# Time: O(n^2) | Space: O(n^2)
# 註：也可用中心擴展法 O(n^2) Time O(1) Space，但 DP 解更好理解
```

---

## 第四章：背包問題 (Knapsack) -- 從零開始

### 4.0 什麼是背包問題？生活化比喻

```
你要去露營，帶了一個背包，最多能裝 W 公斤。
營地商店有 n 件物品，每件有：
  - 重量 weight[i]
  - 價值 value[i]

你想讓背包裡的物品總價值最大，但不能超重。

  ┌─────────────────────────────────┐
  │  背包容量: W = 8 kg             │
  │                                 │
  │  物品清單:                       │
  │  帳篷:   重量=5, 價值=6         │
  │  睡袋:   重量=4, 價值=5         │
  │  食物:   重量=3, 價值=4         │
  │  水壺:   重量=2, 價值=3         │
  │                                 │
  │  問: 帶哪些東西使得總價值最大？   │
  └─────────────────────────────────┘

暴力法: 每件物品有 2 種選擇(帶/不帶)，共 2^n 種組合，逐一算價值取最大。
DP 法: O(n * W)，用表格避免重複計算。
```

### 4.1 0/1 Knapsack 原理（每件物品只能用一次）

#### 狀態定義與轉移

```
dp[i][w] = 考慮前 i 個物品，背包容量為 w 時的最大價值

轉移：對第 i 個物品，只有兩種選擇：

  選擇 1 — 不拿第 i 個物品:
    dp[i][w] = dp[i-1][w]
    ← 等於「只考慮前 i-1 個物品、容量 w」的最大價值

  選擇 2 — 拿第 i 個物品 (前提: w >= weight[i]):
    dp[i][w] = dp[i-1][w - weight[i]] + value[i]
    ← 容量扣掉物品 i 的重量，價值加上物品 i 的價值
    ← 注意是 dp[i-1]，因為 0/1 背包每個物品只能用一次

  最終: dp[i][w] = max(不拿, 拿)

Base case: dp[0][w] = 0 (沒有物品可選，價值為 0)
```

#### 範例：weights=[2,3,4,5], values=[3,4,5,6], capacity=8

```
物品編號:  1     2     3     4
重量:      2     3     4     5
價值:      3     4     5     6

建立 DP 表格 (i=物品編號, w=容量):

         w=0  w=1  w=2  w=3  w=4  w=5  w=6  w=7  w=8
  i=0  [  0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  ]  (沒有物品)
  i=1  [  0  | 0  | 3  | 3  | 3  | 3  | 3  | 3  | 3  ]  (只考慮物品1: w=2,v=3)
  i=2  [  0  | 0  | 3  | 4  | 4  | 7  | 7  | 7  | 7  ]  (考慮物品1,2)
  i=3  [  0  | 0  | 3  | 4  | 5  | 7  | 8  | 9  | 9  ]  (考慮物品1,2,3)
  i=4  [  0  | 0  | 3  | 4  | 5  | 7  | 8  | 9  | 10 ]  (考慮全部)
                                                      ↑ 答案 = 10

逐格計算（重要 cell）：

  i=1 (物品1: w=2, v=3):
    dp[1][0]=0, dp[1][1]=0  (容量不夠放物品1)
    dp[1][2]: max(dp[0][2], dp[0][2-2]+3) = max(0, 0+3) = 3  ← 拿物品1
    dp[1][5]: max(dp[0][5], dp[0][5-2]+3) = max(0, 0+3) = 3  ← 拿物品1

  i=2 (物品2: w=3, v=4):
    dp[2][2]: max(dp[1][2], dp[1][2-3]+4) → 容量不夠拿物品2 → dp[1][2] = 3
    dp[2][3]: max(dp[1][3], dp[1][3-3]+4) = max(3, 0+4) = 4  ← 拿物品2
    dp[2][5]: max(dp[1][5], dp[1][5-3]+4) = max(3, 3+4) = 7  ← 拿物品1+2
              容量5: 物品1(w=2)+物品2(w=3)=5，剛好裝滿，價值=3+4=7

  i=3 (物品3: w=4, v=5):
    dp[3][4]: max(dp[2][4], dp[2][4-4]+5) = max(4, 0+5) = 5  ← 拿物品3
    dp[3][6]: max(dp[2][6], dp[2][6-4]+5) = max(7, 3+5) = 8  ← 拿物品1+3
    dp[3][7]: max(dp[2][7], dp[2][7-4]+5) = max(7, 4+5) = 9  ← 拿物品2+3

  i=4 (物品4: w=5, v=6):
    dp[4][5]: max(dp[3][5], dp[3][5-5]+6) = max(7, 0+6) = 7  ← 不拿(7>6)
    dp[4][7]: max(dp[3][7], dp[3][7-5]+6) = max(9, 3+6) = 9  ← 打平
    dp[4][8]: max(dp[3][8], dp[3][8-5]+6) = max(9, 4+6) = 10 ← 拿物品2+4!

最優解：拿物品 2 (w=3, v=4) + 物品 4 (w=5, v=6)
  總重量 = 3 + 5 = 8 (剛好)
  總價值 = 4 + 6 = 10 ✓
```

#### 1D 空間優化（重要！面試常問）

```python
# 2D 版本
dp = [[0] * (capacity + 1) for _ in range(n + 1)]
for i in range(1, n + 1):
    for w in range(capacity + 1):
        dp[i][w] = dp[i-1][w]
        if w >= weights[i-1]:
            dp[i][w] = max(dp[i][w], dp[i-1][w-weights[i-1]] + values[i-1])

# 1D 版本 — 內層迴圈倒序!
dp = [0] * (capacity + 1)
for i in range(n):
    for w in range(capacity, weights[i] - 1, -1):  # ← 倒序!
        dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
```

**為什麼要倒序？**

```
假設我們用正序 (左到右)：
  物品 i: weight=2, value=3

  dp[2] = max(dp[2], dp[0] + 3) = 3    ← OK, 拿了一次物品 i
  dp[4] = max(dp[4], dp[2] + 3) = 6    ← 問題! dp[2] 已經被更新為 3
                                            等於又拿了一次物品 i！

  正序導致同一輪中 dp[w-weight] 已包含本輪物品 → 重複使用!

用倒序 (右到左)：
  dp[4] = max(dp[4], dp[2] + 3)   ← dp[2] 還是上一輪的值 (0)，正確!
  dp[2] = max(dp[2], dp[0] + 3)   ← dp[0] 也是上一輪的值 (0)，正確!

  倒序保證 dp[w-weight] 是「不含本輪物品」的值 → 每個物品最多用一次!
```

---

### 4.2 Partition Equal Subset Sum -- LeetCode 416

#### 問題描述

給定一個只包含正整數的非空陣列 nums，判斷是否可以把它分成兩個子集，使得兩個子集的元素和相等。

#### 轉化成背包問題

```
如果能分成兩個等和子集，每個子集的和 = total / 2

所以問題變成：能否從 nums 中選出一些數字，使得它們的和恰好 = total / 2？

這就是 0/1 背包！
  「物品」= nums 中的每個數字
  「背包容量」= total / 2
  「目標」= 能否恰好裝滿（不是求最大價值，而是求 True/False）

dp[i][s] = 考慮前 i 個數字，能否湊出和 s
  不選 nums[i-1]: dp[i][s] = dp[i-1][s]
  選 nums[i-1]:   dp[i][s] = dp[i-1][s - nums[i-1]]  (如果 s >= nums[i-1])
  dp[i][s] = dp[i-1][s] or dp[i-1][s - nums[i-1]]
```

#### 範例 1：nums = [1, 5, 11, 5]，答案 = True

```
total = 22, target = 11

DP 表格 (T=True 可以湊出, .=False 不行):

         s=0  s=1  s=2  s=3  s=4  s=5  s=6  s=7  s=8  s=9  s=10  s=11
  init [  T  | .  | .  | .  | .  | .  | .  | .  | .  | .  |  .  |  .  ]
  +1   [  T  | T  | .  | .  | .  | .  | .  | .  | .  | .  |  .  |  .  ]
  +5   [  T  | T  | .  | .  | .  | T  | T  | .  | .  | .  |  .  |  .  ]
  +11  [  T  | T  | .  | .  | .  | T  | T  | .  | .  | .  |  .  |  T  ]
  +5   [  T  | T  | .  | .  | .  | T  | T  | .  | .  | .  |  T  |  T  ]
                                                                     ↑ True!

逐行計算：
  init: 只有 s=0 是 T（不選任何數字，和 = 0）

  +1 (考慮數字 1):
    s=0: T (不選 1)
    s=1: dp[0][1-1]=dp[0][0]=T → T (選 1)
    s=2~11: F

  +5 (考慮數字 1, 5):
    s=5: dp[1][5-5]=dp[1][0]=T → T (選 5)
    s=6: dp[1][6-5]=dp[1][1]=T → T (選 1 和 5)

  +11 (考慮數字 1, 5, 11):
    s=11: dp[2][11-11]=dp[2][0]=T → T (選 11)

  +5 (考慮數字 1, 5, 11, 5):
    s=10: dp[3][10-5]=dp[3][5]=T → T (選 5 和 5)
    s=11: dp[3][11]=T already → T

最終 dp[4][11] = True → 可以均分！
子集: {1, 5, 5} 和 {11}，各自和 = 11 ✓
```

#### 範例 2：nums = [1, 2, 3, 5]，答案 = False

```
total = 11 → 奇數！

奇數不可能均分成兩個整數之和！
直接 return False（不需要建表）。

這是最重要的剪枝：if total % 2 != 0: return False
```

#### Python 程式碼

```python
def canPartition(nums: list) -> bool:
    total = sum(nums)
    if total % 2 != 0:
        return False
    target = total // 2

    # 1D DP
    dp = [False] * (target + 1)
    dp[0] = True
    for num in nums:
        for s in range(target, num - 1, -1):  # 倒序 = 0/1 背包
            dp[s] = dp[s] or dp[s - num]
    return dp[target]

# Time: O(n * target) | Space: O(target)
```

---

### 4.3 Target Sum -- LeetCode 494

#### 問題描述

給定陣列 nums 和目標值 target，你可以在每個數字前面放 `+` 或 `-`，使得所有數字的和恰好等於 target。求有幾種方法。

#### 數學轉化（關鍵！）

```
設：
  P = 所有取 + 號的數字之和
  N = 所有取 - 號的數字之和

已知：
  P - N = target      (定義)
  P + N = total        (所有數字的總和)

兩式相加：
  2P = target + total
  P = (target + total) / 2

所以問題變成：從 nums 中選出一些數字，使得它們的和恰好 = P
  → 0/1 背包，「計數」版本（不是 True/False，而是有幾種方法）

限制條件：
  - (target + total) 必須是偶數，否則 P 不是整數 → 答案 = 0
  - |target| <= total，否則不可能達成 → 答案 = 0
```

#### 範例 1：nums = [1, 1, 1, 1, 1], target = 3

```
total = 5
P = (3 + 5) / 2 = 4

問題轉化：從 [1,1,1,1,1] 選出子集和 = 4 的方法數

DP 表格（計數版 0/1 背包）:

         s=0  s=1  s=2  s=3  s=4
  init [  1  | 0  | 0  | 0  | 0  ]
  +1   [  1  | 1  | 0  | 0  | 0  ]
  +1   [  1  | 2  | 1  | 0  | 0  ]
  +1   [  1  | 3  | 3  | 1  | 0  ]
  +1   [  1  | 4  | 6  | 4  | 1  ]
  +1   [  1  | 5  | 10 | 10 | 5  ]
                                ↑ 答案 = 5

逐行計算：
  init: dp[0]=1 (空子集和=0，一種方法)

  第 1 個 1: dp[1] += dp[1-1] = dp[0] = 1 → dp[1]=1

  第 2 個 1: dp[2] += dp[1] → 0+1=1; dp[1] += dp[0] → 1+1=2

  第 3 個 1: dp[3] += dp[2]=1; dp[2] += dp[1]=3 → 0+1=1,1+2=3; dp[1] += dp[0]=3

  最終 dp[4] = 5

驗證：5 個 1 取 4 個放 + 號 = C(5,4) = 5 種 ✓
  +1+1+1+1-1 = 3
  +1+1+1-1+1 = 3
  +1+1-1+1+1 = 3
  +1-1+1+1+1 = 3
  -1+1+1+1+1 = 3
```

#### 範例 2：nums = [1, 2, 3], target = 0

```
total = 6
P = (0 + 6) / 2 = 3

問題轉化：從 [1,2,3] 選出子集和 = 3 的方法數

         s=0  s=1  s=2  s=3
  init [  1  | 0  | 0  | 0  ]
  +1   [  1  | 1  | 0  | 0  ]
  +2   [  1  | 1  | 1  | 1  ]
  +3   [  1  | 1  | 1  | 2  ]
                           ↑ 答案 = 2 (不是 3!)

但等等，這是在數字沒有 0 的情況。方法如下：
  選 {3}:       +3 -1 -2 = 0 ✓    或寫成  -1-2+3 = 0
  選 {1, 2}:    +1 +2 -3 = 0 ✓    或寫成  +1+2-3 = 0

但不是 {1,2,3}，因為 P=3，所以只選和為 3 的子集。
  {3} 和 {1,2} 恰好 2 種 → 答案 = 2

等等，讓我重新驗算所有組合：
  +1+2+3 = 6  (不是0)
  +1+2-3 = 0  ✓
  +1-2+3 = 2  (不是0)
  +1-2-3 = -4 (不是0)
  -1+2+3 = 4  (不是0)
  -1+2-3 = -2 (不是0)
  -1-2+3 = 0  ✓
  -1-2-3 = -6 (不是0)

  共 2 種，答案 = 2，沒錯！
```

#### Python 程式碼

```python
def findTargetSumWays(nums: list, target: int) -> int:
    total = sum(nums)
    if (target + total) % 2 != 0 or abs(target) > total:
        return 0
    bag = (target + total) // 2

    dp = [0] * (bag + 1)
    dp[0] = 1
    for num in nums:
        for s in range(bag, num - 1, -1):  # 倒序 = 0/1 背包
            dp[s] += dp[s - num]
    return dp[bag]

# Time: O(n * bag) | Space: O(bag)
```

---

## 第五章：完全背包 (Unbounded Knapsack)

### 5.0 跟 0/1 背包的差異

```
┌──────────────────┬──────────────────────┬──────────────────────┐
│                  │  0/1 背包             │  完全背包             │
├──────────────────┼──────────────────────┼──────────────────────┤
│ 物品使用次數      │ 每件最多 1 次         │ 每件可以無限次        │
│ 現實比喻         │ 二手市場（獨一無二）    │ 超商（同商品無限量）   │
│ 轉移公式 (2D)    │ dp[i-1][w-wt] + val  │ dp[i][w-wt] + val    │
│                  │ ↑ 用上一列 (i-1)      │ ↑ 用同一列 (i)       │
│ 1D 內層迴圈方向   │ 倒序 (capacity→0)    │ 正序 (0→capacity)    │
└──────────────────┴──────────────────────┴──────────────────────┘

關鍵記憶法：
  0/1 = 倒序 = 每個物品只用一次 (因為算 dp[w] 時 dp[w-wt] 還是舊值)
  完全 = 正序 = 允許重複使用     (因為算 dp[w] 時 dp[w-wt] 可能已被本輪更新)
```

#### 為什麼正序 = 可以重複使用？圖解

```
物品: weight=2, value=3, capacity=6

0/1 背包（倒序）：
  處理 dp[6] → dp[4] → dp[2]
  dp[6] = max(dp[6], dp[4]+3)   ← dp[4] 是上一輪的值（不含本物品）
  dp[4] = max(dp[4], dp[2]+3)   ← dp[2] 是上一輪的值
  dp[2] = max(dp[2], dp[0]+3)   ← dp[0] 是上一輪的值
  → 物品只被用了一次

完全背包（正序）：
  處理 dp[2] → dp[4] → dp[6]
  dp[2] = max(dp[2], dp[0]+3) = 3     ← 用了 1 次
  dp[4] = max(dp[4], dp[2]+3) = 6     ← dp[2] 已更新為 3（含本物品）→ 用了 2 次!
  dp[6] = max(dp[6], dp[4]+3) = 9     ← dp[4] 已更新為 6 → 用了 3 次!
  → 物品可以重複使用!
```

---

### 5.1 Coin Change -- LeetCode 322

#### 問題描述

給定不同面額的硬幣 coins 和一個總金額 amount，計算湊出 amount 所需的**最少硬幣數**。每種硬幣可以使用無限次。如果無法湊出，回傳 -1。

#### 轉化成完全背包

```
  「物品」= 硬幣面額
  「背包容量」= 目標金額 amount
  「價值」= 硬幣數量（我們想最小化，不是最大化）
  「無限次使用」→ 完全背包

dp[a] = 湊出金額 a 所需的最少硬幣數
  dp[0] = 0 (湊出 0 元需要 0 枚硬幣)
  dp[a] = min(dp[a], dp[a - coin] + 1) for each coin  (如果 a >= coin)
```

這題之前在 Coin Change 的 1D DP 教學中已經詳細說過。這裡從背包觀點重新理解：

#### 範例：coins = [1, 2, 5], amount = 11

```
1D DP 表格（正序 = 完全背包）:

  金額:  0   1   2   3   4   5   6   7   8   9  10  11
  dp: [  0 | X | X | X | X | X | X | X | X | X | X | X ]  初始

  處理 coin=1（正序）:
  dp: [  0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |11 ]
        dp[1]=dp[0]+1=1, dp[2]=dp[1]+1=2, ... dp[11]=11

  處理 coin=2（正序）:
  dp: [  0 | 1 | 1 | 2 | 2 | 3 | 3 | 4 | 4 | 5 | 5 | 6 ]
        dp[2]=min(2, dp[0]+1)=1, dp[3]=min(3, dp[1]+1)=2
        dp[4]=min(4, dp[2]+1)=min(4,2)=2, ...

  處理 coin=5（正序）:
  dp: [  0 | 1 | 1 | 2 | 2 | 1 | 2 | 2 | 3 | 3 | 2 | 3 ]
        dp[5]=min(3, dp[0]+1)=1
        dp[10]=min(5, dp[5]+1)=2
        dp[11]=min(6, dp[6]+1)=min(6,3)=3

答案 = dp[11] = 3（5+5+1）✓
```

#### Python 程式碼（背包觀點）

```python
def coinChange(coins: list, amount: int) -> int:
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for a in range(coin, amount + 1):   # 正序 = 完全背包
            dp[a] = min(dp[a], dp[a - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1
```

---

### 5.2 Coin Change 2 -- LeetCode 518 (計算組合數)

#### 問題描述

給定不同面額的硬幣 coins 和一個總金額 amount，計算湊出 amount 的**不同組合數**。每種硬幣可以使用無限次。注意 [1,2] 和 [2,1] 是同一種組合。

#### 與 Coin Change 的差異

```
Coin Change (LC 322):  求最少硬幣「數量」 → min
Coin Change 2 (LC 518): 求組合「方法數」  → sum (累加)

dp[a] = 湊出金額 a 的組合數
  dp[0] = 1 (湊出 0 元，只有一種方式：不選任何硬幣)
  dp[a] += dp[a - coin]  (每用一枚 coin，方法數加上 dp[a-coin] 的方法數)
```

#### 範例 1：coins = [1, 2, 5], amount = 5

```
2D DP 表格（更清楚地看到每種硬幣的貢獻）:

          a=0  a=1  a=2  a=3  a=4  a=5
  init  [  1  | 0  | 0  | 0  | 0  | 0  ]
  +1    [  1  | 1  | 1  | 1  | 1  | 1  ]
  +2    [  1  | 1  | 2  | 2  | 3  | 3  ]
  +5    [  1  | 1  | 2  | 2  | 3  | 4  ]  ← 答案 = 4

逐行計算：

  init: dp[0]=1，其餘為 0

  +1 (只用 1 元硬幣):
    dp[1]=dp[0]=1 (1)
    dp[2]=dp[1]=1 (1+1)
    dp[3]=dp[2]=1 (1+1+1)
    dp[4]=dp[3]=1 (1+1+1+1)
    dp[5]=dp[4]=1 (1+1+1+1+1)

  +2 (加入 2 元硬幣):
    dp[2]= 原本1 + dp[0]=1 = 2  (1+1 或 2，兩種)
    dp[3]= 原本1 + dp[1]=1 = 2  (1+1+1 或 1+2，兩種)
    dp[4]= 原本1 + dp[2]=2 = 3  (1+1+1+1 或 1+1+2 或 2+2，三種)
    dp[5]= 原本1 + dp[3]=2 = 3  (1*5 或 1+1+1+2 或 1+2+2，三種)

  +5 (加入 5 元硬幣):
    dp[5]= 原本3 + dp[0]=1 = 4  (前面 3 種 + 用一個 5 元)

4 種組合：{5}, {1+2+2}, {1+1+1+2}, {1+1+1+1+1} ✓
```

#### 範例 2：coins = [1, 2, 3], amount = 4

```
          a=0  a=1  a=2  a=3  a=4
  init  [  1  | 0  | 0  | 0  | 0  ]
  +1    [  1  | 1  | 1  | 1  | 1  ]
  +2    [  1  | 1  | 2  | 2  | 3  ]
  +3    [  1  | 1  | 2  | 3  | 4  ]  ← 答案 = 4

+2 行計算：
  dp[2] = 1 + dp[0] = 1 + 1 = 2     (1+1 或 2)
  dp[3] = 1 + dp[1] = 1 + 1 = 2     (1+1+1 或 1+2)
  dp[4] = 1 + dp[2] = 1 + 2 = 3     (1+1+1+1 或 1+1+2 或 2+2)

+3 行計算：
  dp[3] = 2 + dp[0] = 2 + 1 = 3     (加上 {3} 這種組合)
  dp[4] = 3 + dp[1] = 3 + 1 = 4     (加上 {1+3} 這種組合)

4 種組合：{1+1+1+1}, {1+1+2}, {2+2}, {1+3} ✓
```

#### 為什麼外層遍歷 coin、內層遍歷 amount 可以避免重複？

```
關鍵問題：[1,2] 和 [2,1] 應該算同一種，怎麼避免重複？

答案：因為我們是「逐種硬幣加入」的。

  當我們處理 coin=1 時，只能用 1 元。
  當我們處理 coin=2 時，可以用 1 元和 2 元。
  當我們處理 coin=5 時，可以用 1 元、2 元和 5 元。

  這相當於強制「先用小面額、再用大面額」的順序。
  [1,2] 會被計入，[2,1] 不會被重複計入。

  如果反過來（外層遍歷 amount、內層遍歷 coin），就會變成計算「排列數」!
```

#### Python 程式碼

```python
def change(amount: int, coins: list) -> int:
    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:                          # 外層: 逐種硬幣
        for a in range(coin, amount + 1):       # 內層: 正序 = 完全背包
            dp[a] += dp[a - coin]
    return dp[amount]

# Time: O(n * amount) | Space: O(amount)
```

---

## 第六章：區間 DP

### 6.1 Burst Balloons -- LeetCode 312 (Google Hard 經典)

#### 問題描述

有 n 個氣球排成一排，每個氣球上寫著一個數字。每次你可以戳破一個氣球 i，獲得 `nums[left] * nums[i] * nums[right]` 枚金幣（left 和 right 是 i 的相鄰氣球）。戳破後，left 和 right 就變成相鄰的了。求最大金幣數。

#### 為什麼是區間 DP？

```
直覺想法：考慮「先戳哪個」很難，因為戳掉一個後，鄰居會改變。

逆向思考：考慮「最後戳哪個」！

如果我們知道在區間 [i, j] 中，最後戳的是 k，那麼：
  - k 左邊的氣球已經全部戳完了 → 子問題 dp[i][k]
  - k 右邊的氣球已經全部戳完了 → 子問題 dp[k][j]
  - 最後戳 k 時，k 的左鄰居是 i，右鄰居是 j（因為 i,j 之間的其他氣球都已經沒了）
  - 所以最後一步得到 nums[i] * nums[k] * nums[j]

技巧：在原陣列兩端加上 1，方便處理邊界。
  arr = [1] + nums + [1]

dp[i][j] = 戳破 i 和 j 之間（不含 i, j 本身）所有氣球能得到的最大金幣

轉移：dp[i][j] = max(dp[i][k] + dp[k][j] + arr[i]*arr[k]*arr[j])
                 for k in (i+1, i+2, ..., j-1)
                 k = 「最後被戳的氣球」
```

#### 範例：nums = [3, 1, 5, 8]

```
加邊界後: arr = [1, 3, 1, 5, 8, 1]
  index:         0  1  2  3  4  5

dp[i][j] = 戳破 (i,j) 之間氣球的最大金幣（不含 i, j 自身）

填表順序：按區間長度從小到大

長度 2（i 和 j 之間有 1 個氣球）：
  dp[0][2]: k=1, arr[0]*arr[1]*arr[2] = 1*3*1 = 3
            最後戳 1 號(值3)，左右是 0 號(1) 和 2 號(1)
            dp[0][2] = 3

  dp[1][3]: k=2, arr[1]*arr[2]*arr[3] = 3*1*5 = 15
            dp[1][3] = 15

  dp[2][4]: k=3, arr[2]*arr[3]*arr[4] = 1*5*8 = 40
            dp[2][4] = 40

  dp[3][5]: k=4, arr[3]*arr[4]*arr[5] = 5*8*1 = 40
            dp[3][5] = 40

長度 3（i 和 j 之間有 2 個氣球）：
  dp[0][3]: 戳破 index 1, 2（值 3 和 1），最後戳誰？
    k=1: dp[0][1] + dp[1][3] + arr[0]*arr[1]*arr[3]
       = 0 + 15 + 1*3*5 = 0 + 15 + 15 = 30
    k=2: dp[0][2] + dp[2][3] + arr[0]*arr[2]*arr[3]
       = 3 + 0 + 1*1*5 = 3 + 0 + 5 = 8
    dp[0][3] = max(30, 8) = 30

  dp[1][4]: 戳破 index 2, 3（值 1 和 5）
    k=2: dp[1][2] + dp[2][4] + arr[1]*arr[2]*arr[4]
       = 0 + 40 + 3*1*8 = 0 + 40 + 24 = 64
    k=3: dp[1][3] + dp[3][4] + arr[1]*arr[3]*arr[4]
       = 15 + 0 + 3*5*8 = 15 + 0 + 120 = 135
    dp[1][4] = max(64, 135) = 135

  dp[2][5]: 戳破 index 3, 4（值 5 和 8）
    k=3: dp[2][3] + dp[3][5] + arr[2]*arr[3]*arr[5]
       = 0 + 40 + 1*5*1 = 0 + 40 + 5 = 45
    k=4: dp[2][4] + dp[4][5] + arr[2]*arr[4]*arr[5]
       = 40 + 0 + 1*8*1 = 40 + 0 + 8 = 48
    dp[2][5] = max(45, 48) = 48

長度 4（i 和 j 之間有 3 個氣球）：
  dp[0][4]: 戳破 index 1, 2, 3（值 3, 1, 5）
    k=1: dp[0][1] + dp[1][4] + arr[0]*arr[1]*arr[4]
       = 0 + 135 + 1*3*8 = 0 + 135 + 24 = 159
    k=2: dp[0][2] + dp[2][4] + arr[0]*arr[2]*arr[4]
       = 3 + 40 + 1*1*8 = 3 + 40 + 8 = 51
    k=3: dp[0][3] + dp[3][4] + arr[0]*arr[3]*arr[4]
       = 30 + 0 + 1*5*8 = 30 + 0 + 40 = 70
    dp[0][4] = max(159, 51, 70) = 159

  dp[1][5]: 戳破 index 2, 3, 4（值 1, 5, 8）
    k=2: dp[1][2] + dp[2][5] + arr[1]*arr[2]*arr[5]
       = 0 + 48 + 3*1*1 = 0 + 48 + 3 = 51
    k=3: dp[1][3] + dp[3][5] + arr[1]*arr[3]*arr[5]
       = 15 + 40 + 3*5*1 = 15 + 40 + 15 = 70
    k=4: dp[1][4] + dp[4][5] + arr[1]*arr[4]*arr[5]
       = 135 + 0 + 3*8*1 = 135 + 0 + 24 = 159
    dp[1][5] = max(51, 70, 159) = 159

長度 5（全部氣球）：
  dp[0][5]: 戳破 index 1, 2, 3, 4（所有原始氣球）
    k=1: dp[0][1] + dp[1][5] + arr[0]*arr[1]*arr[5]
       = 0 + 159 + 1*3*1 = 162
    k=2: dp[0][2] + dp[2][5] + arr[0]*arr[2]*arr[5]
       = 3 + 48 + 1*1*1 = 52
    k=3: dp[0][3] + dp[3][5] + arr[0]*arr[3]*arr[5]
       = 30 + 40 + 1*5*1 = 75
    k=4: dp[0][4] + dp[4][5] + arr[0]*arr[4]*arr[5]
       = 159 + 0 + 1*8*1 = 167
    dp[0][5] = max(162, 52, 75, 167) = 167  ← 答案!

完整 DP 表格：
         0    1    2    3    4    5
    0 [  0 |  0 |  3 | 30 |159 |167 ]
    1 [    |  0 |  0 | 15 |135 |159 ]
    2 [    |    |  0 |  0 | 40 | 48 ]
    3 [    |    |    |  0 |  0 | 40 ]
    4 [    |    |    |    |  0 |  0 ]
    5 [    |    |    |    |    |  0 ]

答案 = dp[0][5] = 167 ✓
```

#### Python 程式碼

```python
def maxCoins(nums: list) -> int:
    arr = [1] + nums + [1]
    n = len(arr)
    dp = [[0] * n for _ in range(n)]

    for length in range(2, n):          # 區間長度 j-i
        for i in range(n - length):
            j = i + length
            for k in range(i + 1, j):   # 最後戳的氣球
                val = dp[i][k] + dp[k][j] + arr[i] * arr[k] * arr[j]
                dp[i][j] = max(dp[i][j], val)

    return dp[0][n - 1]

# Time: O(n^3) | Space: O(n^2)
```

---

## 第七章：比較總結

### 7.1 五種 2D DP 類型一覽

```
┌──────────────┬──────────────────┬──────────────────┬──────────────┐
│     類型      │  dp[i][j] 含義   │    轉移方向        │   經典題目    │
├──────────────┼──────────────────┼──────────────────┼──────────────┤
│ 網格 DP      │ 走到(i,j)的       │ 上方+左方          │ LC 62, 64   │
│              │ 路徑數/最小成本    │ dp[i-1][j],       │              │
│              │                   │ dp[i][j-1]        │              │
├──────────────┼──────────────────┼──────────────────┼──────────────┤
│ 字串 DP      │ 兩字串前i,j字元   │ 對角+上+左         │ LC 1143, 72 │
│              │ 的 LCS/編輯距離   │ dp[i-1][j-1],     │ LC 5        │
│              │                   │ dp[i-1][j],       │              │
│              │                   │ dp[i][j-1]        │              │
├──────────────┼──────────────────┼──────────────────┼──────────────┤
│ 0/1 背包     │ 前i個物品+容量w   │ 上一列             │ LC 416, 494 │
│              │ 的最大價值/可行性  │ dp[i-1][w],       │              │
│              │                   │ dp[i-1][w-wt]     │              │
├──────────────┼──────────────────┼──────────────────┼──────────────┤
│ 完全背包     │ 前i種+容量w       │ 上一列+同一列      │ LC 322, 518 │
│              │ 的最佳解          │ dp[i-1][w],       │              │
│              │                   │ dp[i][w-wt]       │              │
├──────────────┼──────────────────┼──────────────────┼──────────────┤
│ 區間 DP      │ 區間[i,j]的       │ 枚舉分割點k        │ LC 312      │
│              │ 最佳解            │ dp[i][k]+dp[k][j] │              │
└──────────────┴──────────────────┴──────────────────┴──────────────┘
```

### 7.2 0/1 背包 vs 完全背包 -- 迴圈方向（最重要的對比！）

```
=== 0/1 背包 (1D 優化) ===

for i in range(n):                     # 外層: 逐個物品
    for w in range(W, wt[i]-1, -1):    # 內層: 倒序! ←←←
        dp[w] = max(dp[w], dp[w-wt[i]] + val[i])

  倒序原因: 保證 dp[w-wt[i]] 是「不含物品 i」的值
  效果: 每個物品最多用一次

=== 完全背包 (1D 優化) ===

for i in range(n):                     # 外層: 逐種物品
    for w in range(wt[i], W+1):        # 內層: 正序! →→→
        dp[w] = max(dp[w], dp[w-wt[i]] + val[i])

  正序原因: dp[w-wt[i]] 可能「已含物品 i」
  效果: 每種物品可以無限次使用

=== 一句話記住 ===
  0/1 倒序: "回頭看的都是舊的（上一輪的），不會重複拿"
  完全正序: "回頭看的可能是新的（本輪更新的），可以重複拿"
```

### 7.3 如何判斷用哪種 DP？決策樹

```
拿到一道 DP 題，問自己：

Q1: 狀態跟幾個維度有關？
  ├─ 一個 → 1D DP (上一章)
  └─ 兩個 → 繼續往下

Q2: 兩個維度是什麼？
  ├─ (行, 列) = 座標位置 → 網格 DP (LC 62, 64)
  ├─ (字串1位置, 字串2位置) → 字串 DP (LC 1143, 72, 5)
  ├─ (物品編號, 容量/目標) → 背包 DP → Q3
  └─ (區間左端, 區間右端) → 區間 DP (LC 312)

Q3: 背包中每件物品能用幾次？
  ├─ 最多一次 → 0/1 背包 (LC 416, 494)
  └─ 無限次   → 完全背包 (LC 322, 518)
```

### 7.4 Google 面試熱門度排名

```
★★★★★ Edit Distance (LC 72)         — Google 最愛的 Hard DP
★★★★★ Coin Change (LC 322)          — 經典完全背包
★★★★☆ LCS (LC 1143)                 — 字串 DP 入門必考
★★★★☆ Burst Balloons (LC 312)       — 區間 DP 代表題
★★★☆☆ Unique Paths (LC 62)          — 2D DP 入門
★★★☆☆ Partition Equal Subset (LC 416) — 0/1 背包變形
★★★☆☆ Target Sum (LC 494)           — 數學轉化 + 背包
★★★☆☆ Coin Change 2 (LC 518)        — 組合計數
★★☆☆☆ Min Path Sum (LC 64)          — 網格 DP
★★☆☆☆ Longest Palindromic (LC 5)    — DP 或中心擴展
```

### 7.5 常見錯誤與面試提醒

```
錯誤 1: 背包方向搞反
  0/1 背包用正序 → 物品被重複使用，答案錯誤
  完全背包用倒序 → 物品只用一次，答案偏小
  修正: 記住 "0/1 倒序，完全正序"

錯誤 2: Edit Distance 忘記初始化邊界
  dp[i][0] = i (刪除 i 個字元)
  dp[0][j] = j (插入 j 個字元)
  很多人只初始化 dp[0][0] = 0，忘了第一列和第一行

錯誤 3: LCS 的 dp 表格大小錯誤
  dp 應該是 (m+1) x (n+1)，多一列多一行代表空字串
  如果開成 m x n，dp[0][0] 的意思就不對了

錯誤 4: 區間 DP 填表順序錯誤
  必須從短區間填到長區間（不是從左上到右下！）
  因為 dp[i][j] 依賴 dp[i][k] 和 dp[k][j]，而 k 在 i 和 j 之間

錯誤 5: Burst Balloons 沒有加邊界
  不加 [1] 在兩端 → 邊界情況很難處理
  加了邊界後，dp[0][n+1] 就是答案，非常乾淨

錯誤 6: Target Sum 忘記特殊條件
  (target + total) 是奇數 → 無解
  |target| > total → 無解
  不做這兩個檢查會 index out of bounds
```

---

> **本章重點回顧**：
> 1. 網格 DP：`dp[i][j] = f(dp[i-1][j], dp[i][j-1])`，從上方和左方轉移
> 2. 字串 DP：`dp[i][j]` 對比兩個字串的前 i, j 個字元
> 3. 0/1 背包：每件用一次，1D 內層**倒序**
> 4. 完全背包：每件無限次，1D 內層**正序**
> 5. 區間 DP：按區間長度從小到大填表，枚舉分割點
>
> **下一章預告**：`13_Backtracking_教學.md` -- 回溯法，DFS + 剪枝，排列組合子集問題
