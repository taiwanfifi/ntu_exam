# 面試模擬題組：5 回合實戰演練

> **定位**：模擬真實 45 分鐘 Google / NVIDIA coding interview，含完整計時、評分、追問
> **適用對象**：已完成基礎教學（01-17）+ 情境地圖（18-21），準備最終實戰的人
> **語言**：繁體中文解說 + English technical terms
> **使用前提**：每回合獨立，可亂序練習；建議每週完成 2 回合

---

## 目錄

1. [使用方式](#使用方式)
2. [第一回合：基礎能力測試 (Easy → Medium)](#模擬面試-第一回合基礎能力測試)
3. [第二回合：Graph + BFS (Medium)](#模擬面試-第二回合graph--bfs)
4. [第三回合：DP + Binary Search (Medium → Hard)](#模擬面試-第三回合dp--binary-search)
5. [第四回合：Backtracking + Tree (Medium → Hard)](#模擬面試-第四回合backtracking--tree)
6. [第五回合：Google 風格綜合 (Medium → Hard)](#模擬面試-第五回合google-風格綜合)
7. [附錄：自我評分表](#附錄自我評分表)
8. [附錄：面試回答框架 (STAR for Coding)](#附錄面試回答框架)

---

## 使用方式

```
步驟 1：選一個回合
步驟 2：設定計時器（45 分鐘）
步驟 3：只看「題目描述」，不看後面的解析
步驟 4：在白紙或 IDE 上作答（建議先白紙再轉 code）
步驟 5：時間到後，對照「面試官期待」和「完美解答要點」
步驟 6：用「自我評分表」打分，記錄弱項
步驟 7：弱項對應回 01-17 教學檔案複習

面試模擬的黃金法則：
  ┌─────────────────────────────────────────────────────┐
  │  1. 開口說話 — 全程用英文或中文解釋你的思路           │
  │  2. 先問問題 — 花 1-2 分鐘確認 edge cases            │
  │  3. 先說再寫 — 口述 approach 後再寫 code             │
  │  4. 寫完就測 — 用小例子 walk through                 │
  │  5. 分析複雜度 — Time + Space + 為什麼               │
  └─────────────────────────────────────────────────────┘
```

---

## 模擬面試 第一回合：基礎能力測試

> **難度梯度**：Easy → Medium
> **考察重點**：HashMap fundamentals, Tree DFS, 溝通與 edge case 意識
> **總時間**：45 分鐘

### [時間分配]

| 階段 | 時間 | 內容 |
|------|------|------|
| 問題 1 | 15 min | Two Sum (Easy) |
| 問題 2 | 25 min | Diameter of Binary Tree (Medium) |
| 收尾 | 5 min | 問面試官問題 / 複雜度總結 |

---

### 問題 1：Two Sum (LC 1) — 15 分鐘

**題目描述（唸給自己聽）：**

給定一個整數陣列 `nums` 和一個目標值 `target`，找出陣列中和為 `target` 的兩個數的索引。假設每個輸入恰好有一個解，且同一個元素不能使用兩次。

```
Input:  nums = [2, 7, 11, 15], target = 9
Output: [0, 1]
Explanation: nums[0] + nums[1] = 2 + 7 = 9
```

---

**（以下為解析，計時結束後再看）**

**面試官期待的時間軸：**

```
0:00 - 2:00  讀題 + 確認 edge cases
  → "Can nums be empty?"
  → "Are there duplicate values?"
  → "Is there always exactly one solution?"
  → "Can I use the same element twice?"

2:00 - 5:00  提出 approach
  → "Brute force: nested loop, O(n^2) time, O(1) space"
  → "Optimized: HashMap, store complement, O(n) time, O(n) space"
  → "I'll go with the HashMap approach because..."

5:00 - 13:00  寫程式碼
  → 乾淨、有意義的變數名
  → 一次遍歷 (one-pass)

13:00 - 15:00  Walk through + 複雜度
  → 用 [2,7,11,15], target=9 走一次
  → "Time O(n), Space O(n), because we traverse once and HashMap lookup is O(1)"
```

**完美解答：**

```python
def twoSum(nums, target):
    seen = {}  # value -> index
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []  # 題目保證有解，但防禦性程式
```

**關鍵要點：**

| 要點 | 說明 |
|------|------|
| One-pass HashMap | 邊走邊查，不需要兩次遍歷 |
| complement = target - num | 核心轉換：「找兩數之和」→「找 complement 是否存在」 |
| 先查再存 | 避免同一元素用兩次（seen[num] = i 放在 if 後面） |
| Time O(n), Space O(n) | 每個元素最多進出 HashMap 一次 |

**常見扣分：**

```
-2 分：沒問任何 edge case 就開始寫
-3 分：只寫 O(n^2) brute force，沒提出優化
-1 分：寫完沒有 walk through
-1 分：沒分析 Space complexity
-2 分：code 有 bug（例如先存再查，導致自己跟自己配對）
```

---

### 問題 2：Diameter of Binary Tree (LC 543) — 25 分鐘

**題目描述：**

給定一個二元樹的 root，回傳該樹的「直徑」。二元樹的直徑是任意兩個節點之間最長路徑的邊數。這條路徑可能不經過 root。

```
Input:
        1
       / \
      2   3
     / \
    4   5

Output: 3
Explanation: 路徑 4→2→1→3 或 5→2→1→3，長度為 3 條邊
```

---

**面試官期待的時間軸：**

```
0:00 - 3:00  讀題 + 畫圖 + 確認
  → 畫出 example tree
  → "直徑是邊數，不是節點數"
  → "直徑可能不經過 root" ← 這句話是關鍵
  → "如果 root 是 null？回傳 0"
  → "如果只有一個節點？回傳 0（沒有邊）"

3:00 - 8:00  提出 approach
  → "觀察：任一條路徑一定有一個『最高點』（LCA）"
  → "經過某節點的最長路徑 = 左子樹深度 + 右子樹深度"
  → "所以我需要 DFS 計算每個節點的深度，同時追蹤全域最大 diameter"
  → 畫出遞迴過程

8:00 - 20:00  寫程式碼
  → 清楚定義 helper function 的回傳值
  → 用 nonlocal / self / 陣列來追蹤 max_diameter

20:00 - 25:00  測試 + 追問
  → Walk through example
  → 回答追問
```

**完美解答：**

```python
def diameterOfBinaryTree(root):
    max_diameter = 0

    def depth(node):
        nonlocal max_diameter
        if not node:
            return 0
        left_depth = depth(node.left)
        right_depth = depth(node.right)
        # 經過此節點的路徑長度 = 左深度 + 右深度
        max_diameter = max(max_diameter, left_depth + right_depth)
        # 回傳此節點的深度（給父節點用）
        return 1 + max(left_depth, right_depth)

    depth(root)
    return max_diameter
```

**關鍵要點：**

| 要點 | 說明 |
|------|------|
| DFS postorder | 先算子樹，再算自己 |
| depth 回傳深度 | 但「順便」更新全域 max_diameter |
| left + right = 經過此節點的路徑 | 核心洞察 |
| Time O(n), Space O(h) | h = 樹高，最壞 O(n) (skewed tree) |

**常見追問與回答：**

```
Q1: "如果要回傳實際路徑（不只是長度）呢？"
A1: "在更新 max_diameter 時，同時記錄對應的起點和終點節點。
     或者用一個 list 記錄 path，在 DFS 過程中追蹤。"

Q2: "如果是 N-ary tree 呢？"
A2: "取所有子樹中最大的兩個深度相加。
     sort children depths → top_two = sorted[-1] + sorted[-2]"

Q3: "Space 可以更好嗎？"
A3: "DFS 遞迴本身就需要 O(h) stack space。
     可以用 iterative postorder 但空間仍是 O(h)，所以無法改善。"
```

**常見扣分：**

```
-3 分：沒意識到直徑可能不經過 root
-2 分：depth 函式回傳值混淆（回傳 diameter 還是 depth？）
-1 分：忘記處理 null node base case
-2 分：沒用全域變數追蹤 max，只在最後回傳 root 的左+右
```

---

## 模擬面試 第二回合：Graph + BFS

> **難度梯度**：Medium + Medium
> **考察重點**：Multi-source BFS, Topological Sort, Graph 建模能力
> **總時間**：45 分鐘

### [時間分配]

| 階段 | 時間 | 內容 |
|------|------|------|
| 問題 1 | 20 min | Rotting Oranges (Multi-source BFS) |
| 問題 2 | 20 min | Course Schedule (Topological Sort) |
| 收尾 | 5 min | 總結 + 提問 |

---

### 問題 1：Rotting Oranges (LC 994) — 20 分鐘

**題目描述：**

給定一個 `m x n` 的 grid：
- `0` = 空格
- `1` = 新鮮橘子
- `2` = 腐爛橘子

每一分鐘，腐爛橘子會使上下左右相鄰的新鮮橘子腐爛。回傳使所有橘子都腐爛的最少分鐘數。如果不可能全部腐爛，回傳 `-1`。

```
Input:  [[2,1,1],
         [1,1,0],
         [0,1,1]]
Output: 4
```

---

**面試官期待的時間軸：**

```
0:00 - 3:00  讀題 + 確認
  → "多個腐爛橘子同時開始擴散" ← 關鍵：multi-source BFS
  → "如果沒有新鮮橘子？回傳 0"
  → "如果有新鮮橘子但無法被感染？回傳 -1"
  → "grid 可以是空的嗎？"

3:00 - 7:00  提出 approach
  → "這是 multi-source BFS：所有腐爛橘子同時作為起點"
  → "每一層 BFS = 1 分鐘"
  → "最後檢查是否還有新鮮橘子"
  → 口述 algorithm 步驟

7:00 - 17:00  寫程式碼

17:00 - 20:00  Walk through + 複雜度
```

**完美解答：**

```python
from collections import deque

def orangesRotting(grid):
    rows, cols = len(grid), len(grid[0])
    queue = deque()
    fresh_count = 0

    # Step 1: 收集所有腐爛橘子 + 計算新鮮橘子數量
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:
                queue.append((r, c))
            elif grid[r][c] == 1:
                fresh_count += 1

    # Edge case: 沒有新鮮橘子
    if fresh_count == 0:
        return 0

    # Step 2: Multi-source BFS
    minutes = 0
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    while queue and fresh_count > 0:
        minutes += 1
        for _ in range(len(queue)):  # 處理當前層
            r, c = queue.popleft()
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:
                    grid[nr][nc] = 2
                    fresh_count -= 1
                    queue.append((nr, nc))

    return minutes if fresh_count == 0 else -1
```

**關鍵要點：**

| 要點 | 說明 |
|------|------|
| Multi-source BFS | 所有爛橘子同時入隊，不是一個一個來 |
| 逐層處理 = 時間推進 | `for _ in range(len(queue))` 確保一層一層 |
| fresh_count 追蹤 | 避免最後再掃一次 grid |
| Time O(m*n), Space O(m*n) | 每個 cell 最多入隊一次 |

**常見追問：**

```
Q1: "為什麼用 BFS 而不是 DFS？"
A1: "BFS 自然地按層（時間）擴展。DFS 會深入一條路徑，
     無法正確模擬『同時擴散』的行為。"

Q2: "如果橘子有不同的腐爛速度呢？"
A2: "用 priority queue (min-heap) 取代普通 queue，
     變成 Dijkstra-like 的處理。"

Q3: "能否不修改原始 grid？"
A3: "用一個 visited set 取代直接修改 grid[r][c] = 2。
     Space 多用 O(m*n) 但不改原始資料。"
```

**常見扣分：**

```
-3 分：用 DFS 而不是 BFS（無法正確模擬同時擴散）
-2 分：沒有 multi-source（一個一個腐爛橘子分別做 BFS）
-2 分：忘記處理 "所有橘子都已經腐爛" 的 edge case
-1 分：逐層計數邏輯錯誤（多算或少算一層）
-1 分：忘記檢查最後是否還有 fresh oranges
```

---

### 問題 2：Course Schedule (LC 207) — 20 分鐘

**題目描述：**

共有 `numCourses` 門課程（編號 0 到 numCourses-1）。給定一個先修條件列表 `prerequisites`，其中 `prerequisites[i] = [a, b]` 表示要修課 a 必須先修課 b。判斷是否可以完成所有課程。

```
Input:  numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: true
Explanation: 修課順序 0→1→2→3 或 0→2→1→3

Input:  numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: 循環依賴，無法完成
```

---

**面試官期待的時間軸：**

```
0:00 - 3:00  讀題 + 建模
  → "這是一個 directed graph，課程是節點，先修是邊"
  → "能否完成所有課程 = 圖中有沒有 cycle"
  → "有 cycle → false，無 cycle → true"
  → 畫出 example 的圖

3:00 - 7:00  提出 approach
  → "方法 1: BFS Topological Sort (Kahn's Algorithm)"
  → "方法 2: DFS cycle detection"
  → "我用 Kahn's，因為更直觀且能產出拓撲排序"
  → 口述步驟：建 graph + 算 in-degree + BFS

7:00 - 17:00  寫程式碼

17:00 - 20:00  Walk through + 複雜度
```

**完美解答（Kahn's Algorithm / BFS Topological Sort）：**

```python
from collections import deque

def canFinish(numCourses, prerequisites):
    # Step 1: 建圖 + 計算 in-degree
    graph = [[] for _ in range(numCourses)]
    in_degree = [0] * numCourses

    for course, prereq in prerequisites:
        graph[prereq].append(course)
        in_degree[course] += 1

    # Step 2: 所有 in-degree=0 的課程入隊
    queue = deque()
    for i in range(numCourses):
        if in_degree[i] == 0:
            queue.append(i)

    # Step 3: BFS — 每處理一個節點，減少鄰居的 in-degree
    completed = 0
    while queue:
        course = queue.popleft()
        completed += 1
        for next_course in graph[course]:
            in_degree[next_course] -= 1
            if in_degree[next_course] == 0:
                queue.append(next_course)

    # Step 4: 如果所有課程都被處理，就沒有 cycle
    return completed == numCourses
```

**關鍵要點：**

| 要點 | 說明 |
|------|------|
| 問題轉換 | 「能否完成所有課程」= 「有向圖是否有 cycle」= 「能否做 topological sort」 |
| Kahn's Algorithm | BFS：從 in-degree=0 開始，逐步剝離 |
| completed == numCourses | 如果有 cycle，cycle 中的節點 in-degree 永遠不會變 0 |
| Time O(V+E), Space O(V+E) | V = numCourses, E = len(prerequisites) |

**常見追問：**

```
Q1: "如果要回傳一個合法的修課順序呢？" (LC 210)
A1: "在 BFS 中把每次 popleft 的 course 加入 result list。
     最後 len(result) == numCourses 就回傳 result。"

Q2: "用 DFS 怎麼做？"
A2: "三色標記法：white=未訪問, gray=處理中, black=已完成。
     如果 DFS 碰到 gray 節點，代表有 back edge → cycle。"

Q3: "如果有多個合法順序，怎麼找字典序最小的？"
A3: "把 queue 換成 min-heap (priority queue)，每次取最小編號。"
```

**常見扣分：**

```
-3 分：沒有把問題轉換成 graph / cycle detection
-2 分：建圖方向搞反（prerequisite 的邊方向錯誤）
-2 分：忘記處理 numCourses > 0 但 prerequisites 為空的情況（應回傳 true）
-1 分：用了 DFS 但沒有處理三種狀態（只用 visited set，無法偵測 cycle）
```

---

## 模擬面試 第三回合：DP + Binary Search

> **難度梯度**：Medium → Hard
> **考察重點**：DP 狀態定義, Binary Search on Answer, 優化思維
> **總時間**：45 分鐘

### [時間分配]

| 階段 | 時間 | 內容 |
|------|------|------|
| 問題 1 | 20 min | Coin Change (DP) |
| 問題 2 | 20 min | Split Array Largest Sum (Binary Search on Answer) |
| 收尾 | 5 min | 總結 + 提問 |

---

### 問題 1：Coin Change (LC 322) — 20 分鐘

**題目描述：**

給定不同面額的硬幣陣列 `coins` 和一個總金額 `amount`。回傳湊出該金額所需的最少硬幣數量。如果無法湊出，回傳 `-1`。每種硬幣可以無限使用。

```
Input:  coins = [1, 5, 11], amount = 15
Output: 3
Explanation: 5 + 5 + 5 = 15（不是 11 + 1 + 1 + 1 + 1 = 15，那需要 5 枚）
```

---

**面試官期待的時間軸：**

```
0:00 - 3:00  讀題 + 確認
  → "每種硬幣可以用無限次" ← Unbounded Knapsack
  → "amount = 0 時回傳 0"
  → "coins 可以是空的嗎？"
  → "面額一定是正整數嗎？"

3:00 - 7:00  提出 approach
  → "Greedy 不行：[1,5,11] amount=15，greedy 選 11 需要 5 枚，但 5*3=3 枚"
  → "DP: dp[i] = 湊出金額 i 所需的最少硬幣數"
  → "轉移方程：dp[i] = min(dp[i - coin] + 1) for each coin"
  → "Base case: dp[0] = 0，其餘初始化為 infinity"

7:00 - 17:00  寫程式碼

17:00 - 20:00  Walk through + 複雜度
```

**完美解答：**

```python
def coinChange(coins, amount):
    # dp[i] = 湊出金額 i 的最少硬幣數
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # base case: 湊出 0 需要 0 枚

    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i and dp[i - coin] != float('inf'):
                dp[i] = min(dp[i], dp[i - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1
```

**關鍵要點：**

| 要點 | 說明 |
|------|------|
| Greedy 反例 | [1,5,11] amount=15 → Greedy 失敗，必須用 DP |
| dp 定義要清楚 | dp[i] = 「湊出金額 i 的最少硬幣數」，先說這句話再寫 code |
| 初始化 inf | 代表「目前不可達」，只有 dp[0]=0 是已知的 |
| Time O(amount * len(coins)) | 兩層迴圈 |
| Space O(amount) | 一維 DP 陣列 |

**常見追問：**

```
Q1: "如果要回傳用了哪些硬幣呢？"
A1: "多一個 parent[] 陣列，parent[i] = 用了哪個 coin 到達 i。
     最後從 parent[amount] 回溯。"

Q2: "如果每種硬幣只能用一次呢？"
A2: "變成 0-1 Knapsack，內層迴圈要反向遍歷。"

Q3: "能用 BFS 解嗎？"
A3: "可以！把每個金額當節點，每種 coin 是一條邊。
     BFS 從 0 出發找到 amount 的最短路徑。
     但 DP 更直觀且常數更小。"
```

**常見扣分：**

```
-3 分：用了 Greedy 且沒發現不適用
-2 分：dp 定義不清楚，說不出 dp[i] 代表什麼
-1 分：忘記初始化為 inf（或用 -1 但後續邏輯沒處理好）
-1 分：忘記最後的 -1 回傳（amount 不可達時）
```

---

### 問題 2：Split Array Largest Sum (LC 410) — 20 分鐘

**題目描述：**

給定一個非負整數陣列 `nums` 和一個整數 `k`，將 `nums` 分成 `k` 個非空連續子陣列。使得這些子陣列的最大和最小化。回傳最小化後的最大和。

```
Input:  nums = [7,2,5,10,8], k = 2
Output: 18
Explanation: 分成 [7,2,5] 和 [10,8]，子陣列和分別為 14 和 18，最大值 18。
             這是所有分法中，最大子陣列和的最小值。
```

---

**面試官期待的時間軸：**

```
0:00 - 4:00  讀題 + 確認
  → "連續子陣列" ← 不能重新排序
  → "非空" ← 每段至少一個元素
  → "最小化最大值" ← Binary Search on Answer 的信號詞！
  → 確認 k <= len(nums)

4:00 - 9:00  提出 approach
  → "看到 '最小化最大值'，想到 Binary Search on Answer"
  → "答案範圍：[max(nums), sum(nums)]"
  → "對每個候選答案 mid，用 Greedy 檢查能否在 k 段內完成"
  → "如果可以 → 試更小，不行 → 試更大"

9:00 - 18:00  寫程式碼

18:00 - 20:00  Walk through + 複雜度
```

**完美解答：**

```python
def splitArray(nums, k):
    def can_split(max_sum):
        """用 greedy 檢查：子陣列和上限為 max_sum 時，能否分成 <= k 段"""
        count = 1       # 至少 1 段
        current_sum = 0
        for num in nums:
            if current_sum + num > max_sum:
                count += 1       # 開新一段
                current_sum = num
            else:
                current_sum += num
        return count <= k

    # Binary Search on Answer
    lo = max(nums)    # 最小可能：每段至少要放得下最大的那個數
    hi = sum(nums)    # 最大可能：所有數放同一段

    while lo < hi:
        mid = (lo + hi) // 2
        if can_split(mid):
            hi = mid       # mid 可行，試更小
        else:
            lo = mid + 1   # mid 不可行，需要更大

    return lo
```

**關鍵要點：**

| 要點 | 說明 |
|------|------|
| 辨識信號 | 「最小化最大值」→ Binary Search on Answer |
| 搜尋空間 | [max(nums), sum(nums)] — 不是在 index 上搜尋！ |
| Greedy check | 貪心地塞：能塞就塞，塞不下就開新段 |
| 單調性 | max_sum 越大 → 需要的段數越少（可行性單調） |
| Time O(n * log(sum)) | Binary Search O(log(sum-max)) * check O(n) |
| Space O(1) | 只用常數空間 |

**常見追問：**

```
Q1: "能用 DP 解嗎？"
A1: "可以。dp[i][j] = 前 i 個元素分成 j 段的最小最大和。
     但 Time O(n^2 * k)，比 Binary Search 的 O(n log sum) 慢很多。"

Q2: "如果 nums 中有負數呢？"
A2: "Binary Search on Answer 不適用，因為單調性不成立。
     （子陣列和上限更大不代表需要更少段數）
     此時只能用 DP。"

Q3: "can_split 為什麼用 Greedy 是正確的？"
A3: "因為我們要判斷的是『能否在 k 段內完成』，不是求最優分法。
     Greedy 地盡量塞，如果這樣都超過 k 段，那更保守的策略只會更多段。"
```

**常見扣分：**

```
-3 分：沒有辨識出 Binary Search on Answer pattern
-2 分：搜尋範圍錯誤（lo 應為 max(nums) 而非 0）
-2 分：can_split 的 Greedy 邏輯有 off-by-one（count 初始值）
-1 分：Binary Search 的終止條件或更新邏輯錯誤
```

---

## 模擬面試 第四回合：Backtracking + Tree

> **難度梯度**：Medium → Hard
> **考察重點**：Backtracking 模板, Tree DFS with global state, 遞迴思維
> **總時間**：45 分鐘

### [時間分配]

| 階段 | 時間 | 內容 |
|------|------|------|
| 問題 1 | 15 min | Subsets (Backtracking 基礎) |
| 問題 2 | 25 min | Binary Tree Maximum Path Sum (Hard Tree DFS) |
| 收尾 | 5 min | 總結 + 提問 |

---

### 問題 1：Subsets (LC 78) — 15 分鐘

**題目描述：**

給定一個不含重複元素的整數陣列 `nums`，回傳所有可能的子集（power set）。答案中不能有重複的子集。

```
Input:  nums = [1, 2, 3]
Output: [[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]
```

---

**面試官期待的時間軸：**

```
0:00 - 2:00  讀題 + 確認
  → "nums 不含重複" ← 不需要去重邏輯
  → "空集合也算一個子集"
  → "順序重要嗎？" → [1,2] 和 [2,1] 算同一個

2:00 - 5:00  提出 approach
  → "Backtracking：每個元素有兩個選擇 — 選 or 不選"
  → "用 start index 避免重複"
  → "每次遞迴都把當前 path 加入 result"
  → 畫出 decision tree

5:00 - 12:00  寫程式碼

12:00 - 15:00  Walk through + 複雜度
```

**完美解答：**

```python
def subsets(nums):
    result = []

    def backtrack(start, path):
        result.append(path[:])  # 加入當前子集的拷貝
        for i in range(start, len(nums)):
            path.append(nums[i])      # 選擇
            backtrack(i + 1, path)     # 探索（從 i+1 開始避免重複）
            path.pop()                 # 撤銷選擇

    backtrack(0, [])
    return result
```

**關鍵要點：**

| 要點 | 說明 |
|------|------|
| 每層都加入 result | 不只是 leaf，每個節點都是一個合法子集 |
| start index 遞增 | `backtrack(i+1, path)` 確保不回頭選已選過的 |
| path[:] 拷貝 | 必須 copy，否則 result 裡全部指向同一個 list |
| Time O(n * 2^n) | 共 2^n 個子集，每個子集最長 n |
| Space O(n) | 遞迴深度 n（不計 result） |

**常見追問：**

```
Q1: "如果 nums 有重複元素呢？" (LC 90)
A1: "先排序，然後在同層跳過重複：
     if i > start and nums[i] == nums[i-1]: continue"

Q2: "能不能用 iterative / bit manipulation 做？"
A2: "可以。用 0 到 2^n-1 的二進位表示：
     第 j 位為 1 表示選 nums[j]。"

Q3: "如果要找大小恰好為 k 的子集呢？"
A3: "加一個條件：只在 len(path) == k 時加入 result，
     且 len(path) == k 時 return（剪枝）。"
```

**常見扣分：**

```
-2 分：忘記 path[:] 拷貝（result 裡全是空 list）
-2 分：不會用 start index 去重
-1 分：沒有畫 decision tree 就直接寫
```

---

### 問題 2：Binary Tree Maximum Path Sum (LC 124) — 25 分鐘

**題目描述：**

給定一個二元樹，找出任意節點到任意節點的路徑中，節點值總和最大的路徑。路徑至少包含一個節點，且不一定經過 root。

```
Input:
       -10
       /  \
      9    20
          /  \
         15   7

Output: 42
Explanation: 路徑 15 → 20 → 7，和 = 15 + 20 + 7 = 42
```

---

**面試官期待的時間軸：**

```
0:00 - 4:00  讀題 + 理解
  → "路徑可以不經過 root" ← 跟 Diameter 一樣的概念
  → "節點值可以是負數！" ← 關鍵
  → "路徑至少一個節點" ← 不能回傳空路徑
  → "路徑不能分叉" ← 最多經過一個『轉折點』

4:00 - 9:00  提出 approach
  → "跟 LC 543 Diameter 很像！"
  → "DFS：每個節點計算『以我為轉折點的最大路徑和』"
  → "以某節點為轉折點：node.val + 左邊最大貢獻 + 右邊最大貢獻"
  → "但回傳給父節點時，只能選左或右（路徑不能分叉）"
  → "負數貢獻取 0（不選比選更好）"
  → 全域變數追蹤 max

9:00 - 22:00  寫程式碼（這題邏輯較複雜，給多點時間）

22:00 - 25:00  Walk through + 追問
```

**完美解答：**

```python
def maxPathSum(root):
    max_sum = float('-inf')  # 全域最大值，初始為負無窮

    def max_gain(node):
        """回傳以 node 為端點的最大貢獻值（單邊，不分叉）"""
        nonlocal max_sum
        if not node:
            return 0

        # 左右子樹的最大貢獻（負數取 0 = 不選）
        left_gain = max(max_gain(node.left), 0)
        right_gain = max(max_gain(node.right), 0)

        # 以 node 為「轉折點」的路徑和
        path_through_node = node.val + left_gain + right_gain
        max_sum = max(max_sum, path_through_node)

        # 回傳給父節點：只能走一邊（路徑不分叉）
        return node.val + max(left_gain, right_gain)

    max_gain(root)
    return max_sum
```

**關鍵要點：**

| 要點 | 說明 |
|------|------|
| 兩個角色 | max_gain 回傳「單邊最大」，但內部更新「雙邊經過此節點的最大」 |
| max(gain, 0) | 負數子樹不要選，貢獻取 0 |
| 路徑不分叉 | 回傳時只選 max(left, right)，但更新 max_sum 時用 left + right |
| 初始值 -inf | 因為所有節點可能都是負數 |
| Time O(n), Space O(h) | 每個節點訪問一次 |

**常見追問：**

```
Q1: "為什麼 max_sum 初始化為 -inf 而不是 0？"
A1: "因為所有節點可能都是負數。例如 tree = [-3]，答案是 -3。
     如果初始化為 0，會錯誤回傳 0。"

Q2: "如果要回傳實際路徑呢？"
A2: "在 max_gain 中，當更新 max_sum 時，同時記錄對應的
     起始和終止節點。最後用另一次 DFS 重建路徑。"

Q3: "跟 LC 543 的差別在哪？"
A3: "結構完全一樣，差別只有兩點：
     (1) 這題算『值的和』不是『邊的數量』
     (2) 需要 max(gain,0) 處理負數子樹"
```

**常見扣分：**

```
-3 分：沒有意識到「回傳」和「更新」是不同的（回傳單邊，更新雙邊）
-2 分：忘記 max(gain, 0) 處理負數
-2 分：max_sum 初始化為 0 而不是 -inf
-1 分：說不出跟 LC 543 的關聯
```

---

## 模擬面試 第五回合：Google 風格綜合

> **難度梯度**：Medium → Hard
> **考察重點**：Sliding Window with HashMap, Monotonic Stack, 極限優化
> **總時間**：45 分鐘

### [時間分配]

| 階段 | 時間 | 內容 |
|------|------|------|
| 問題 1 | 15 min | Minimum Window Substring (Sliding Window) |
| 問題 2 | 25 min | Largest Rectangle in Histogram (Monotonic Stack) |
| 收尾 | 5 min | 總結 + 提問 |

---

### 問題 1：Minimum Window Substring (LC 76) — 15 分鐘

**題目描述：**

給定兩個字串 `s` 和 `t`，找出 `s` 中包含 `t` 所有字元的最短子字串。如果不存在，回傳空字串。`t` 中的重複字元必須在子字串中至少出現相同次數。

```
Input:  s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: "BANC" 包含 A, B, C 各至少一次，且是最短的
```

---

**面試官期待的時間軸：**

```
0:00 - 2:00  讀題 + 確認
  → "t 有重複字元嗎？" → 有，例如 t = "AAB" 需要兩個 A
  → "s 和 t 只有英文字母嗎？"
  → "沒有合法窗口時回傳空字串"

2:00 - 5:00  提出 approach
  → "Sliding Window + HashMap (frequency count)"
  → "先擴右邊直到包含所有字元，再縮左邊找最短"
  → "用 formed / required 追蹤是否滿足條件"

5:00 - 13:00  寫程式碼

13:00 - 15:00  Walk through + 複雜度
```

**完美解答：**

```python
from collections import Counter

def minWindow(s, t):
    if not s or not t:
        return ""

    t_count = Counter(t)
    required = len(t_count)   # 需要滿足的不同字元數
    formed = 0                # 已經滿足的不同字元數
    window_count = {}

    left = 0
    result = (float('inf'), 0, 0)  # (length, left, right)

    for right in range(len(s)):
        # 擴展右邊
        char = s[right]
        window_count[char] = window_count.get(char, 0) + 1

        if char in t_count and window_count[char] == t_count[char]:
            formed += 1

        # 嘗試縮小左邊
        while formed == required:
            # 更新答案
            if right - left + 1 < result[0]:
                result = (right - left + 1, left, right)

            # 縮左邊
            left_char = s[left]
            window_count[left_char] -= 1
            if left_char in t_count and window_count[left_char] < t_count[left_char]:
                formed -= 1
            left += 1

    return "" if result[0] == float('inf') else s[result[1]:result[2] + 1]
```

**關鍵要點：**

| 要點 | 說明 |
|------|------|
| formed vs required | 追蹤「已滿足幾種字元」而不是逐個比較 HashMap |
| 擴右縮左 | 右指針一直走，左指針在滿足條件時才縮 |
| == 觸發 formed++ | 只在剛好達到要求的瞬間 +1，不是每次 >= |
| < 觸發 formed-- | 只在剛好低於要求的瞬間 -1 |
| Time O(|s| + |t|) | 每個字元最多被左右指針各訪問一次 |
| Space O(|s| + |t|) | 兩個 HashMap |

**常見追問：**

```
Q1: "能否優化到真正的 O(|s|)？"
A1: "預處理 s，只保留在 t 中出現的字元及其 index。
     在 filtered 陣列上做 Sliding Window，跳過無關字元。"

Q2: "如果要找所有最短的子字串（不只一個）呢？"
A2: "把 result 從一個值改成一個 list，
     長度相同時都加入。"
```

**常見扣分：**

```
-3 分：沒用 Sliding Window（用了 brute force O(n^2) 或 O(n^3)）
-2 分：formed/required 追蹤邏輯錯誤
-2 分：縮左邊的條件判斷有 bug
-1 分：忘記處理 t 比 s 長的 edge case
```

---

### 問題 2：Largest Rectangle in Histogram (LC 84) — 25 分鐘

**題目描述：**

給定一個整數陣列 `heights`，其中 `heights[i]` 代表直方圖中第 `i` 個柱子的高度，柱子寬度為 1。找出直方圖中最大的矩形面積。

```
Input:  heights = [2,1,5,6,2,3]
Output: 10
Explanation: 高度 5 和 6 的兩個柱子組成寬 2 高 5 的矩形，面積 = 10

     6
   5 █
   █ █
   █ █   3
 2 █ █ 2 █
 █ █ █ █ █
 █ █ █ █ █
 ─────────
```

---

**面試官期待的時間軸：**

```
0:00 - 4:00  讀題 + 分析
  → 畫出 histogram
  → "每個矩形由最矮的那根柱子的高度決定"
  → "Brute force: 對每個柱子，向左右擴展找到能延伸的範圍 → O(n^2)"
  → "需要更快的方法"

4:00 - 10:00  提出 approach
  → "Monotonic Stack（遞增棧）"
  → "維護一個遞增的 stack，碰到比棧頂矮的柱子時結算"
  → "結算：棧頂柱子的高度 × 能延伸的寬度"
  → "寬度 = right_boundary - left_boundary - 1"
  → 畫出 stack 的變化過程

10:00 - 22:00  寫程式碼（這題 index 計算容易出錯）

22:00 - 25:00  Walk through + 複雜度
```

**完美解答：**

```python
def largestRectangleArea(heights):
    stack = []  # 存 index，維護遞增高度
    max_area = 0

    for i in range(len(heights)):
        # 當前柱子比棧頂矮 → 棧頂可以結算
        while stack and heights[i] < heights[stack[-1]]:
            h = heights[stack.pop()]
            # 寬度：左邊界是新棧頂（或 -1），右邊界是 i
            w = i - stack[-1] - 1 if stack else i
            max_area = max(max_area, h * w)
        stack.append(i)

    # 處理棧中剩餘的柱子（它們的右邊界是 len(heights)）
    while stack:
        h = heights[stack.pop()]
        w = len(heights) - stack[-1] - 1 if stack else len(heights)
        max_area = max(max_area, h * w)

    return max_area
```

**關鍵要點：**

| 要點 | 說明 |
|------|------|
| 核心問題 | 對每個柱子，找到「左邊第一個比它矮」和「右邊第一個比它矮」的位置 |
| Monotonic Stack | 維護遞增棧，碰到更矮的就觸發結算 |
| 寬度計算 | w = right_boundary - left_boundary - 1（兩邊都不包含） |
| Sentinel 技巧 | 加 [0] 在首尾，避免特殊處理「棧空」和「遍歷結束後結算」 |
| Time O(n) | 每個 index 最多 push 和 pop 各一次 |
| Space O(n) | Stack 最多存 n 個 index |

**常見追問：**

```
Q1: "能用 Divide and Conquer 嗎？"
A1: "可以。找最矮的柱子把問題分成左右兩半 + 橫跨最矮柱子的矩形。
     Average O(n log n)，但 worst case O(n^2)。
     用 Segment Tree 找 range minimum 可以穩定 O(n log n)。"

Q2: "這題跟 LC 85 Maximal Rectangle 有什麼關係？"
A2: "LC 85 是 2D 矩陣中最大矩形。可以逐行計算 histogram 高度，
     然後對每行呼叫本題的 O(n) 算法。總共 O(rows * cols)。"

Q3: "為什麼用 Monotonic Stack 而不是普通 Stack？"
A3: "普通 Stack 沒有遞增性質，無法直接知道左邊界。
     Monotonic Stack 的遞增性保證棧頂下面那個元素就是左邊界。"
```

**常見扣分：**

```
-3 分：用 O(n^2) brute force 沒有優化到 O(n)
-3 分：不知道 Monotonic Stack pattern
-2 分：寬度計算 off-by-one（最常見的 bug）
-2 分：忘記處理遍歷結束後 stack 中剩餘的柱子
-1 分：walk through 時邏輯跟 code 不一致
```

---

## 附錄：自我評分表

### 每回合通用評分表

完成每個回合後，用此表格自我評估（每題分別打分）：

| 維度 | 1分 (差) | 2分 (待改善) | 3分 (普通) | 4分 (良好) | 5分 (優秀) |
|------|---------|------------|---------|---------|---------|
| **問題理解** | 沒問 edge cases，直接開寫 | 問了 1 個 edge case | 問了 2-3 個相關問題 | 主動確認大部分邊界 | 全面確認 + 畫圖釐清 |
| **算法選擇** | 只有暴力解，沒優化 | 有優化想法但方向錯 | 想到正確方向但不最優 | 最優解但無法解釋 why | 最優解 + 清楚解釋為何其他方法不行 |
| **程式碼品質** | 有 bug 且無法 debug | 有 bug 但能修復 | 可運行但不夠簡潔 | 正確且簡潔 | 乾淨 + 有意義的變數名 + 防禦性程式 |
| **溝通能力** | 沉默寫 code | 寫完才解釋 | 偶爾說明在做什麼 | 大部分時間在解釋 | 全程 think aloud + 主動說 trade-off |
| **複雜度分析** | 完全沒分析 | 只說 Time | Time + Space | Time + Space + 正確 | T + S + 為什麼 + 能否更好 |
| **時間控制** | 超時 >50% | 超時 20-50% | 剛好或略超 | 在時間內完成 | 提前完成 + 有餘裕處理追問 |

### 分數解讀

```
每題滿分 30 分（6 個維度 × 5 分），每回合兩題共 60 分。

55-60 分：面試 strong hire — 你已經準備好了
45-54 分：面試 hire — 穩定通過
35-44 分：面試 borderline — 需要加強弱項
25-34 分：面試 no hire — 需要更多練習
< 25 分：需要回去複習基礎教學
```

### 弱項對應複習表

| 弱項 | 對應教學檔案 |
|------|-------------|
| HashMap 不熟 | 03_HashMap_HashSet_教學.md |
| Tree DFS 不熟 | 07_Tree_DFS_教學.md |
| BFS 不熟 | 08_Tree_BFS_BST_教學.md, 09_Graph_DFS_BFS_教學.md |
| Graph / TopSort 不熟 | 10_Graph_Advanced_教學.md |
| DP 不熟 | 11_DP_1D_教學.md, 12_DP_2D_Knapsack_教學.md |
| Binary Search 不熟 | 06_Binary_Search_教學.md |
| Backtracking 不熟 | 13_Backtracking_教學.md |
| Sliding Window 不熟 | 02_Sliding_Window_教學.md |
| Stack / Monotonic Stack 不熟 | 04_Stack_Queue_教學.md |
| 情境判斷不熟 | 18-20 情境解題地圖系列 |
| 算法選擇邏輯不清 | 19_情境解題地圖_Level2_怎麼選算法.md |

---

## 附錄：面試回答框架

### UMPIRE 框架（每題都用）

```
U - Understand：讀題 + 問 edge cases（1-3 分鐘）
M - Match：辨識 pattern，對應到已知算法（1-2 分鐘）
P - Plan：口述完整的解題步驟（2-3 分鐘）
I - Implement：寫程式碼（主要時間）
R - Review：用例子 walk through（1-2 分鐘）
E - Evaluate：分析 Time + Space complexity（1 分鐘）
```

### 五回合涵蓋的 Pattern 總覽

```
回合 1: HashMap (Two Sum) + Tree DFS (Diameter)
回合 2: Multi-source BFS (Rotting Oranges) + Topological Sort (Course Schedule)
回合 3: 1D DP (Coin Change) + Binary Search on Answer (Split Array)
回合 4: Backtracking (Subsets) + Tree DFS Global State (Max Path Sum)
回合 5: Sliding Window + HashMap (Min Window) + Monotonic Stack (Histogram)

涵蓋 10 個核心 pattern，難度從 Easy 到 Hard 完整覆蓋。
如果每回合都能拿到 45+ 分，你的面試準備已經非常充分。
```

---

> **最後提醒**：面試不只考演算法。溝通、問問題、承認不知道（然後一步步推導）、
> 保持冷靜 — 這些 soft skills 往往是 hire 和 no hire 的分界線。
> 練習時請「說出聲音」，模擬真實面試的對話感。
