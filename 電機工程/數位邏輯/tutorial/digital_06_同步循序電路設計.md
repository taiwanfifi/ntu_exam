# 數位邏輯教學講義 第六章：同步循序電路設計

---

## 🔰 **本章基礎觀念（零基礎必讀）**

上一章學了正反器（記憶元件），這一章要把正反器和組合邏輯結合起來，
設計出能「按步驟做事」的電路——**同步循序電路 (Synchronous Sequential Circuit)**。
計數器、交通燈控制器、CPU 的控制單元，都是同步循序電路。

本章最重要的是**設計流程**：從問題描述一步步走到最終電路。
這套流程在業界面試（聯發科/瑞昱/聯詠）中是必考題。

> **學完本章，你應該能做到：**
> 1. 分析已有的循序電路（電路→狀態圖）
> 2. 完整執行設計流程（問題→狀態圖→狀態表→編碼→激勵方程→電路）
> 3. 區分 Mealy Machine 和 Moore Machine
> 4. 設計各種計數器

---

## 關鍵術語表

| 中文 | 英文 | 白話解釋 | 例子 |
|------|------|----------|------|
| 同步循序電路 | Synchronous Sequential Circuit | 所有 FF 用同一個時脈驅動 | 同步計數器 |
| 狀態 | State | 電路目前的記憶內容 | 用 FF 的 Q 值表示 |
| 狀態圖 | State Diagram | 用圓圈(狀態)和箭頭(轉移)表示行為 | 泡泡圖 |
| 狀態表 | State Table | 用表格列出每個狀態在各輸入下的轉移 | 類似真值表 |
| 狀態方程 | State Equation | 描述下一狀態的布林方程 | Q+=f(Q,input) |
| 狀態編碼 | State Assignment | 用二進位編碼表示每個狀態 | S0=00,S1=01... |
| 激勵方程 | Excitation Equation | FF 的輸入信號方程 | D₁=..., D₀=... |
| 輸出方程 | Output Equation | 輸出信號的方程 | Z = f(Q) 或 f(Q,X) |
| Mealy 機 | Mealy Machine | 輸出取決於現態+輸入 | 輸出標在箭頭上 |
| Moore 機 | Moore Machine | 輸出只取決於現態 | 輸出標在圓圈裡 |
| 等價狀態 | Equivalent States | 對所有輸入，輸出和下一狀態都相同 | 可以合併 |

---

## 一、同步循序電路的結構

```
                    ┌──────────────────────┐
輸入 X ────────────→│                      │──────→ 輸出 Z
                    │    組合邏輯電路       │
         ┌────────→│                      │
         │          └──────────┬───────────┘
         │                     │
         │              激勵信號 D
         │                     │
         │          ┌──────────▼───────────┐
         │          │                      │
         └──────────│     Flip-Flops       │
     現態 Q         │    (狀態記憶)         │
                    └──────────────────────┘
                              ↑
                            CLK
```

三個組成部分：
1. **組合邏輯**：根據現態 Q 和輸入 X，計算下一狀態的激勵信號和輸出
2. **Flip-Flops**：儲存狀態
3. **時脈 (CLK)**：同步所有 FF

---

## 二、分析流程

已有電路 → 理解它做什麼

```
電路圖 → 激勵方程 → 狀態方程 → 狀態表 → 狀態圖
```

### 【分析例題】

```
電路：一個 D FF，輸入 D = X ⊕ Q，輸出 Z = Q
```

Step 1：激勵方程
```
D = X ⊕ Q
```

Step 2：狀態方程（D FF 的 Q+ = D）
```
Q+ = X ⊕ Q
```

Step 3：狀態表

| 現態 Q | X=0 | X=1 |
|--------|-----|-----|
| 0 | 0⊕0=0 | 1⊕0=1 |
| 1 | 0⊕1=1 | 1⊕1=0 |

加上輸出 Z=Q：

| 現態 Q | X=0: Q+/Z | X=1: Q+/Z |
|--------|-----------|-----------|
| 0 | 0/0 | 1/0 |
| 1 | 1/1 | 0/1 |

Step 4：狀態圖
```
         X=0/Z=0         X=1/Z=1
     ┌──────────┐    ┌──────────┐
     │          ▼    │          ▼
     │  ┌───┐        │  ┌───┐
     └──│S0 │──X=1──→└──│S1 │
        │Q=0│←──X=0─────│Q=1│
        └───┘    Z=1     └───┘
          Z=0              Z=1
```

**功能**：這是一個 T Flip-Flop 的行為！X=1 時切換，X=0 時保持。

---

## 三、設計流程（★本章重點！）

### 完整步驟

```
1. 問題描述（文字/需求）
      ↓
2. 畫狀態圖 (State Diagram)
      ↓
3. 建立狀態表 (State Table)
      ↓
4. 狀態化簡（合併等價狀態）
      ↓
5. 狀態編碼 (State Assignment)
      ↓
6. 建立激勵表 → 用 K-map 化簡 → 激勵方程
      ↓
7. 寫出輸出方程
      ↓
8. 畫電路圖
```

---

## 四、完整設計範例

### 【設計例題 1】設計一個 Mod-3 上數計數器

**問題描述**：設計一個計數器，輸出依序為 0→1→2→0→1→2→...

#### Step 1：問題描述
- 3 個狀態：S0(值=0), S1(值=1), S2(值=2)
- 無外部輸入（每個 CLK 自動+1）
- 輸出就是計數值

#### Step 2：狀態圖
```
    ┌───┐         ┌───┐         ┌───┐
    │S0 │────────→│S1 │────────→│S2 │
    │ 00│←────────│ 01│         │ 10│
    └───┘         └───┘         └───┘
      ↑                            │
      └────────────────────────────┘
```

#### Step 3：狀態表

| 現態 | 下一狀態 | 輸出 |
|------|---------|------|
| S0 | S1 | 00 |
| S1 | S2 | 01 |
| S2 | S0 | 10 |

#### Step 4：狀態化簡
只有 3 個狀態，無法化簡。

#### Step 5：狀態編碼
需要 ⌈log₂3⌉ = 2 個 FF

| 狀態 | Q₁Q₀ |
|------|-------|
| S0 | 00 |
| S1 | 01 |
| S2 | 10 |
| (未用) | 11 |

#### Step 6：建立編碼後的狀態表，求激勵方程

用 D FF：

| Q₁ | Q₀ | Q₁⁺ | Q₀⁺ | D₁ | D₀ |
|----|-----|------|------|-----|-----|
| 0 | 0 | 0 | 1 | 0 | 1 |
| 0 | 1 | 1 | 0 | 1 | 0 |
| 1 | 0 | 0 | 0 | 0 | 0 |
| 1 | 1 | X | X | X | X |

（Q₁Q₀=11 是未使用狀態 → Don't Care）

D₁ 的 K-map：
```
      Q₀
      0   1
Q₁ 0| 0 | 1 |
   1| 0 | X |

D₁ = Q₁'Q₀
```

D₀ 的 K-map：
```
      Q₀
      0   1
Q₁ 0| 1 | 0 |
   1| 0 | X |

D₀ = Q₁'Q₀'
```

#### Step 7：輸出方程
輸出就是 Q₁Q₀ 本身（二進位計數值）。

#### Step 8：電路

```
          ┌──────────────────────┐
          │                      │
Q₁'Q₀ ──→│ D₁    [D FF₁] Q₁ ──→├──→ 輸出高位元
          │                      │
Q₁'Q₀'──→│ D₀    [D FF₀] Q₀ ──→├──→ 輸出低位元
          │                      │
          └──────────────────────┘
                    ↑
                   CLK
```

---

### 【設計例題 2】設計一個序列偵測器（簡化版）

**問題描述**：偵測輸入序列 "10"，偵測到時輸出 Z=1（Moore Machine）。

#### Step 2：狀態圖（Moore Machine）

```
狀態定義：
S0 = 初始/尚未偵測到有用的前綴
S1 = 已收到 "1"
S2 = 已收到 "10" → 輸出 Z=1

          X=0            X=0
     ┌──────────┐   ┌──────────┐
     ▼          │   ▼          │
   ┌─────┐      │ ┌─────┐     │  ┌─────┐
   │ S0  │      │ │ S1  │     │  │ S2  │
   │ Z=0 │──X=1→│ │ Z=0 │──X=0→│ │ Z=1 │
   └─────┘       └─────┘       └─────┘
     ↑  ↑          │  X=1        │
     │  │          │  ┌──────────┘
     │  │          └──┘ (自環)     X=1 → S1
     │  └──── X=0 ─── S2
     └──── X=1 ──── S2？
```

讓我重新畫清楚：

```
      X=0              X=1(自環)
  ┌─────────┐      ┌─────────┐
  ▼         │      ▼         │
┌─────┐     │    ┌─────┐     │    ┌─────┐
│ S0  │─X=1→│    │ S1  │─X=1→│    │ S2  │
│ Z=0 │     └───→│ Z=0 │     └───→│ Z=1 │
└─────┘          └─────┘          └─────┘
  ↑                 │                │
  │               X=0→S2           X=0→S0
  │                                  │
  └──────────── X=1 → S1 ───────────┘

等等，重新思考：
S2(Z=1) 偵測到 "10" 後：
  - 下一個是 0 → 回到 S0（"0" 不是 "1" 的開頭）
  - 下一個是 1 → 去 S1（新的 "1" 可能是下一次 "10" 的開頭）
```

#### Step 3：狀態表（Moore Machine）

| 現態 | X=0 | X=1 | Z |
|------|-----|-----|---|
| S0 | S0 | S1 | 0 |
| S1 | S2 | S1 | 0 |
| S2 | S0 | S1 | 1 |

#### Step 5：狀態編碼

| 狀態 | Q₁Q₀ |
|------|-------|
| S0 | 00 |
| S1 | 01 |
| S2 | 10 |

#### Step 6：激勵表（使用 D FF）

| Q₁ | Q₀ | X | Q₁⁺ | Q₀⁺ | D₁ | D₀ |
|----|-----|---|------|------|-----|-----|
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 0 | 1 | 0 | 1 |
| 0 | 1 | 0 | 1 | 0 | 1 | 0 |
| 0 | 1 | 1 | 0 | 1 | 0 | 1 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 1 | 0 | 1 | 0 | 1 |
| 1 | 1 | 0 | X | X | X | X |
| 1 | 1 | 1 | X | X | X | X |

D₁ 的 K-map：
```
          Q₀X
        00  01  11  10
Q₁  0 | 0 | 0 | 0 | 1 |
    1 | 0 | 0 | X | X |

D₁ = Q₁'Q₀X'
```

D₀ 的 K-map：
```
          Q₀X
        00  01  11  10
Q₁  0 | 0 | 1 | 1 | 0 |
    1 | 0 | 1 | X | X |

D₀ = X
```

#### Step 7：輸出方程
```
Z = Q₁Q₀'  （只有 S2=10 時 Z=1）

但因為 Q₁Q₀=10 → Z = Q₁（因為 Q₁=1 只出現在 S2）
更精確：Z = Q₁（利用 11 是 Don't Care）
```

#### 結果
```
D₁ = Q₁'Q₀X'
D₀ = X
Z  = Q₁
```

---

### 【設計例題 3】用 JK FF 設計 Mod-4 上/下數計數器

**問題描述**：
- 輸入 M：M=0 上數，M=1 下數
- 計數序列：上數 00→01→10→11→00...，下數 00→11→10→01→00...

#### 狀態表

| Q₁ | Q₀ | M=0 (上數) Q₁⁺Q₀⁺ | M=1 (下數) Q₁⁺Q₀⁺ |
|----|-----|---------------------|---------------------|
| 0 | 0 | 01 | 11 |
| 0 | 1 | 10 | 00 |
| 1 | 0 | 11 | 01 |
| 1 | 1 | 00 | 10 |

#### 展開激勵表（用 JK FF）

| Q₁ | Q₀ | M | Q₁⁺ | Q₀⁺ | J₁ | K₁ | J₀ | K₀ |
|----|----|---|------|------|----|----|----|----|
| 0 | 0 | 0 | 0 | 1 | 0 | X | 1 | X |
| 0 | 0 | 1 | 1 | 1 | 1 | X | 1 | X |
| 0 | 1 | 0 | 1 | 0 | 1 | X | X | 1 |
| 0 | 1 | 1 | 0 | 0 | 0 | X | X | 1 |
| 1 | 0 | 0 | 1 | 1 | X | 0 | 1 | X |
| 1 | 0 | 1 | 0 | 1 | X | 1 | 1 | X |
| 1 | 1 | 0 | 0 | 0 | X | 1 | X | 1 |
| 1 | 1 | 1 | 1 | 0 | X | 0 | X | 1 |

JK FF 的激勵表回顧：
- 0→0: J=0, K=X
- 0→1: J=1, K=X
- 1→0: J=X, K=1
- 1→1: J=X, K=0

#### K-map 化簡

J₁ 的 K-map（變數 Q₁, Q₀, M）：
```
          Q₀M
        00  01  11  10
Q₁  0 | 0 | 1 | 0 | 1 |
    1 | X | X | X | X |

J₁ = Q₀'M + Q₀M' = Q₀ ⊕ M
```

K₁ 的 K-map：
```
          Q₀M
        00  01  11  10
Q₁  0 | X | X | X | X |
    1 | 0 | 1 | 0 | 1 |

K₁ = Q₀'M + Q₀M' = Q₀ ⊕ M
```

J₀ 的 K-map：
```
          Q₀M
        00  01  11  10
Q₁  0 | 1 | 1 | X | X |
    1 | 1 | 1 | X | X |

J₀ = 1
```

K₀ 的 K-map：
```
          Q₀M
        00  01  11  10
Q₁  0 | X | X | 1 | 1 |
    1 | X | X | 1 | 1 |

K₀ = 1
```

#### 結果
```
J₁ = K₁ = Q₀ ⊕ M
J₀ = K₀ = 1     （Q₀ 永遠 toggle → 最低位每次都切換 ✓）
```

> **觀察**：Q₀ 的 J=K=1 表示每個 CLK 都 toggle，這正是計數器最低位的行為。
> Q₁ 的 toggle 取決於 Q₀ 和 M 的關係，實現上/下數控制。

---

## 五、計數器設計

### 5.1 二進位上數計數器 (Binary Up Counter)

用 T FF 最直覺：

```
T₀ = 1          （最低位每次 toggle）
T₁ = Q₀         （Q₀=1 時 toggle）
T₂ = Q₁Q₀       （Q₁=Q₀=1 時 toggle）
T₃ = Q₂Q₁Q₀     （Q₂=Q₁=Q₀=1 時 toggle）
```

**一般化**：Tᵢ = Q(i-1) · Q(i-2) · ... · Q₀

### 5.2 任意 Mod-N 計數器

**方法**：正常的二進位計數器 + 偵測到 N 時重設為 0。

例：Mod-6 計數器（數 0~5）

用 3-bit 計數器，當 Q₂Q₁Q₀ = 110 (=6) 時，用非同步 Reset 歸零。

```
Reset = Q₂ · Q₁  （110 時觸發，不需要 Q₀ 因為不會到 111）
```

> 注意：這種方法會讓「110」短暫出現（一個閘延遲），叫做「過渡狀態 (Transient State)」。

---

## 六、Mealy Machine vs Moore Machine

### 6.1 Moore Machine

```
輸出只取決於現態：Z = f(Q)

狀態圖表示法：
┌──────────┐
│ 狀態名稱  │
│ Z = 輸出  │  ← 輸出寫在圓圈裡
└──────────┘
    │
    │ 輸入條件    ← 箭頭上只有輸入
    ▼
```

**特性**：
- 輸出和輸入無直接關聯
- 輸出在整個狀態期間保持不變（較穩定）
- 通常需要**較多狀態**

### 6.2 Mealy Machine

```
輸出取決於現態+輸入：Z = f(Q, X)

狀態圖表示法：
┌──────────┐
│ 狀態名稱  │  ← 圓圈裡只有狀態
└──────────┘
    │
    │ 輸入/輸出   ← 箭頭上有輸入和輸出
    ▼
```

**特性**：
- 輸出可以在時脈週期中間就改變（輸入一變就變）
- 通常需要**較少狀態**
- 輸出可能有毛刺(Glitch)

### 6.3 比較

| | Moore Machine | Mealy Machine |
|--|--------------|---------------|
| 輸出取決於 | 只有現態 | 現態 + 輸入 |
| 輸出寫在 | 狀態圓圈裡 | 轉移箭頭上 |
| 狀態數量 | 通常較多 | 通常較少 |
| 輸出穩定性 | 較穩定 | 可能有 Glitch |
| 輸出反應速度 | 晚一個 CLK | 同一個 CLK 就反應 |
| 設計偏好 | 較安全 | 較省資源 |

### 6.4 Moore ↔ Mealy 互轉

任何 Mealy Machine 都可以轉成等效的 Moore Machine（可能多一些狀態），反之亦然。

**Mealy → Moore**：如果某個狀態的不同入邊(incoming edge)有不同輸出，就需要拆分狀態。

---

## 七、題型鑑別表

| 題目關鍵字 | 該用什麼方法 |
|-----------|-------------|
| 「分析此循序電路」 | 電路→激勵方程→狀態方程→狀態表→狀態圖 |
| 「設計計數器」 | 狀態圖→狀態表→編碼→激勵方程→電路 |
| 「設計序列偵測器」 | 定義狀態(前綴)→狀態圖→後續步驟 |
| 「用 JK FF 設計」 | 激勵表用 JK 的（很多 Don't Care） |
| 「用 D FF 設計」 | D = Q⁺，最直覺 |
| 「求最大時脈頻率」 | fmax = 1/(tcq + tcomb + tsu) |
| 「Mealy vs Moore」 | Moore 輸出看狀態，Mealy 輸出看狀態+輸入 |
| 「狀態化簡」 | 找等價狀態合併（下章詳述） |

---

## ✅ 自我檢測

### Q1：同步循序電路的三個組成部分是什麼？

<details>
<summary>點擊查看答案</summary>

1. **組合邏輯電路**：計算下一狀態(激勵信號)和輸出
2. **Flip-Flops**：儲存現在的狀態
3. **時脈 (CLK)**：同步所有 FF 的更新時機

結構：輸入 + 現態 → 組合邏輯 → 下一狀態(送回 FF) + 輸出
</details>

### Q2：設計同步循序電路的完整步驟（按順序列出）。

<details>
<summary>點擊查看答案</summary>

1. 問題描述
2. 畫狀態圖 (State Diagram)
3. 建立狀態表 (State Table)
4. 狀態化簡（合併等價狀態）
5. 狀態編碼 (State Assignment)
6. 建立激勵表 → K-map 化簡 → 激勵方程
7. 寫出輸出方程
8. 畫電路圖
</details>

### Q3：Moore Machine 和 Mealy Machine 的輸出分別取決於什麼？在狀態圖上怎麼表示？

<details>
<summary>點擊查看答案</summary>

**Moore Machine**：
- 輸出只取決於**現態** → Z = f(Q)
- 狀態圖：輸出寫在**狀態圓圈裡**
- 例：圓圈裡寫「S0/Z=0」

**Mealy Machine**：
- 輸出取決於**現態 + 輸入** → Z = f(Q, X)
- 狀態圖：輸出寫在**轉移箭頭上**
- 例：箭頭標記「X=1/Z=0」

Mealy 通常少一些狀態但輸出可能有 Glitch；
Moore 多一些狀態但輸出較穩定。
</details>

### Q4：用 T FF 設計 4-bit 二進位上數計數器，寫出每個 FF 的 T 輸入方程。

<details>
<summary>點擊查看答案</summary>

```
T₀ = 1              （最低位每個 CLK 都切換）
T₁ = Q₀             （Q₀=1 時切換）
T₂ = Q₁ · Q₀        （Q₁=Q₀=1 時切換）
T₃ = Q₂ · Q₁ · Q₀   （Q₂=Q₁=Q₀=1 時切換）
```

計數序列：0000 → 0001 → 0010 → ... → 1111 → 0000

**規律**：第 i 位在所有更低位都是 1 時切換。
</details>

### Q5：某循序電路有 5 個狀態，至少需要幾個 FF？未使用的狀態編碼怎麼處理？

<details>
<summary>點擊查看答案</summary>

至少需要 ⌈log₂5⌉ = **3 個 FF**（3 bit 可以表示 8 個狀態）。

未使用的 3 個狀態（8-5=3）有兩種處理方式：

1. **當 Don't Care**：激勵方程化簡時可以利用，但要確認這些未使用狀態
   不會形成死鎖（如果意外進入，要能回到有效狀態）

2. **安全設計**：明確規定未使用狀態的下一狀態（通常導向初始狀態），
   避免系統進入無法恢復的狀態。
</details>

---

> **下一章預告**：本章學了設計的基本流程，下一章將用更多實際應用來練習——序列偵測器、交通燈、自動販賣機，還有狀態化簡和編碼策略的進階技巧！
