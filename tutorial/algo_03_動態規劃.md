# 演算法教學 03：動態規劃 (Dynamic Programming)

> 台大演算法課教學講義
> DP 是演算法課的重中之重。如果你只能精通一個主題，那就精通 DP 吧。它考試必考、面試必問、實務上也極度常用。

---

## 1. DP 四步驟教學

動態規劃的精髓在於：**把一個看起來要指數時間的問題，透過「記住子問題的答案」降到多項式時間。**

每次做 DP 題，都請你按這四個步驟走：

### Step 1：定義子問題（最關鍵！）

這是 DP 最難的一步。你需要定義一個函數 dp[...] ，使得：
- 原問題可以用 dp[...] 的某個值表達
- dp[...] 之間存在遞迴關係

**子問題定義得好，後面三步自然就出來了。定義得不好，後面都卡住。**

### Step 2：寫遞迴式（含 base case）

根據子問題的定義，寫出：
$$
dp[\cdots] = \text{某個關於更小子問題的表達式}
$$

別忘了定義 base case（最小的子問題，直接知道答案）。

### Step 3：決定計算順序（bottom-up 填表）

遞迴式告訴你 dp[i] 依賴哪些 dp[j]。計算順序必須確保：**在算 dp[i] 的時候，它依賴的所有 dp[j] 都已經算好了。**

通常就是從小到大填表。

### Step 4：回溯找解

dp 表格算完後，我們知道「最優值是多少」，但通常還要回溯找出「最優解長什麼樣」。

方法：在填表時額外記錄「每個 dp[i] 是從哪個子問題來的」（choice 陣列），然後從最終答案往回追。

---

## 2. 如何定義好的子問題？

### 2.1 常見的子問題定義模式

以下是四種最常見的模式，覆蓋了 80% 以上的 DP 題：

#### 模式 A：dp[i] = 「前 i 個元素」的最優解

適用場景：線性結構（陣列、序列），從左到右處理。

範例：
- LIS：dp[i] = 以 A[i] **結尾**的最長遞增子序列長度
- Coin Change：dp[i] = 湊出金額 i 的最少硬幣數
- House Robber：dp[i] = 考慮前 i 間房子能搶到的最大金額

#### 模式 B：dp[i][j] = 「區間 [i..j]」的最優解

適用場景：需要考慮區間的問題，通常是「把東西合併或切割」。

範例：
- Matrix Chain Multiplication：dp[i][j] = 計算矩陣 $A_i \cdots A_j$ 乘積的最少純量乘法次數
- Optimal BST：dp[i][j] = 包含 key i 到 key j 的最佳 BST 成本
- 回文問題：dp[i][j] = 子字串 s[i..j] 是否為回文 / 需要多少次插入

**填表方向：** 按區間長度從小到大（先算短區間，再算長區間）。

#### 模式 C：dp[i][j] = 「用前 i 個物品，限制為 j」的最優解

適用場景：有「容量」或「預算」限制的選擇問題。

範例：
- 0/1 Knapsack：dp[i][w] = 用前 i 個物品、背包容量 w 的最大價值
- Subset Sum：dp[i][s] = 用前 i 個數字能否湊出和為 s

#### 模式 D：dp[i][j] = 「X[1..i] 和 Y[1..j]」的最優解

適用場景：兩個序列的比較。

範例：
- LCS：dp[i][j] = X[1..i] 和 Y[1..j] 的最長公共子序列長度
- Edit Distance：dp[i][j] = 把 X[1..i] 變成 Y[1..j] 的最少操作次數

### 2.2 定義子問題的技巧

1. **先想暴力解，找出「決策」在哪裡。** 每個決策點就是遞迴式分支的地方。

2. **子問題的參數 = 描述「還剩多少」或「已經做到哪」的狀態。**

3. **如果一維不夠，就加維度。** 很多題一開始你可能覺得 dp[i] 就夠了，但推不出遞迴式，這時要考慮 dp[i][j] 甚至 dp[i][j][k]。

4. **子問題的數量 = 表格大小 = 時間複雜度的下界。** 所以子問題不能太多。

---

## 3. Optimal Substructure 的正式定義

### 3.1 定義

一個問題具有 **optimal substructure（最優子結構）** 的性質，意思是：

> 問題的最優解**包含了**子問題的最優解。

更精確地說：假設原問題的最優解是 S*，而 S* 的某一部分恰好對應一個子問題 P'，那麼 S* 在 P' 上的部分一定也是 P' 的最優解。

### 3.2 如何驗證？

標準的驗證方式是**剪貼論證（cut-and-paste argument）：**

假設 S* 是原問題的最優解，但 S* 在子問題 P' 上的部分不是 P' 的最優解。那麼把 P' 的部分「剪掉」，換成 P' 的真正最優解「貼上去」，應該會得到一個更好的整體解。但這跟 S* 是最優解矛盾！

因此 S* 在 P' 上的部分**必然是** P' 的最優解。

### 3.3 注意：不是所有問題都有 Optimal Substructure

**反例：最長簡單路徑**

從 a 到 c 的最長簡單路徑，不一定包含從 a 到 b 的最長簡單路徑。因為「簡單路徑」有「不重複」的限制，子問題之間不獨立。

---

## 4. Top-down vs Bottom-up

### 4.1 Top-down（記憶化搜尋 Memoization）

```
dp = 空的 hash table

SOLVE(problem):
    if problem in dp:
        return dp[problem]    // 已經算過，直接回傳

    if problem is base case:
        dp[problem] = base_value
        return base_value

    result = 計算 recurrence（呼叫更小的 SOLVE）
    dp[problem] = result
    return result
```

**優點：**
- 只算**需要的**子問題（有些子問題可能永遠不會被觸及）
- 遞迴式直接寫成程式碼，不需要想計算順序

**缺點：**
- 遞迴呼叫有 overhead（函數呼叫堆疊）
- 可能 stack overflow（深度太深時）

### 4.2 Bottom-up（製表法 Tabulation）

```
// 建立 dp 表格
dp = 適當大小的陣列

// 填 base case
dp[base cases] = base_values

// 按正確順序填表
for i = ... (從小到大):
    dp[i] = 計算 recurrence using dp[smaller cases]

return dp[goal]
```

**優點：**
- 沒有遞迴 overhead
- 通常比較快（常數比較小）
- 不會 stack overflow

**缺點：**
- 要自己想清楚計算順序
- 會算**所有**子問題，即使有些用不到

### 4.3 該選哪個？

一般來說，**考試寫 bottom-up**（比較好分析時間複雜度），**實作時如果子問題空間很稀疏，用 top-down**。

---

## 5. 經典 DP 問題

### 5.1 0/1 Knapsack（0/1 背包問題）

#### 問題定義

有 n 個物品，第 i 個物品重量 $w_i$、價值 $v_i$。背包容量 W。每個物品最多選一次。求最大總價值。

#### Step 1：定義子問題

$$dp[i][w] = \text{只考慮前 i 個物品、背包容量為 w 時的最大價值}$$

#### Step 2：遞迴式

對於第 i 個物品，有兩個選擇：

- **不選第 i 個物品：** $dp[i][w] = dp[i-1][w]$
- **選第 i 個物品（前提：$w_i \leq w$）：** $dp[i][w] = dp[i-1][w-w_i] + v_i$

取較大的：

$$
dp[i][w] = \begin{cases} dp[i-1][w] & \text{if } w_i > w \\ \max(dp[i-1][w],\; dp[i-1][w-w_i] + v_i) & \text{if } w_i \leq w \end{cases}
$$

**Base case：** $dp[0][w] = 0$ 對所有 $w$（沒有物品可選，價值為 0）。

#### Step 3：計算順序

外層 i 從 1 到 n，內層 w 從 0 到 W。

#### 虛擬碼

```
KNAPSACK(n, W, w[], v[]):
    // 初始化
    for w = 0 to W:
        dp[0][w] = 0

    // 填表
    for i = 1 to n:
        for w = 0 to W:
            dp[i][w] = dp[i-1][w]          // 不選第 i 個
            if w[i] <= w:
                dp[i][w] = max(dp[i][w], dp[i-1][w - w[i]] + v[i])  // 選第 i 個

    return dp[n][W]
```

#### Step-by-step 填表範例

物品：

| 物品 | 重量 w | 價值 v |
|------|--------|--------|
| 1    | 2      | 3      |
| 2    | 3      | 4      |
| 3    | 4      | 5      |
| 4    | 5      | 6      |

背包容量 W = 5。

填表：

```
       w=  0   1   2   3   4   5
i=0:       0   0   0   0   0   0
i=1(w=2,v=3):
           0   0   3   3   3   3
           w=0: 不夠放
           w=1: 不夠放
           w=2: max(0, 0+3)=3
           w=3: max(0, 0+3)=3
           w=4: max(0, 0+3)=3
           w=5: max(0, 0+3)=3

i=2(w=3,v=4):
           0   0   3   4   4   7
           w=0: 不夠放
           w=1: 不夠放
           w=2: 不夠放(w=3>2)，dp=3
           w=3: max(3, dp[1][0]+4)=max(3, 4)=4
           w=4: max(3, dp[1][1]+4)=max(3, 4)=4
           w=5: max(3, dp[1][2]+4)=max(3, 3+4)=7

i=3(w=4,v=5):
           0   0   3   4   5   7
           w=0~3: 不夠放，照抄上面
           w=4: max(4, dp[2][0]+5)=max(4, 5)=5
           w=5: max(7, dp[2][1]+5)=max(7, 5)=7

i=4(w=5,v=6):
           0   0   3   4   5   7
           w=0~4: 不夠放，照抄上面
           w=5: max(7, dp[3][0]+6)=max(7, 6)=7
```

**答：最大價值 = dp[4][5] = 7。**

**回溯找解：**
- dp[4][5] = 7 = dp[3][5]，沒選物品 4
- dp[3][5] = 7 = dp[2][5]，沒選物品 3
- dp[2][5] = 7 ≠ dp[1][5] = 3，選了物品 2！剩餘容量 5-3=2
- dp[1][2] = 3 ≠ dp[0][2] = 0，選了物品 1！

最優解：選物品 1 和物品 2，重量 = 2+3 = 5，價值 = 3+4 = 7。 ✓

**時間複雜度：** $O(nW)$（注意：這是 pseudo-polynomial！因為 W 是數值大小，不是輸入位元數。）

**空間複雜度：** $O(nW)$，可用滾動陣列優化到 $O(W)$。

---

### 5.2 LCS (Longest Common Subsequence)

#### 問題定義

給定兩個序列 X = $x_1 x_2 \cdots x_m$ 和 Y = $y_1 y_2 \cdots y_n$，求最長公共子序列的長度。

子序列不需要連續，但要保持原始順序。

#### Step 1：定義子問題

$$dp[i][j] = X[1..i] \text{ 和 } Y[1..j] \text{ 的 LCS 長度}$$

#### Step 2：遞迴式

$$
dp[i][j] = \begin{cases} 0 & \text{if } i = 0 \text{ or } j = 0 \\ dp[i-1][j-1] + 1 & \text{if } x_i = y_j \\ \max(dp[i-1][j],\; dp[i][j-1]) & \text{if } x_i \neq y_j \end{cases}
$$

**直覺：**
- 如果 $x_i = y_j$，這個字元一定在 LCS 裡，長度 +1
- 如果 $x_i \neq y_j$，要嘛不用 $x_i$，要嘛不用 $y_j$，取較大的

#### 虛擬碼

```
LCS(X, Y):
    m = |X|, n = |Y|

    // Base case
    for i = 0 to m: dp[i][0] = 0
    for j = 0 to n: dp[0][j] = 0

    // 填表
    for i = 1 to m:
        for j = 1 to n:
            if X[i] == Y[j]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]
```

#### Step-by-step 填表範例

X = "ABCBDAB", Y = "BDCABA"

```
       ""  B  D  C  A  B  A
   ""   0  0  0  0  0  0  0
    A   0  0  0  0  1  1  1
    B   0  1  1  1  1  2  2
    C   0  1  1  2  2  2  2
    B   0  1  1  2  2  3  3
    D   0  1  2  2  2  3  3
    A   0  1  2  2  3  3  4
    B   0  1  2  2  3  4  4
```

逐步解說幾個關鍵格子：

- dp[1][4]：X[1]='A' = Y[4]='A' → dp[0][3]+1 = 0+1 = 1
- dp[2][1]：X[2]='B' = Y[1]='B' → dp[1][0]+1 = 0+1 = 1
- dp[2][5]：X[2]='B' = Y[5]='B' → dp[1][4]+1 = 1+1 = 2
- dp[4][5]：X[4]='B' = Y[5]='B' → dp[3][4]+1 = 2+1 = 3
- dp[6][4]：X[6]='A' = Y[4]='A' → dp[5][3]+1 = 2+1 = 3
- dp[7][5]：X[7]='B' = Y[5]='B' → dp[6][4]+1 = 3+1 = 4

**答：LCS 長度 = dp[7][6] = 4。**

**回溯找 LCS：**
- dp[7][6]=4, X[7]='B'≠Y[6]='A', dp[7][5]=4=dp[7][6]，往左
- dp[7][5]=4, X[7]='B'=Y[5]='B', 取！往左上。記錄 'B'。到 dp[6][4]
- dp[6][4]=3, X[6]='A'=Y[4]='A', 取！往左上。記錄 'A'。到 dp[5][3]
- dp[5][3]=2, X[5]='D'≠Y[3]='C', dp[4][3]=2=dp[5][3]，往上
- dp[4][3]=2, X[4]='B'≠Y[3]='C', dp[3][3]=2=dp[4][3]，往上
- dp[3][3]=2, X[3]='C'=Y[3]='C', 取！往左上。記錄 'C'。到 dp[2][2]
- dp[2][2]=1, X[2]='B'≠Y[2]='D', dp[1][2]=0, dp[2][1]=1，往左
- dp[2][1]=1, X[2]='B'=Y[1]='B', 取！往左上。記錄 'B'。到 dp[1][0]
- dp[1][0]=0，結束

LCS = "BCAB"（反轉記錄順序）。 ✓

**時間複雜度：** $O(mn)$
**空間複雜度：** $O(mn)$，可用滾動陣列優化到 $O(\min(m,n))$。

---

### 5.3 LIS (Longest Increasing Subsequence)

#### 問題定義

給定序列 A[1..n]，求最長（嚴格）遞增子序列的長度。

#### 方法一：$O(n^2)$ DP

**子問題：** dp[i] = 以 A[i] **結尾**的 LIS 長度

**遞迴式：**
$$dp[i] = 1 + \max_{j < i,\; A[j] < A[i]} dp[j]$$

（如果沒有這樣的 j，dp[i] = 1。）

**最終答案：** $\max_{i=1}^{n} dp[i]$

##### 虛擬碼

```
LIS-QUADRATIC(A):
    n = |A|
    dp = array of size n, all initialized to 1

    for i = 1 to n:
        for j = 1 to i-1:
            if A[j] < A[i]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp[1..n])
```

##### 範例

A = [10, 9, 2, 5, 3, 7, 101, 18]

```
i=1: A[1]=10, 沒有 j < 1     → dp[1] = 1
i=2: A[2]=9,  9<10? No        → dp[2] = 1
i=3: A[3]=2,  2<10? No, 2<9? No → dp[3] = 1
i=4: A[4]=5,  5>2 ✓ → dp[4] = max(1, dp[3]+1) = 2
i=5: A[5]=3,  3>2 ✓ → dp[5] = max(1, dp[3]+1) = 2
i=6: A[6]=7,  7>2 ✓, 7>5 ✓, 7>3 ✓ → dp[6] = max(1, dp[3]+1, dp[4]+1, dp[5]+1) = 3
i=7: A[7]=101, 比所有都大 → dp[7] = max(..., dp[6]+1) = 4
i=8: A[8]=18, 18>2, 18>5, 18>3, 18>7 → dp[8] = max(dp[3]+1, dp[4]+1, dp[5]+1, dp[6]+1) = 4

答：max(dp) = 4。一個 LIS 是 [2, 5, 7, 101] 或 [2, 3, 7, 101] 或 [2, 5, 7, 18] 等。
```

#### 方法二：$O(n \log n)$ 的 Patience Sorting

**核心想法：** 維護一個陣列 tails[]，其中 tails[k] = 目前所有長度為 k+1 的遞增子序列中，結尾元素最小的那個。

**關鍵性質：** tails[] 一定是遞增的！（所以可以用二分搜尋。）

**演算法：**

對每個 A[i]：
- 如果 A[i] 大於 tails 的最後一個元素，直接 append（LIS 可以延長）
- 否則，用二分搜尋找到 tails 中**第一個 ≥ A[i] 的位置**，替換它

tails[] 的**長度**就是 LIS 的長度（注意 tails 本身不一定是 LIS）。

##### 虛擬碼

```
LIS-NLOGN(A):
    tails = empty array

    for each x in A:
        if tails is empty or x > tails.last():
            tails.append(x)
        else:
            pos = binary_search(tails, x)   // 找第一個 >= x 的位置
            tails[pos] = x

    return len(tails)
```

##### 範例

A = [10, 9, 2, 5, 3, 7, 101, 18]

```
處理 10:  tails = [10]
處理 9:   9 < 10, 替換 tails[0] → tails = [9]
處理 2:   2 < 9, 替換 tails[0] → tails = [2]
處理 5:   5 > 2, append → tails = [2, 5]
處理 3:   3 < 5, 替換 tails[1] → tails = [2, 3]
處理 7:   7 > 3, append → tails = [2, 3, 7]
處理 101: 101 > 7, append → tails = [2, 3, 7, 101]
處理 18:  18 < 101, 替換 tails[3] → tails = [2, 3, 7, 18]

答：len(tails) = 4 ✓
```

**注意：** tails = [2, 3, 7, 18] 不一定是一個 LIS！它只是記錄了每個長度的「最小結尾」。但長度確實是 4。

**時間複雜度：** $O(n \log n)$（每個元素一次二分搜尋）。

---

### 5.4 Edit Distance（編輯距離）

#### 問題定義

給定兩個字串 X 和 Y，求把 X 變成 Y 所需的最少操作次數。允許的操作：
1. Insert（插入一個字元）
2. Delete（刪除一個字元）
3. Replace（替換一個字元）

#### Step 1：定義子問題

$$dp[i][j] = \text{把 } X[1..i] \text{ 變成 } Y[1..j] \text{ 的最少操作次數}$$

#### Step 2：遞迴式

$$
dp[i][j] = \begin{cases} j & \text{if } i = 0 \text{（插入 j 個字元）} \\ i & \text{if } j = 0 \text{（刪除 i 個字元）} \\ dp[i-1][j-1] & \text{if } X[i] = Y[j] \text{（不需操作）} \\ 1 + \min\begin{cases} dp[i-1][j] & \text{(Delete)} \\ dp[i][j-1] & \text{(Insert)} \\ dp[i-1][j-1] & \text{(Replace)} \end{cases} & \text{if } X[i] \neq Y[j] \end{cases}
$$

**直覺：**
- Delete：把 X[i] 刪掉，問題變成 X[1..i-1] → Y[1..j]
- Insert：在 X 的末端插入 Y[j]，問題變成 X[1..i] → Y[1..j-1]
- Replace：把 X[i] 換成 Y[j]，問題變成 X[1..i-1] → Y[1..j-1]

#### Step-by-step 填表範例

X = "HORSE", Y = "ROS"

```
       ""  R  O  S
   ""   0  1  2  3
    H   1  1  2  3
    O   2  2  1  2
    R   3  2  2  2
    S   4  3  3  2
    E   5  4  4  3
```

逐步解說：

- dp[0][0]=0（空→空）
- dp[0][1]=1（空→"R"，插入 R）
- dp[1][0]=1（"H"→空，刪除 H）
- dp[1][1]：H≠R，1+min(dp[0][1], dp[1][0], dp[0][0]) = 1+min(1,1,0) = 1（替換 H→R）
- dp[2][2]：O=O，dp[1][1] = 1（不需操作）
- dp[3][1]：R=R，dp[2][0] = 2（不需操作）
- dp[5][3]：E≠S，1+min(dp[4][3], dp[5][2], dp[4][2]) = 1+min(2,4,2) = 3

**答：Edit Distance = dp[5][3] = 3。**

操作序列（其中一種）：
1. Replace H → R：HORSE → RORSE
2. Delete R：RORSE → ROSE
3. Delete E：ROSE → ROS

**時間複雜度：** $O(mn)$
**空間複雜度：** $O(mn)$，可滾動陣列優化到 $O(\min(m,n))$。

---

### 5.5 Matrix Chain Multiplication（矩陣鏈乘法）

#### 問題定義

有 n 個矩陣 $A_1, A_2, \ldots, A_n$，其中 $A_i$ 的維度是 $p_{i-1} \times p_i$。矩陣乘法有結合律，不同的括號方式計算量不同。求最少的純量乘法次數。

#### Step 1：定義子問題

$$dp[i][j] = \text{計算 } A_i A_{i+1} \cdots A_j \text{ 的最少純量乘法次數}$$

#### Step 2：遞迴式

$$
dp[i][j] = \begin{cases} 0 & \text{if } i = j \\ \min_{i \leq k < j} \{dp[i][k] + dp[k+1][j] + p_{i-1} \cdot p_k \cdot p_j\} & \text{if } i < j \end{cases}
$$

**直覺：** 枚舉最後一次乘法的「分割點」k。把 $A_i \cdots A_k$ 看成一個矩陣（$p_{i-1} \times p_k$），$A_{k+1} \cdots A_j$ 看成一個矩陣（$p_k \times p_j$），最後乘在一起需要 $p_{i-1} \cdot p_k \cdot p_j$ 次純量乘法。

#### Step 3：計算順序

按**區間長度**從小到大！先算 len=1（dp[i][i]=0），再 len=2, 3, ..., n。

#### 虛擬碼

```
MATRIX-CHAIN(p, n):
    // p[0..n] 是維度陣列，A_i 的維度是 p[i-1] x p[i]

    // Base case
    for i = 1 to n:
        dp[i][i] = 0

    // 填表：按區間長度
    for len = 2 to n:
        for i = 1 to n - len + 1:
            j = i + len - 1
            dp[i][j] = infinity
            for k = i to j - 1:
                cost = dp[i][k] + dp[k+1][j] + p[i-1] * p[k] * p[j]
                if cost < dp[i][j]:
                    dp[i][j] = cost
                    split[i][j] = k     // 記錄分割點

    return dp[1][n]
```

#### Step-by-step 填表範例

矩陣：$A_1(30\times35), A_2(35\times15), A_3(15\times5), A_4(5\times10), A_5(10\times20), A_6(20\times25)$

維度陣列 p = [30, 35, 15, 5, 10, 20, 25]

```
Base case: dp[i][i] = 0 for all i

len=2:
dp[1][2] = p[0]*p[1]*p[2] = 30*35*15 = 15750
dp[2][3] = p[1]*p[2]*p[3] = 35*15*5 = 2625
dp[3][4] = p[2]*p[3]*p[4] = 15*5*10 = 750
dp[4][5] = p[3]*p[4]*p[5] = 5*10*20 = 1000
dp[5][6] = p[4]*p[5]*p[6] = 10*20*25 = 5000

len=3:
dp[1][3]:
  k=1: dp[1][1]+dp[2][3]+30*35*5 = 0+2625+5250 = 7875
  k=2: dp[1][2]+dp[3][3]+30*15*5 = 15750+0+2250 = 18000
  dp[1][3] = 7875 (split at k=1)

dp[2][4]:
  k=2: dp[2][2]+dp[3][4]+35*15*10 = 0+750+5250 = 6000
  k=3: dp[2][3]+dp[4][4]+35*5*10 = 2625+0+1750 = 4375
  dp[2][4] = 4375 (split at k=3)

dp[3][5]:
  k=3: dp[3][3]+dp[4][5]+15*5*20 = 0+1000+1500 = 2500
  k=4: dp[3][4]+dp[5][5]+15*10*20 = 750+0+3000 = 3750
  dp[3][5] = 2500 (split at k=3)

dp[4][6]:
  k=4: dp[4][4]+dp[5][6]+5*10*25 = 0+5000+1250 = 6250
  k=5: dp[4][5]+dp[6][6]+5*20*25 = 1000+0+2500 = 3500
  dp[4][6] = 3500 (split at k=5)

len=4:
dp[1][4]:
  k=1: dp[1][1]+dp[2][4]+30*35*10 = 0+4375+10500 = 14875
  k=2: dp[1][2]+dp[3][4]+30*15*10 = 15750+750+4500 = 21000
  k=3: dp[1][3]+dp[4][4]+30*5*10 = 7875+0+1500 = 9375
  dp[1][4] = 9375 (split at k=3)

dp[2][5]:
  k=2: 0+2500+35*15*20 = 13000
  k=3: 2625+1000+35*5*20 = 7125
  k=4: 4375+0+35*10*20 = 11375
  dp[2][5] = 7125 (split at k=3)

dp[3][6]:
  k=3: 0+3500+15*5*25 = 5375
  k=4: 750+5000+15*10*25 = 9500
  k=5: 2500+0+15*20*25 = 10000
  dp[3][6] = 5375 (split at k=3)

len=5:
dp[1][5]:
  k=1: 0+7125+30*35*20 = 28125
  k=2: 15750+2500+30*15*20 = 27250
  k=3: 7875+1000+30*5*20 = 11875
  k=4: 9375+0+30*10*20 = 15375
  dp[1][5] = 11875 (split at k=3)

dp[2][6]:
  k=2: 0+5375+35*15*25 = 18500
  k=3: 2625+3500+35*5*25 = 10500
  k=4: 4375+5000+35*10*25 = 18125
  k=5: 7125+0+35*20*25 = 24625
  dp[2][6] = 10500 (split at k=3)

len=6:
dp[1][6]:
  k=1: 0+10500+30*35*25 = 36750
  k=2: 15750+5375+30*15*25 = 32375
  k=3: 7875+3500+30*5*25 = 15125
  k=4: 9375+5000+30*10*25 = 21875
  k=5: 11875+0+30*20*25 = 26875
  dp[1][6] = 15125 (split at k=3)
```

**答：最少純量乘法次數 = 15125。**

**最佳括號方式（透過 split 陣列回溯）：**
- dp[1][6] split at k=3: $(A_1 A_2 A_3)(A_4 A_5 A_6)$
- dp[1][3] split at k=1: $A_1(A_2 A_3)$
- dp[4][6] split at k=5: $(A_4 A_5)A_6$

最終：$(A_1(A_2 A_3))((A_4 A_5)A_6)$

**時間複雜度：** $O(n^3)$
**空間複雜度：** $O(n^2)$

---

### 5.6 Optimal BST（最佳二元搜尋樹）

#### 問題定義

有 n 個 key $k_1 < k_2 < \cdots < k_n$，每個 key 有搜尋機率 $p_i$。此外有 n+1 個「虛擬 key」$d_0, d_1, \ldots, d_n$（代表搜尋不在 key 中的值），機率 $q_i$。

目標：建一棵 BST，使得**期望搜尋成本最小**。

$$E[\text{search cost}] = \sum_{i=1}^{n} p_i \cdot (\text{depth}(k_i) + 1) + \sum_{i=0}^{n} q_i \cdot (\text{depth}(d_i) + 1)$$

#### 子問題

$$dp[i][j] = \text{包含 key } k_i, \ldots, k_j \text{ 和虛擬 key } d_{i-1}, \ldots, d_j \text{ 的最佳 BST 成本}$$

$$w[i][j] = \sum_{l=i}^{j} p_l + \sum_{l=i-1}^{j} q_l \quad \text{（子樹的總機率和）}$$

#### 遞迴式

$$
dp[i][j] = \begin{cases} q_{i-1} & \text{if } j = i-1 \text{（空樹，只有虛擬 key } d_{i-1}\text{）} \\ \min_{i \leq r \leq j} \{dp[i][r-1] + dp[r+1][j] + w[i][j]\} & \text{if } i \leq j \end{cases}
$$

**直覺：** 選 $k_r$ 當根，左子樹包含 $k_i \cdots k_{r-1}$，右子樹包含 $k_{r+1} \cdots k_j$。當子樹變成某個 node 的子樹時，所有節點的深度 +1，所以成本增加 $w[i][j]$。

**時間複雜度：** $O(n^3)$（可用 Knuth 優化到 $O(n^2)$）。

---

### 5.7 Coin Change（硬幣找零）

#### 問題定義

有無限量的硬幣，面額為 $c_1, c_2, \ldots, c_k$。要湊出金額 n，求最少硬幣數。

#### 子問題

$$dp[i] = \text{湊出金額 i 的最少硬幣數}$$

#### 遞迴式

$$
dp[i] = \begin{cases} 0 & \text{if } i = 0 \\ \min_{j:\; c_j \leq i} \{dp[i - c_j] + 1\} & \text{if } i > 0 \end{cases}
$$

如果沒有任何硬幣能用（min 取不到），$dp[i] = \infty$（無解）。

#### 虛擬碼

```
COIN-CHANGE(coins, n):
    dp[0] = 0
    for i = 1 to n:
        dp[i] = infinity
        for each coin c in coins:
            if c <= i and dp[i - c] + 1 < dp[i]:
                dp[i] = dp[i - c] + 1

    return dp[n] (if dp[n] == infinity, return -1)
```

#### Step-by-step 填表範例

coins = [1, 3, 4], n = 6

```
dp[0] = 0
dp[1]: min(dp[0]+1) = 1                    （用 1 元）
dp[2]: min(dp[1]+1) = 2                    （用 1 元 ×2）
dp[3]: min(dp[2]+1, dp[0]+1) = min(3,1) = 1   （直接用 3 元！）
dp[4]: min(dp[3]+1, dp[1]+1, dp[0]+1) = min(2,2,1) = 1 （直接用 4 元！）
dp[5]: min(dp[4]+1, dp[2]+1, dp[1]+1) = min(2,3,2) = 2 （用 4+1 或 1+4）
dp[6]: min(dp[5]+1, dp[3]+1, dp[2]+1) = min(3,2,3) = 2 （用 3+3！）
```

**答：dp[6] = 2，用兩個 3 元硬幣。**

**時間複雜度：** $O(nk)$，其中 k 是硬幣種類數。

---

### 5.8 回文插入（Minimum Insertions to Make Palindrome）

#### 問題定義

給定字串 S[1..n]，求最少插入幾個字元可以使它變成回文。

#### 觀察

最少插入次數 = n - LPS(S)，其中 LPS 是 Longest Palindromic Subsequence。

而 LPS(S) = LCS(S, reverse(S))。

但我們也可以直接用區間 DP 解：

#### 子問題

$$dp[i][j] = \text{把 } S[i..j] \text{ 變成回文的最少插入次數}$$

#### 遞迴式

$$
dp[i][j] = \begin{cases} 0 & \text{if } i \geq j \\ dp[i+1][j-1] & \text{if } S[i] = S[j] \\ 1 + \min(dp[i+1][j],\; dp[i][j-1]) & \text{if } S[i] \neq S[j] \end{cases}
$$

**直覺：**
- 如果頭尾相同，不需要插入，往內縮
- 如果頭尾不同：
  - 在右邊插入 S[i]，問題變成 dp[i+1][j]
  - 在左邊插入 S[j]，問題變成 dp[i][j-1]

#### 填表範例

S = "abcda"

```
       a  b  c  d  a
   a   0  1  2  3  2
   b      0  1  2  2（注意這裡 b 到 a 需要變成回文）
   c         0  1  2
   d            0  1
   a               0
```

填表順序（按區間長度）：

- len=1: dp[i][i] = 0（全部是 0）
- len=2:
  - dp[1][2]: 'a'≠'b', 1+min(dp[2][2], dp[1][1]) = 1+0 = 1
  - dp[2][3]: 'b'≠'c', 1
  - dp[3][4]: 'c'≠'d', 1
  - dp[4][5]: 'd'≠'a', 1
- len=3:
  - dp[1][3]: 'a'≠'c', 1+min(dp[2][3], dp[1][2]) = 1+min(1,1) = 2
  - dp[2][4]: 'b'≠'d', 1+min(dp[3][4], dp[2][3]) = 1+min(1,1) = 2
  - dp[3][5]: 'c'≠'a', 1+min(dp[4][5], dp[3][4]) = 1+min(1,1) = 2
- len=4:
  - dp[1][4]: 'a'≠'d', 1+min(dp[2][4], dp[1][3]) = 1+min(2,2) = 3
  - dp[2][5]: 'b'≠'a', 1+min(dp[3][5], dp[2][4]) = 1+min(2,2) = 3
    但等等，讓我重新算：dp[2][5]: 'b'≠'a', 1+min(dp[3][5], dp[2][4]) = 1+min(2,2) = 3
    嗯，不對，我漏算了。讓我重新更仔細算。

重新計算 dp[2][5]：S[2..5] = "bcda"
  S[2]='b' ≠ S[5]='a'
  dp[2][5] = 1 + min(dp[3][5], dp[2][4]) = 1 + min(2, 2) = 3
  但我上面表格寫的是 2，讓我改正。

其實我搞混了索引。讓我用 0-indexed 重來：

S = "abcda" (indices 0-4)

len=1: all 0
len=2:
  dp[0][1]: a≠b → 1
  dp[1][2]: b≠c → 1
  dp[2][3]: c≠d → 1
  dp[3][4]: d≠a → 1
len=3:
  dp[0][2]: a≠c → 1+min(dp[1][2], dp[0][1]) = 1+1 = 2
  dp[1][3]: b≠d → 1+min(dp[2][3], dp[1][2]) = 1+1 = 2
  dp[2][4]: c≠a → 1+min(dp[3][4], dp[2][3]) = 1+1 = 2
len=4:
  dp[0][3]: a≠d → 1+min(dp[1][3], dp[0][2]) = 1+2 = 3
  dp[1][4]: b≠a → 1+min(dp[2][4], dp[1][3]) = 1+2 = 3
len=5:
  dp[0][4]: a=a! → dp[1][3] = 2
```

**答：dp[0][4] = 2。** 例如可以插入成 "abcdcba"（插入 c 和 b）或 "adcbcda"。

**時間複雜度：** $O(n^2)$

---

### 5.9 Weighted Job Scheduling（加權工作排程）

#### 問題定義

有 n 個工作，第 i 個工作有開始時間 $s_i$、結束時間 $f_i$、權重（利潤）$w_i$。工作不能重疊。求最大總利潤。

#### 預處理

1. 把工作按結束時間排序
2. 對每個工作 i，找 $p(i)$ = 不與工作 i 衝突的、結束時間最晚的前一個工作的 index（可以用二分搜尋找）

#### 子問題

$$dp[i] = \text{考慮前 i 個工作（按結束時間排序）的最大利潤}$$

#### 遞迴式

$$
dp[i] = \max(dp[i-1],\; w_i + dp[p(i)])
$$

- 不選工作 i：$dp[i-1]$
- 選工作 i：$w_i + dp[p(i)]$

**Base case：** $dp[0] = 0$

#### 虛擬碼

```
WEIGHTED-JOB-SCHEDULING(jobs):
    sort jobs by finish time

    // 預處理 p(i)：用二分搜尋
    for i = 1 to n:
        p[i] = largest j < i such that job j doesn't conflict with job i
        // 也就是 finish[j] <= start[i] 的最大 j

    dp[0] = 0
    for i = 1 to n:
        dp[i] = max(dp[i-1], jobs[i].weight + dp[p[i]])

    return dp[n]
```

#### Step-by-step 填表範例

工作（已按結束時間排序）：

| 工作 | 開始 | 結束 | 利潤 |
|------|------|------|------|
| 1    | 1    | 3    | 5    |
| 2    | 2    | 5    | 6    |
| 3    | 4    | 6    | 5    |
| 4    | 6    | 7    | 4    |
| 5    | 5    | 8    | 11   |
| 6    | 7    | 9    | 2    |

先求 p(i)：
- p(1) = 0（沒有不衝突的前面工作）
- p(2) = 0（工作 1 結束時間 3 > 工作 2 開始時間 2）
- p(3) = 1（工作 1 結束 3 ≤ 工作 3 開始 4）
- p(4) = 2（工作 2 結束 5 ≤ 工作 4 開始 6；工作 3 結束 6 不 ≤ 6... 等等結束時間 6 ≤ 開始時間 6？看定義，通常是嚴格不重疊所以 finish ≤ start）
  - 工作 3 結束 6 ≤ 工作 4 開始 6 ✓ → p(4) = 3
- p(5) = 2（工作 2 結束 5 ≤ 工作 5 開始 5 ✓，工作 3 結束 6 > 5 ✗）→ p(5) = 2
- p(6) = 4（工作 4 結束 7 ≤ 工作 6 開始 7 ✓）

```
dp[0] = 0
dp[1] = max(dp[0], 5 + dp[p(1)]) = max(0, 5+0) = 5
dp[2] = max(dp[1], 6 + dp[p(2)]) = max(5, 6+0) = 6
dp[3] = max(dp[2], 5 + dp[p(3)]) = max(6, 5+dp[1]) = max(6, 5+5) = 10
dp[4] = max(dp[3], 4 + dp[p(4)]) = max(10, 4+dp[3]) = max(10, 4+10) = 14
dp[5] = max(dp[4], 11 + dp[p(5)]) = max(14, 11+dp[2]) = max(14, 11+6) = 17
dp[6] = max(dp[5], 2 + dp[p(6)]) = max(17, 2+dp[4]) = max(17, 2+14) = 17
```

**答：最大利潤 = 17。**

**回溯：** dp[6]=17=dp[5]（不選 6），dp[5]=17=11+dp[2]（選 5），dp[2]=6=6+dp[0]（選 2）。所以選工作 2 和 5，利潤 6+11=17。

**時間複雜度：** 排序 $O(n \log n)$ + 二分搜尋求 p 需 $O(n \log n)$ + DP 填表 $O(n)$ = $O(n \log n)$。

---

## 6. DP 優化技巧：空間優化（滾動陣列）

### 6.1 基本想法

很多 DP 的遞迴式中，dp[i] 只依賴 dp[i-1]（上一行），不需要更早的行。這時候可以只保留兩行（甚至一行），把空間從 O(n·m) 降到 O(m)。

### 6.2 範例：0/1 Knapsack 空間優化

原本：dp[i][w] 依賴 dp[i-1][w] 和 dp[i-1][w-w_i]

**用一維陣列，但從後往前掃！**

```
KNAPSACK-OPTIMIZED(n, W, w[], v[]):
    dp = array of size W+1, all zeros

    for i = 1 to n:
        for w = W downto w[i]:      // 注意：從後往前！
            dp[w] = max(dp[w], dp[w - w[i]] + v[i])

    return dp[W]
```

**為什麼要從後往前？** 因為 dp[w - w_i] 需要的是「上一輪（i-1）」的值。如果從前往後掃，dp[w - w_i] 可能已經被這一輪更新過了，變成「第 i 輪」的值，相當於物品 i 可以重複選（變成 unbounded knapsack）。

### 6.3 LCS 空間優化

原本 O(mn) 空間。dp[i][j] 只依賴 dp[i-1][j], dp[i][j-1], dp[i-1][j-1]，所以只需要兩行（或一行加一個暫存變數）。

```
LCS-SPACE-OPTIMIZED(X, Y):
    m = |X|, n = |Y|
    prev = array of size n+1, all zeros
    curr = array of size n+1, all zeros

    for i = 1 to m:
        for j = 1 to n:
            if X[i] == Y[j]:
                curr[j] = prev[j-1] + 1
            else:
                curr[j] = max(prev[j], curr[j-1])
        swap prev and curr
        fill curr with zeros

    return prev[n]
```

空間：$O(\min(m, n))$。

**注意：** 空間優化後通常無法回溯找解（因為中間結果被覆蓋了）。如果需要找解，要用其他技巧（如 Hirschberg's algorithm 用分治來回溯，空間仍為 O(n)）。

---

## 7. 如何區分「DP」vs「Greedy」

這是很多人的困惑。以下是判斷方法：

### 7.1 核心差異

| 特徵 | DP | Greedy |
|------|-----|--------|
| 每一步 | 考慮**所有**選擇，取最優 | 只做**局部最優**的選擇 |
| 子問題 | 重疊的子問題都會被考慮 | 做完選擇就不回頭 |
| 正確性保證 | 只要遞迴式正確就一定對 | 需要額外證明 greedy choice property |
| 時間 | 通常較慢（但一定正確） | 通常較快（但不一定正確） |

### 7.2 判斷流程

```
你遇到一個最優化問題：

1. 有 Greedy Choice Property 嗎？
   （也就是說，「局部最優選擇」一定會出現在「全域最優解」中嗎？）

   ├── 能證明 Yes → 用 Greedy
   │
   └── No 或 不確定 →

       2. 有 Optimal Substructure 嗎？
          ├── Yes → 用 DP
          └── No → 可能需要其他方法（如搜尋、近似）
```

### 7.3 經典對比

**Activity Selection（等權重）→ Greedy**
- 所有活動權重一樣，選最早結束的一定不虧（greedy choice property 成立）

**Weighted Job Scheduling → DP**
- 權重不一樣了！選最早結束的不一定最好（greedy choice property 不成立）
- 需要 DP 來考慮所有可能性

**Fractional Knapsack → Greedy**
- 可以拿分數個物品 → 按 CP 值（v/w）排序，貪心拿

**0/1 Knapsack → DP**
- 只能整個拿或不拿 → Greedy 不行（反例很容易構造），必須 DP

**Minimum Spanning Tree → Greedy**
- Kruskal/Prim 都是 Greedy（有 matroid 理論支持）

**Shortest Path（有負邊）→ DP**
- Bellman-Ford 就是 DP

### 7.4 快速試錯法

如果你猜一個 Greedy 策略，試著構造一個反例。如果很快就能構造出反例，那就不適合 Greedy，用 DP。

**範例：** 0/1 Knapsack，用「CP 值最高先拿」的 Greedy：

物品 A：重 1，值 6（CP = 6）
物品 B：重 2，值 10（CP = 5）
背包容量 = 2

Greedy 選 A（CP 最高），剩餘容量 1，B 放不下。總值 = 6。
最佳解：選 B，總值 = 10。

Greedy 失敗！→ 要用 DP。

---

## 8. 更多完整填表範例

### 填表範例 1：Coin Change（不同面額）

coins = [2, 5, 7], n = 13

```
dp[0] = 0
dp[1] = ∞ （沒有面額為 1 的硬幣）
dp[2] = min(dp[0]+1) = 1          （用一個 2）
dp[3] = ∞
dp[4] = min(dp[2]+1) = 2          （2+2）
dp[5] = min(dp[3]+1, dp[0]+1) = 1 （用一個 5）
dp[6] = min(dp[4]+1) = 3          （2+2+2）
dp[7] = min(dp[5]+1, dp[2]+1, dp[0]+1) = min(2, 2, 1) = 1  （用一個 7）
dp[8] = min(dp[6]+1, dp[3]+1, dp[1]+1) = min(4, ∞, ∞) = 4
  等等，dp[6]+1 = 3+1=4？讓我重算
  dp[8]: 用 2 → dp[6]+1=4; 用 5 → dp[3]+1=∞; 用 7 → dp[1]+1=∞
  嗯，但 dp[6] 應該可以更好。

  讓我重新從頭算：
  dp[6]: 用 2 → dp[4]+1=3; 用 5 → dp[1]+1=∞; 用 7 → 7>6 不行
  所以 dp[6] = 3 ... 不對，2+2+2 確實是 3 個硬幣。

  但其實還有更好的方法嗎？沒有，因為沒有面額 3 或 1。

  dp[8]: 用 2 → dp[6]+1=4（2+2+2+2）; 用 5 → dp[3]+1=∞; 用 7 → dp[1]+1=∞
  dp[8] = 4... 嗯但這似乎不太好。

  等等！沒錯，coins 只有 2, 5, 7，所以 8 = 2+2+2+2 需要 4 個。

dp[9] = min(dp[7]+1, dp[4]+1, dp[2]+1) = min(2, 3, 2) = 2     （7+2 或 2+7）
dp[10] = min(dp[8]+1, dp[5]+1, dp[3]+1) = min(5, 2, ∞) = 2    （5+5）
dp[11] = min(dp[9]+1, dp[6]+1, dp[4]+1) = min(3, 4, 3) = 3    （7+2+2 或 2+2+7）
dp[12] = min(dp[10]+1, dp[7]+1, dp[5]+1) = min(3, 2, 2) = 2   （7+5 或 5+7）
dp[13] = min(dp[11]+1, dp[8]+1, dp[6]+1) = min(4, 5, 4) = 4
  嗯，不對。讓我仔細看：
  用 2 → dp[11]+1 = 3+1 = 4
  用 5 → dp[8]+1 = 4+1 = 5
  用 7 → dp[6]+1 = 3+1 = 4
  dp[13] = 4?

  但 13 = 7 + 2 + 2 + 2 = 4 個，或 5 + 2 + 2 + 2 + 2 = 5 個。
  那 5+5+2+... 不行（12）。7+5+... 不行（12）。
  嗯 13 真的沒辦法比 4 個更好（在只有 2,5,7 的情況下）。

  等等：2+2+2+7 = 13, 4 個。2+2+2+2+5 = 13, 5 個。
  但 2+4+7 不行因為沒有 4。5+2+2+2+2 = 13 也是 5 個。

  所以 dp[13] = 4 沒問題。但讓我試另一個：
  dp[12] = 2 (7+5)，dp[14] = min(dp[12]+1, dp[9]+1, dp[7]+1) = min(3,3,2) = 2 (7+7)
```

好吧，讓我再提供一個更乾淨的範例。

### 填表範例 2：LIS 的 O(n^2) DP

A = [3, 1, 4, 1, 5, 9, 2, 6]

```
i=1: A[1]=3  → dp[1] = 1                               LIS 結尾: [3]
i=2: A[2]=1  → 沒有 A[j]<1 → dp[2] = 1                  LIS 結尾: [1]
i=3: A[3]=4  → A[1]=3<4 ✓: dp[1]+1=2
               A[2]=1<4 ✓: dp[2]+1=2
             → dp[3] = 2                                 LIS 結尾: [3,4] 或 [1,4]
i=4: A[4]=1  → 沒有 A[j]<1 → dp[4] = 1                  LIS 結尾: [1]
i=5: A[5]=5  → A[1]=3<5: dp[1]+1=2
               A[2]=1<5: dp[2]+1=2
               A[3]=4<5: dp[3]+1=3
               A[4]=1<5: dp[4]+1=2
             → dp[5] = 3                                 LIS 結尾: [1,4,5] 或 [3,4,5]
i=6: A[6]=9  → 都 <9，最大的是 dp[5]+1=4
             → dp[6] = 4                                 LIS 結尾: [1,4,5,9]
i=7: A[7]=2  → A[2]=1<2: dp[2]+1=2
               A[4]=1<2: dp[4]+1=2
             → dp[7] = 2                                 LIS 結尾: [1,2]
i=8: A[8]=6  → A[1]=3<6: dp[1]+1=2
               A[2]=1<6: dp[2]+1=2
               A[3]=4<6: dp[3]+1=3
               A[4]=1<6: dp[4]+1=2
               A[5]=5<6: dp[5]+1=4
               A[7]=2<6: dp[7]+1=3
             → dp[8] = 4                                 LIS 結尾: [1,4,5,6]

答：max(dp) = 4。一個 LIS 是 [1, 4, 5, 9] 或 [1, 4, 5, 6] 或 [3, 4, 5, 9] 等。
```

---

### 填表範例 3：Edit Distance

X = "SUNDAY", Y = "SATURDAY"

```
         ""  S  A  T  U  R  D  A  Y
    ""    0  1  2  3  4  5  6  7  8
     S    1  0  1  2  3  4  5  6  7
     U    2  1  1  2  2  3  4  5  6
     N    3  2  2  2  3  3  4  5  6
     D    4  3  3  3  3  4  3  4  5
     A    5  4  3  4  4  4  4  3  4
     Y    6  5  4  4  5  5  5  4  3
```

逐步解說一些格子：

- dp[1][1]: S=S → dp[0][0] = 0
- dp[2][1]: U≠S → 1+min(dp[1][1], dp[2][0], dp[1][0]) = 1+min(0,2,1) = 1
- dp[2][4]: U=U → dp[1][3] = 2
- dp[4][6]: D=D → dp[3][5] = 3
- dp[6][8]: Y=Y → dp[5][7] = 3

**答：Edit Distance = 3。**

操作：SUNDAY → SATURDAY
1. Insert A at position 2: SUNDAY → SAUNDAY
2. Insert T at position 3: SAUNDAY → SATUNDAY
3. Replace N with R: SATUNDAY → SATURDAY

（或其他等價操作序列。）

---

### 填表範例 4：回文插入

S = "race"

dp[i][j] = 把 S[i..j] 變成回文的最少插入次數

```
     r  a  c  e
r    0  1  2  3
a       0  1  2
c          0  1
e             0
```

詳細計算：

```
len=1: dp[0][0]=0, dp[1][1]=0, dp[2][2]=0, dp[3][3]=0

len=2:
dp[0][1]: r≠a → 1+min(dp[1][1], dp[0][0]) = 1+0 = 1
dp[1][2]: a≠c → 1+min(dp[2][2], dp[1][1]) = 1+0 = 1
dp[2][3]: c≠e → 1+min(dp[3][3], dp[2][2]) = 1+0 = 1

len=3:
dp[0][2]: r≠c → 1+min(dp[1][2], dp[0][1]) = 1+min(1,1) = 2
dp[1][3]: a≠e → 1+min(dp[2][3], dp[1][2]) = 1+min(1,1) = 2

len=4:
dp[0][3]: r≠e → 1+min(dp[1][3], dp[0][2]) = 1+min(2,2) = 3
```

**答：dp[0][3] = 3。** "race" → "racecar"（插入 c, a, r）。

---

### 填表範例 5：0/1 Knapsack（另一個範例）

物品：

| 物品 | 重量 w | 價值 v |
|------|--------|--------|
| 1    | 1      | 1      |
| 2    | 3      | 4      |
| 3    | 4      | 5      |
| 4    | 2      | 3      |

背包容量 W = 7

```
       w=  0   1   2   3   4   5   6   7
i=0:       0   0   0   0   0   0   0   0

i=1(w=1,v=1):
           0   1   1   1   1   1   1   1
  （容量≥1就可以放物品1）

i=2(w=3,v=4):
           0   1   1   4   5   5   5   5
  w=3: max(dp[1][3], dp[1][0]+4) = max(1, 4) = 4
  w=4: max(dp[1][4], dp[1][1]+4) = max(1, 5) = 5
  w=5: max(dp[1][5], dp[1][2]+4) = max(1, 5) = 5
  w=6: max(dp[1][6], dp[1][3]+4) = max(1, 5) = 5
  w=7: max(dp[1][7], dp[1][4]+4) = max(1, 5) = 5

i=3(w=4,v=5):
           0   1   1   4   5   6   6   9
  w=4: max(dp[2][4], dp[2][0]+5) = max(5, 5) = 5
  w=5: max(dp[2][5], dp[2][1]+5) = max(5, 6) = 6
  w=6: max(dp[2][6], dp[2][2]+5) = max(5, 6) = 6
  w=7: max(dp[2][7], dp[2][3]+5) = max(5, 4+5) = 9

i=4(w=2,v=3):
           0   1   3   4   4   7   8   9
  w=2: max(dp[3][2], dp[3][0]+3) = max(1, 3) = 3
  w=3: max(dp[3][3], dp[3][1]+3) = max(4, 1+3) = 4
  w=4: max(dp[3][4], dp[3][2]+3) = max(5, 1+3) = 5
    等等不對：dp[3][2] = 1, 1+3=4, max(5,4)=5 沒問題
  w=5: max(dp[3][5], dp[3][3]+3) = max(6, 4+3) = 7
  w=6: max(dp[3][6], dp[3][4]+3) = max(6, 5+3) = 8
  w=7: max(dp[3][7], dp[3][5]+3) = max(9, 6+3) = 9
```

**答：最大價值 = dp[4][7] = 9。**

**回溯：**
- dp[4][7]=9=dp[3][7]（沒選 4）
- dp[3][7]=9≠dp[2][7]=5，選了 3！容量剩 7-4=3
- dp[2][3]=4≠dp[1][3]=1，選了 2！容量剩 3-3=0
- 容量 0，結束

選物品 2（w=3,v=4）和物品 3（w=4,v=5），重量 = 7，價值 = 9。 ✓

---

## 9. 常見陷阱

### 陷阱 1：子問題定義不夠精確

例如 LIS，如果定義 dp[i] = 「前 i 個元素的 LIS 長度」，你會發現推不出遞迴式。因為知道前 i-1 個的 LIS 長度，並不能告訴你 A[i] 能不能接上去（你不知道 LIS 的最後一個元素是什麼）。

正確定義：dp[i] = 「以 A[i] **結尾**的 LIS 長度」。這樣你就知道最後一個元素是什麼了。

### 陷阱 2：忘記 Base Case

每個 DP 都需要 base case。常見錯誤是忘記初始化 dp[0] 或 dp[i][0] 等邊界條件。

### 陷阱 3：計算順序錯誤

如果 dp[i][j] 依賴 dp[i][j-1]，你不能先算 dp[i][j] 再算 dp[i][j-1]。要仔細分析依賴方向。

特別是 0/1 Knapsack 的一維優化，一定要**從後往前**掃！

### 陷阱 4：搞混「子序列」和「子字串」

- **子序列 (Subsequence)：** 不需要連續，但要保持順序
- **子字串 (Substring)：** 必須連續

LCS 是子**序列**問題。如果題目問的是子**字串**，DP 定義和遞迴式都不同。

### 陷阱 5：忘記回溯

DP 表格只告訴你最優「值」，不告訴你最優「解」。如果題目要求輸出解（而不只是值），記得在填表時同時記錄 choice，然後回溯。

### 陷阱 6：把 Pseudo-polynomial 當成 Polynomial

Knapsack 的 $O(nW)$ 看起來是多項式，但 W 是「數值」而非「位元數」。如果 W 用 $\log W$ 位元表示，那麼 $O(nW) = O(n \cdot 2^{\log W})$ 其實是指數時間。這就是為什麼 Knapsack 仍是 NP-complete（它只有 pseudo-polynomial 解）。

### 陷阱 7：空間優化後想回溯

滾動陣列覆蓋了之前的 dp 值，無法回溯找解。如果需要找解，要嘛不做空間優化，要嘛用 Hirschberg 等技巧。

---

## 附錄：DP 題型速查表

| 問題 | 子問題定義 | 時間 | 空間 |
|------|-----------|------|------|
| 0/1 Knapsack | dp[i][w] 前 i 物品容量 w | O(nW) | O(W) |
| LCS | dp[i][j] X[1..i] 和 Y[1..j] | O(mn) | O(min(m,n)) |
| LIS | dp[i] 以 A[i] 結尾 | O(n^2) / O(n log n) | O(n) |
| Edit Distance | dp[i][j] X[1..i] → Y[1..j] | O(mn) | O(min(m,n)) |
| Matrix Chain | dp[i][j] 區間 [i..j] | O(n^3) | O(n^2) |
| Optimal BST | dp[i][j] key i 到 j | O(n^3) / O(n^2) | O(n^2) |
| Coin Change | dp[i] 金額 i | O(nk) | O(n) |
| 回文插入 | dp[i][j] 區間 [i..j] | O(n^2) | O(n^2) |
| Weighted Job | dp[i] 前 i 工作 | O(n log n) | O(n) |
