# 演算法偵探筆記（下）— 時間迴廊的最後推理

> *「每一步都依賴上一步的結果。*
> *但你不需要重新走一遍所有的路——只要記住每一站的答案。」*
> *—— 蘇雨晴*

---

## 前情提要

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  凌晨 01:23 系計中伺服器被入侵。                           │
│  一百萬筆資料被打亂（半完成的 heap sort）。                 │
│  2,627 筆重複資料在資料庫裡偷藏了一張有向圖。              │
│                                                             │
│  圖裡有五座島、三個環、一個幽靈帳號 #50742。               │
│  主要嫌疑人：鄭宇翔，校務系統開發者。                       │
│                                                             │
│  但有兩件事不對：                                           │
│  1. 他的 heap sort 做到一半就停了。不像被中斷，像自己停的。 │
│  2. 藏在資料庫裡的圖結構太精緻。不像攻擊，像出題。         │
│                                                             │
│  學姊說：「這是一場考試。」                                 │
│                                                             │
│  如果真的是考試——那答案在哪裡？                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 第一幕　伺服器室的門鎖上了

下午兩點。我們回到系計中的伺服器室。

學姊帶了她的筆電。阿翔帶了三瓶能量飲料。
我帶了一種不祥的預感。

吳教授也來了。他刷了門禁卡——

「嗶。」

門沒開。紅燈。

他又刷了一次。紅燈。

「門禁系統好像被改了，」他皺眉，「今天早上還正常的。」

學姊快速在筆電上連進系統。她的表情在三秒內經歷了
平靜 → 困惑 → 嚴肅。

「門禁密碼被換了。新密碼是一串數字。而且附了一段訊息。」

她把螢幕轉過來。

```
╔══════════════════════════════════════════════════════════════╗
║  [SYSTEM MESSAGE]                                            ║
║                                                              ║
║  門禁密碼已更新。新密碼為以下問題的答案。                    ║
║                                                              ║
║  ┌────────────────────────────────────────────────────┐     ║
║  │                                                    │     ║
║  │  你有一組伺服器日誌，共 n 個時間點。               │     ║
║  │  每個時間點有一個「異常指數」a[i]。                │     ║
║  │                                                    │     ║
║  │  a = [3, -1, 4, -1, 5, -9, 2, 6, -5, 3, 5]       │     ║
║  │                                                    │     ║
║  │  請找出「連續子區間的最大異常總和」。               │     ║
║  │                                                    │     ║
║  │  答案（一個整數）就是新密碼。                      │     ║
║  │                                                    │     ║
║  │                              — 出題者敬上          │     ║
║  │                                                    │     ║
║  └────────────────────────────────────────────────────┘     ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
```

阿翔：「......真的假的。他換了門鎖然後叫我們解題？」

我盯著那道題。

Maximum Subarray Sum。Kadane's Algorithm。
經典中的經典。

但——如果我是第一次看到這題呢？如果我不知道有現成的演算法呢？

我會怎麼想？

---

### 1.1　暴力的誘惑

「最直覺的方法，」阿翔搶先說，「就是列出所有可能的連續子區間，
算出每個的總和，取最大的。」

他在白板上畫：

```
  a = [3, -1, 4, -1, 5, -9, 2, 6, -5, 3, 5]
       0   1  2   3  4   5  6  7   8  9  10

  所有連續子區間（起點 i，終點 j，i ≤ j）：

  i=0: [3], [3,-1], [3,-1,4], [3,-1,4,-1], ...     → 11 個
  i=1: [-1], [-1,4], [-1,4,-1], ...                → 10 個
  i=2: [4], [4,-1], [4,-1,5], ...                  → 9 個
  ...

  總共：11 + 10 + 9 + ... + 1 = 66 個子區間。

  每個子區間要算總和（最慘 O(n)）。
  → 總共 O(n³)。

  用 prefix sum 可以把「算總和」優化到 O(1)。
  → 總共 O(n²)。

  n = 11 的時候，沒問題。
  但如果 n = 一百萬呢？O(n²) = 一兆。又來了。
```

「我們不會真的需要算一百萬筆的版本吧......？」阿翔問。

「先把眼前這個解了，」我說，「n = 11，暴力也行。但我想用更聰明的方法。」

因為——我有一種直覺，這不只是一道門禁密碼的題目。
出題者想看的，是我們怎麼想。

---

### 1.2　換個角度想

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 暫停推理                                                │
│                                                             │
│  a = [3, -1, 4, -1, 5, -9, 2, 6, -5, 3, 5]                │
│                                                             │
│  你站在陣列的每個位置上，從左走到右。                       │
│  在每個位置，你要做一個決定：                               │
│                                                             │
│  「我要把這個數字接到前面的子區間後面，                     │
│    還是從這裡重新開始一段新的？」                           │
│                                                             │
│  想像你在累積分數。                                         │
│  如果前面累積的總和是正的 → 接著累積比較好                  │
│  如果前面累積的總和是負的 → 丟掉重來比較好                  │
│                                                             │
│  這個想法能不能推導出一個 O(n) 的解？                       │
│                                                             │
│  想三十秒。                                                 │
└─────────────────────────────────────────────────────────────┘
```

我在白板上一步步走：

```
  a = [3, -1, 4, -1, 5, -9, 2, 6, -5, 3, 5]

  在每個位置 i，我問自己：
  「以 a[i] 結尾的連續子區間，最大總和是多少？」

  叫它 dp[i]。

  dp[i] 只有兩個選擇：
  (A) 把 a[i] 接到前面的最佳子區間後面 → dp[i-1] + a[i]
  (B) 從 a[i] 自己重新開始            → a[i]

  取較大的那個：dp[i] = max(dp[i-1] + a[i], a[i])

  等價於：dp[i] = max(dp[i-1], 0) + a[i]
  （如果前面的累積是負的，就當作 0，也就是丟掉重來）
```

```
  走一遍：

  ┌─────┬────────┬───────────────────────┬──────────────────┐
  │  i  │  a[i]  │  dp[i-1]+a[i] vs a[i]│  dp[i]           │
  ├─────┼────────┼───────────────────────┼──────────────────┤
  │  0  │   3    │  (起點)               │  3               │
  │  1  │  -1    │  3+(-1)=2  vs  -1     │  2  （接著）     │
  │  2  │   4    │  2+4=6     vs  4      │  6  （接著）     │
  │  3  │  -1    │  6+(-1)=5  vs  -1     │  5  （接著）     │
  │  4  │   5    │  5+5=10    vs  5      │  10 （接著）     │
  │  5  │  -9    │  10+(-9)=1 vs  -9     │  1  （接著！）   │
  │  6  │   2    │  1+2=3     vs  2      │  3  （接著）     │
  │  7  │   6    │  3+6=9     vs  6      │  9  （接著）     │
  │  8  │  -5    │  9+(-5)=4  vs  -5     │  4  （接著）     │
  │  9  │   3    │  4+3=7     vs  3      │  7  （接著）     │
  │ 10  │   5    │  7+5=12    vs  5      │  12 （接著）     │
  └─────┴────────┴───────────────────────┴──────────────────┘

  答案 = max(dp[0], dp[1], ..., dp[10])
       = max(3, 2, 6, 5, 10, 1, 3, 9, 4, 7, 12)
       = 12

  對應的子區間：a[6..10] = [2, 6, -5, 3, 5]
  （但其實 a[0..4] = [3,-1,4,-1,5] = 10 也很大，
   只是後面接了 -9 之後，掙扎了一下又爬回來，
   到最後追到了 12。）
```

「12，」我說，「密碼是 12。」

學姊已經在輸入了。

「嗶。」綠燈。門開了。

阿翔衝進去：「喔耶！」

但我沒有馬上跟進去。

因為我在想一件更重要的事。

---

### 1.3　為什麼這樣想就對了？

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 偵探手札 #13 —— DP 的本質：「每一步只看上一步」         │
│                                                             │
│  剛才我們做了什麼？                                         │
│                                                             │
│  在每個位置，我們問：                                       │
│  「以這個位置結尾的最佳答案是什麼？」                       │
│                                                             │
│  而這個答案，只取決於「上一個位置的最佳答案」。             │
│                                                             │
│  dp[i] = f(dp[i-1], a[i])                                   │
│                                                             │
│  不需要知道 dp[i-2]、dp[i-3]、或更早的任何事。             │
│  只要記住上一步的答案，就能推出這一步的答案。               │
│                                                             │
│  這就是 Dynamic Programming 的核心精神：                    │
│                                                             │
│  ┌──────────────────────────────────────────┐              │
│  │                                          │              │
│  │  大問題 = 小問題的延伸                    │              │
│  │  小問題的答案可以被「記住」               │              │
│  │  不需要每次都從頭算                       │              │
│  │                                          │              │
│  └──────────────────────────────────────────┘              │
│                                                             │
│  這跟暴力法的差別在哪？                                     │
│                                                             │
│  暴力：對每個子區間，從頭算它的總和。                       │
│        很多子區間共用前半段，但你每次都重算。               │
│        → 重複計算 → 浪費 → O(n²) 或 O(n³)                 │
│                                                             │
│  DP：記住「截至目前為止的最佳累積」。                       │
│      每走一步，O(1) 的工作就能得到新答案。                  │
│      → 零重複 → O(n)                                       │
│                                                             │
│  DP 的兩個前提條件：                                        │
│  1. 最優子結構：大問題的最優解包含小問題的最優解            │
│  2. 重疊子問題：不同的大問題會用到相同的小問題              │
│                                                             │
│  如果只有 (1) 沒有 (2) → Greedy 可能就夠了                 │
│  如果 (1) 和 (2) 都有 → DP 是最佳選擇                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 第二幕　伺服器室裡的第二道題

門打開之後，我們走進去。

燈自動亮了。但螢幕上已經有東西在等我們。

```
╔══════════════════════════════════════════════════════════════╗
║  [SYSTEM MESSAGE]                                            ║
║                                                              ║
║  恭喜通過第一關。                                            ║
║                                                              ║
║  第二個問題：                                                ║
║                                                              ║
║  ┌────────────────────────────────────────────────────┐     ║
║  │                                                    │     ║
║  │  伺服器日誌被加密了。加密方式如下：                │     ║
║  │                                                    │     ║
║  │  原始日誌是一串字元。加密後變成另一串。            │     ║
║  │  加密方式：每次可以「刪除一個字元」或              │     ║
║  │  「插入一個字元」或「替換一個字元」。              │     ║
║  │                                                    │     ║
║  │  encrypted = "HLEOP"                               │     ║
║  │  original  = "HELLO"                               │     ║
║  │                                                    │     ║
║  │  問：最少需要幾次操作，才能把 encrypted            │     ║
║  │      變回 original？                               │     ║
║  │                                                    │     ║
║  │  提示：每一步的選擇都依賴前一步的狀態。            │     ║
║  │  而且，你之前已經見過這種思維方式了。              │     ║
║  │                                                    │     ║
║  └────────────────────────────────────────────────────┘     ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
```

Edit Distance。又一道經典。

阿翔看著題目：「呃......把 HLEOP 變成 HELLO......
H 不用動。L 在第二個位置......然後 E 要移到第三個......」

他開始在紙上寫寫畫畫，塗塗改改。

「不要用直覺去拼，」我說，「我們需要系統性地思考。」

---

### 2.1　二維的 DP

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 暫停推理                                                │
│                                                             │
│  把 "HLEOP" 變成 "HELLO"。                                  │
│  三種操作：刪除、插入、替換。每次操作花費 1。               │
│                                                             │
│  如果你只看兩個字串的「最後一個字元」：                     │
│  HLEOP 的最後一個是 P                                       │
│  HELLO 的最後一個是 O                                       │
│                                                             │
│  P ≠ O，所以你有三個選擇：                                 │
│  (a) 刪掉 P → 把 "HLEO" 變成 "HELLO"（子問題）            │
│  (b) 把 P 替換成 O → 把 "HLEO" 變成 "HELL"（子問題）      │
│  (c) 在 P 後面插入 O → 把 "HLEOP" 變成 "HELL"（子問題）   │
│                                                             │
│  不管選哪個，都會產生一個「更小的子問題」。                 │
│  這個子問題的結構跟原問題完全一樣！                         │
│                                                             │
│  你能看出 DP 的 table 該怎麼畫嗎？                          │
│                                                             │
│  想三十秒。                                                 │
└─────────────────────────────────────────────────────────────┘
```

我在白板上畫了一個二維表格。

```
  dp[i][j] = 把 encrypted 的前 i 個字元
             變成 original 的前 j 個字元
             所需的最少操作數

  encrypted = "HLEOP"   (長度 5)
  original  = "HELLO"   (長度 5)

  ┌───┬─────┬──────┬──────┬──────┬──────┬──────┐
  │   │  "" │  H   │  HE  │  HEL │ HELL │HELLO │
  │   │ j=0 │ j=1  │ j=2  │ j=3  │ j=4  │ j=5  │
  ├───┼─────┼──────┼──────┼──────┼──────┼──────┤
  │"" │  0  │  1   │  2   │  3   │  4   │  5   │
  │i=0│     │ 插H  │ 插HE │      │      │      │
  ├───┼─────┼──────┼──────┼──────┼──────┼──────┤
  │ H │  1  │  0   │  1   │  2   │  3   │  4   │
  │i=1│ 刪H │ H=H! │      │      │      │      │
  ├───┼─────┼──────┼──────┼──────┼──────┼──────┤
  │HL │  2  │  1   │  1   │  1   │  2   │  3   │
  │i=2│     │      │ L≠E  │ L=L! │      │      │
  ├───┼─────┼──────┼──────┼──────┼──────┼──────┤
  │HLE│  3  │  2   │  1   │  2   │  2   │  3   │
  │i=3│     │      │ E=E! │      │      │      │
  ├───┼─────┼──────┼──────┼──────┼──────┼──────┤
  │HLEO│ 4  │  3   │  2   │  2   │  3   │  2   │
  │i=4│     │      │      │      │      │ O=O! │
  ├───┼─────┼──────┼──────┼──────┼──────┼──────┤
  │HLEOP│5  │  4   │  3   │  3   │  3   │  3   │
  │i=5│     │      │      │      │      │ P≠O  │
  └───┴─────┴──────┴──────┴──────┴──────┴──────┘

  轉移方程式：
  if encrypted[i] == original[j]:
      dp[i][j] = dp[i-1][j-1]         # 字元相同，不用操作
  else:
      dp[i][j] = 1 + min(
          dp[i-1][j],      # 刪除 encrypted[i]
          dp[i][j-1],      # 插入 original[j]
          dp[i-1][j-1]     # 替換 encrypted[i] → original[j]
      )

  答案 = dp[5][5] = 3
```

我把表格填完之後，回頭看了一眼。

```
  三次操作：
  HLEOP → HLEOO（替換 P→O）→ HLELO（插入 L）→ ...

  不對，讓我追蹤回去：
  dp[5][5] = 3 來自 dp[4][5] = 2（刪除 P）+ 1

  dp[4][5] = 2 來自 dp[3][4] = 2（O=O 不用操作？不對）

  讓我重新看......dp[4][5] = 2，因為 O == O，
  所以 dp[4][5] = dp[3][4] = 2

  dp[3][4] = 2，E ≠ L，所以 = 1 + min(dp[2][4], dp[3][3], dp[2][3])
  = 1 + min(2, 2, 1) = 2

  總之——答案是 3。
```

「3，」我對學姊說。

她輸入。螢幕跳出下一段訊息。

但在那之前——

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 偵探手札 #14 —— 二維 DP 的世界觀                        │
│                                                             │
│  一維 DP（Maximum Subarray）：                              │
│  走在一條線上。每個位置只依賴前一個位置。                   │
│  → dp[i] = f(dp[i-1])                                      │
│                                                             │
│  二維 DP（Edit Distance）：                                 │
│  走在一個棋盤上。每格依賴左邊、上面、和左上角。            │
│  → dp[i][j] = f(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])    │
│                                                             │
│  ┌──→ j                                                    │
│  │  ┌───┬───┬───┐                                         │
│  ↓  │ ↖ │ ← │   │    ↖ = 替換（或不變）                   │
│  i  ├───┼───┼───┤    ← = 插入                              │
│     │ ↑ │ ★ │   │    ↑ = 刪除                              │
│     ├───┼───┼───┤                                          │
│     │   │   │   │    ★ = 當前位置                          │
│     └───┴───┴───┘    取三個方向的最小值 + 1                │
│                                                             │
│  DP 的維度 = 你的「狀態」需要幾個變數來描述。              │
│                                                             │
│  • 最大子區間和：狀態 = 「在位置 i」→ 一個變數 → 1D       │
│  • 編輯距離：狀態 = 「處理完 encrypted 前 i 個              │
│    和 original 前 j 個」→ 兩個變數 → 2D                    │
│  • 背包問題：狀態 = 「考慮前 i 個物品、                    │
│    容量剩 w」→ 兩個變數 → 2D                               │
│                                                             │
│  維度越高，狀態空間越大，但能解的問題也越複雜。             │
│  大部分面試題不會超過 2D。                                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 第三幕　回溯——走錯了也沒關係

### 3.1　第三道題

螢幕上出現了新訊息。

```
╔══════════════════════════════════════════════════════════════╗
║  [SYSTEM MESSAGE]                                            ║
║                                                              ║
║  第三關：                                                    ║
║                                                              ║
║  ┌────────────────────────────────────────────────────┐     ║
║  │                                                    │     ║
║  │  伺服器室有 4 台主機，互相之間的網路線              │     ║
║  │  可以有 6 種接法（每對主機之間 0 或 1 條線）。      │     ║
║  │  但有些接法會造成迴路（環），導致封包風暴。         │     ║
║  │                                                    │     ║
║  │  請列出所有「不含環」的接線方式。                   │     ║
║  │                                                    │     ║
║  │  （含完全不接線的情況。4 台主機編號 0-3。          │     ║
║  │    一種接法 = 一個邊的子集。                        │     ║
║  │    答案 = 不含環的子集數量。）                      │     ║
║  │                                                    │     ║
║  └────────────────────────────────────────────────────┘     ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
```

阿翔看完題目，開始數手指。

「4 台主機，最多 6 條邊（0-1, 0-2, 0-3, 1-2, 1-3, 2-3）。
每條邊可以選或不選，所以總共 2⁶ = 64 種組合。」

「然後你要一個一個檢查裡面有沒有環？」我問。

「呃......對？」

64 種還能硬來。但如果是 10 台主機呢？那就是 2⁴⁵ 種組合。
大約三十五兆。

「而且，」學姊說，「你不需要列舉所有組合再篩選。
你可以在建構的過程中就判斷。」

---

### 3.2　回溯的精神

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 暫停推理                                                │
│                                                             │
│  你有 6 條邊，要選一個子集。                                │
│  約束：選出來的邊不能形成環。                               │
│                                                             │
│  如果你一條一條邊做決定——選或不選——                          │
│  就像走一棵決策樹：                                         │
│                                                             │
│                    []                                        │
│                 ╱      ╲                                    │
│         不選 0-1      選 0-1                                 │
│          ╱    ╲        ╱    ╲                               │
│      不選 0-2  選 0-2  不選 0-2  選 0-2                     │
│      ...                                                    │
│                                                             │
│  每一層 = 一條邊的決定。                                    │
│  深度 = 6（六條邊六個決定）。                               │
│  葉節點 = 64 個。                                           │
│                                                             │
│  但你不需要走到每個葉節點。                                 │
│  如果在某一步，你選了一條邊之後發現「已經形成環了」——       │
│  那這條邊之後的所有選擇都不用看了。                         │
│  直接「回退」到上一步，選另一個分支。                       │
│                                                             │
│  這就是 Backtracking。                                      │
│                                                             │
│  想三十秒：什麼時候選一條邊會形成環？                       │
│  提示：如果兩個端點已經連通......                            │
└─────────────────────────────────────────────────────────────┘
```

「如果兩個端點已經在同一個連通分量裡，再加一條邊就會成環！」
阿翔喊出來。

「沒錯。上一章的 Union-Find 可以 O(1) 判斷。」

我在白板上畫出回溯的過程：

```
  邊的順序：e0=0-1, e1=0-2, e2=0-3, e3=1-2, e4=1-3, e5=2-3

  ┌─ Backtracking Tree（部分）────────────────────────────┐
  │                                                       │
  │                        {}                              │
  │                    ╱        ╲                          │
  │             不選 e0           選 e0 {0-1}             │
  │           ╱      ╲          ╱        ╲                │
  │       不選 e1   選 e1   不選 e1    選 e1              │
  │       {}       {0-2}   {0-1}     {0-1, 0-2}          │
  │                                   ╱        ╲         │
  │                              不選 e2     選 e2        │
  │                                          {0-1,0-2,0-3}│
  │                                          ╱      ╲     │
  │                                     不選 e3   選 e3   │
  │                                              {+1-2}   │
  │                                               │       │
  │                        0 和 2 已經連通（0-1-...2）     │
  │                        加 1-2 會成環！                  │
  │                        → ✂️ 剪枝！不往下走了           │
  │                                                       │
  └───────────────────────────────────────────────────────┘
```

「剪枝，」學姊說，「就是在樹的某個分支上，
提早發現『走下去不可能有答案』，然後直接砍掉整根分支。」

「就像走迷宮走到死路，你不會繼續往牆壁走，
你會回頭試另一條路，」阿翔說。

「完全正確。」

---

### 3.3　為什麼 Backtracking 有效？

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 偵探手札 #15 —— Backtracking 的核心                     │
│                                                             │
│  Backtracking = DFS + 剪枝 + 還原                          │
│                                                             │
│  1. DFS：一條路走到底。走完了或走不下去了就回頭。          │
│  2. 剪枝：在走的過程中，如果發現「不管怎麼選都不行了」，   │
│     提早放棄這個分支。省下大量時間。                        │
│  3. 還原：回頭的時候，把狀態恢復到上一步。                 │
│     就像什麼都沒發生過一樣。                               │
│                                                             │
│  Backtracking 的模板：                                      │
│                                                             │
│  def backtrack(目前的選擇, 目前的狀態):                     │
│      if 已經做完所有選擇:                                   │
│          記錄答案                                           │
│          return                                             │
│      for 每個可能的下一步:                                  │
│          if 這一步合法（剪枝條件）:                         │
│              做這個選擇（修改狀態）                         │
│              backtrack(下一步, 新狀態)                      │
│              撤銷這個選擇（還原狀態）  ← 關鍵！            │
│                                                             │
│  最後那行「撤銷」就是 backtracking 的靈魂。                │
│  你嘗試了一個選擇，探索了所有後果，                         │
│  然後把一切恢復原狀，再嘗試下一個選擇。                     │
│                                                             │
│  沒有撤銷 = 只是普通的 DFS。                               │
│  有撤銷 = Backtracking。                                   │
│                                                             │
│  為什麼要撤銷？                                             │
│  因為你要探索所有可能性。                                   │
│  如果不撤銷，上一個選擇的殘留會污染下一個選擇。            │
│                                                             │
│  經典應用：                                                 │
│  • 排列（Permutations）→ 選了就不能再選                    │
│  • 組合（Combinations）→ 選不選，但要避免重複              │
│  • 子集（Subsets）→ 每個元素選或不選                       │
│  • N-Queens → 每行放一個皇后，不能互相攻擊                │
│  • 數獨、迷宮、填字遊戲......                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

我跑了回溯程式。每選一條邊就用 Union-Find 檢查會不會成環。
如果會，就剪枝。

結果：**不含環的接線方式 = 61 種。**

螢幕接受了答案。

阿翔歡呼。但我注意到學姊的表情。她在盯著什麼。

「怎麼了？」

「......你不覺得奇怪嗎？」她說，
「三道題。Maximum Subarray、Edit Distance、列舉無環子圖。」

「一維 DP、二維 DP、Backtracking，」我說，「由簡到難的設計。」

「不只是由簡到難。」她指著螢幕，
「第一題只要一個數字（密碼）。第二題也只要一個數字。
但第三題要我們『列舉所有方案』。」

她頓了一下。

「出題者不只是在考我們會不會解題。
他是在考我們能不能區分——**什麼時候要找最優解，什麼時候要找所有解。**」

---

## 第四幕　Greedy——賭注與代價

### 4.1　第四道題：資源分配

螢幕上出現第四道題。

```
╔══════════════════════════════════════════════════════════════╗
║  [SYSTEM MESSAGE]                                            ║
║                                                              ║
║  最後一關。                                                  ║
║                                                              ║
║  ┌────────────────────────────────────────────────────┐     ║
║  │                                                    │     ║
║  │  伺服器有 4 個程序需要執行。                       │     ║
║  │  每個程序有「開始時間」和「結束時間」：             │     ║
║  │                                                    │     ║
║  │  程序 A：[1,  4]                                   │     ║
║  │  程序 B：[3,  5]                                   │     ║
║  │  程序 C：[0,  6]                                   │     ║
║  │  程序 D：[5,  7]                                   │     ║
║  │  程序 E：[3,  9]                                   │     ║
║  │  程序 F：[5,  9]                                   │     ║
║  │  程序 G：[6,  8]                                   │     ║
║  │                                                    │     ║
║  │  伺服器同一時間只能跑一個程序。                    │     ║
║  │  問：最多能跑幾個？選哪些？                        │     ║
║  │                                                    │     ║
║  └────────────────────────────────────────────────────┘     ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
```

Activity Selection Problem。又一道經典。

阿翔已經在用回溯了：「每個程序選或不選，
7 個程序就是 2⁷ = 128 種組合，扣掉衝突的——」

「等一下，」我打斷他，「這題不需要回溯。」

「咦？」

「這題有一個更簡單、更快的方法。」

---

### 4.2　貪心的直覺

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 暫停推理                                                │
│                                                             │
│  你想在有限的時間內塞進最多的程序。                         │
│  程序之間不能重疊。                                         │
│                                                             │
│  直覺上，你會怎麼選？                                       │
│                                                             │
│  (a) 先選最短的程序？                                       │
│  (b) 先選最早開始的？                                       │
│  (c) 先選最早結束的？                                       │
│                                                             │
│  哪一個策略能保證最多？為什麼？                             │
│                                                             │
│  想三十秒。                                                 │
└─────────────────────────────────────────────────────────────┘
```

我在白板上畫時間線：

```
  時間軸：0   1   2   3   4   5   6   7   8   9

  C：[████████████████████████████]
  A：    [████████████]
  B：            [████████]
  E：            [████████████████████████]
  D：                        [████████]
  F：                        [████████████████]
  G：                            [████████]

  按結束時間排序：

  A [1,4]   ← 最早結束
  B [3,5]
  C [0,6]
  D [5,7]
  G [6,8]
  E [3,9]
  F [5,9]
```

「先選最早結束的，」我說。

「為什麼不是最早開始的？」阿翔問。

「因為我們要最大化數量。一個程序越早結束，
就越早把時間讓出來給下一個。」

```
  貪心策略：每次選「目前可以選的、結束時間最早的」。

  Step 1：可選全部。結束最早 = A [1,4]。選 A。
          時間軸被佔：[1, 4]
          ✓ A ──────────

  Step 2：開始時間 ≥ 4 的有：D [5,7], G [6,8], E [3,9]...
          等等，B [3,5] 的開始時間 3 < 4，衝突。
          C [0,6] 的開始時間 0 < 4，衝突。
          E [3,9] 開始時間 3 < 4，衝突。
          剩下可選的：D [5,7], F [5,9], G [6,8]
          結束最早 = D [5,7]。選 D。
          ✓ A ──── D ────

  Step 3：開始時間 ≥ 7 的有：G [6,8]? 不行，6 < 7。
          F [5,9]? 不行。
          沒了？

  等等——G 的開始時間是 6，但 D 在 7 才結束。6 < 7，衝突。

  結果：選了 A 和 D，共 2 個。

  但......如果我們改選 A 和 G 呢？
  A [1,4] 結束後，G [6,8]，開始 6 ≥ 4，不衝突！
  那是 A → G → ???
  G 在 8 結束，之後沒了。也是 2 個。

  或者 A [1,4] → D [5,7] → ??? 之後沒有了。2 個。

  再試：B [3,5] → D [5,7] → ???  G [6,8]?  6 < 7。不行。2 個。

  那 A [1,4] → B [3,5]? 不行，3 < 4。

  A [1,4] → D [5,7] 就是最優。2 個？

  不對——讓我重新看。G 的開始是 6，D 結束是 7。6 < 7 確實衝突。

  但：A [1,4] → G [6,8]。中間 [4,6] 空著。也是 2 個。

  最多就是 3 個嗎？ A[1,4] → D[5,7] 只有 2 個？

  等等：A 結束 4，D 開始 5 ≥ 4 ✓。D 結束 7，G 開始 6 < 7 ✗。

  如果：A[1,4] → D[5,7]  → 沒了。= 2
  如果：A[1,4] → G[6,8]  → 沒了。= 2
  如果：B[3,5] → D[5,7]  → 沒了。= 2
  如果：B[3,5] → G[6,8]  → 沒了。= 2

  最多 = 3？讓我想想......
  A[1,4] → B? 不行(3<4)。

  嗯，答案就是 2。
```

我重新確認：答案是 **3**——等等，我算錯了。
讓我重新畫。

```
  等等，我漏看了。再整理一次：

  結束時間排序：A[1,4], B[3,5], C[0,6], D[5,7], G[6,8], E[3,9], F[5,9]

  Greedy：
  1. 選 A [1,4]。下次要 start ≥ 4。
  2. B start=3 < 4 ✗, C start=0 ✗, D start=5 ≥ 4 ✓ → 選 D [5,7]
  3. 下次要 start ≥ 7。G start=6 ✗, E start=3 ✗, F start=5 ✗。
  → 沒了。

  答案 = 2。但讓我 double check：
  A[1,4] → G[6,8]? G start=6 ≥ 4 ✓。然後 start ≥ 8。沒了。也是 2。

  答案 = 2。
```

「2，」我說。

學姊輸入。通過。

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 偵探手札 #16 —— Greedy 什麼時候有效？                   │
│                                                             │
│  Greedy = 每一步都做「當下看起來最好」的選擇。              │
│  不回頭，不後悔。                                           │
│                                                             │
│  聽起來很冒險。為什麼 Activity Selection 可以用 Greedy？    │
│                                                             │
│  因為它有「貪心選擇性質」（Greedy Choice Property）：       │
│                                                             │
│  「存在一個最優解包含貪心的第一步」。                       │
│                                                             │
│  具體來說：                                                 │
│  假設最優解沒有選「最早結束的程序 A」。                     │
│  那最優解選了某個其他程序 X 當第一個。                      │
│  X 的結束時間 ≥ A 的結束時間（因為 A 最早結束）。          │
│  把 X 換成 A → 空出來的時間只會更多或相等 → 不會更差。     │
│  → 所以存在一個「至少一樣好」的最優解包含 A。              │
│  → Greedy 的第一步是安全的。                               │
│  → 遞推下去，每一步都安全 → 整個策略最優。                │
│                                                             │
│  ──────────────────────────────────────────                 │
│                                                             │
│  Greedy vs DP：                                             │
│                                                             │
│  Greedy：每步只看局部最優。快。O(n log n)。                │
│          但只在特定條件下正確（需要證明）。                 │
│                                                             │
│  DP：考慮所有子問題的組合。慢一點。                        │
│      但永遠正確（只要定義好狀態和轉移）。                  │
│                                                             │
│  Greedy 是 DP 的「特例」——                                  │
│  當最優解可以用局部最優推出來時，不需要記錄所有子問題。     │
│                                                             │
│  什麼時候 Greedy 會失敗？                                   │
│  背包問題：物品有重量和價值。                               │
│  貪心選 CP 值最高的？不行。可能裝不滿。                    │
│  → 需要 DP。                                               │
│                                                             │
│  經驗法則：                                                 │
│  如果不確定 Greedy 行不行 → 先想 DP。                      │
│  如果能證明 Greedy 正確 → 用 Greedy（更快更簡潔）。        │
│  面試時：先說「我覺得可以 Greedy」，然後簡短論證為什麼。   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 第五幕　Stack——時間倒轉

### 5.1　最後的訊息

四道題全部通過。螢幕上出現了最後一段訊息。

```
╔══════════════════════════════════════════════════════════════╗
║  [SYSTEM MESSAGE]                                            ║
║                                                              ║
║  四關全過。                                                  ║
║                                                              ║
║  你們比我預期的快。                                          ║
║                                                              ║
║  最後，我不是在問你們問題了。我要告訴你們答案。             ║
║                                                              ║
║  我在系統裡留了一份加密的日誌。                              ║
║  它記錄了去年資安事件的真正經過。                            ║
║  那次事件——不是我做的。但我知道是誰做的。                    ║
║  而我沒有辦法用正常的方式公開。                              ║
║                                                              ║
║  所以我做了這一切。                                          ║
║  打亂資料庫、藏圖、設關卡。                                  ║
║  因為我需要一個夠聰明的人找到這份日誌。                      ║
║                                                              ║
║  日誌被拆成碎片，散佈在系統的操作歷史中。                    ║
║  你們需要按照正確的順序拼回來。                              ║
║                                                              ║
║  拼裝規則：每個碎片都引用了前一個碎片的 hash。               ║
║  最新的碎片在最上面。你們需要從最新的往回追溯。             ║
║                                                              ║
║  這是一個 Stack。後進先出。                                  ║
║  最新的碎片先被找到，但它指向更早的碎片。                    ║
║  你們得一層一層 pop 回去，直到第一個碎片。                   ║
║                                                              ║
║  祝你們好運。                                                ║
║                                                              ║
║                                           — #50742           ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
```

房間裡安靜了很久。

「所以......」阿翔的聲音有點抖，「鄭宇翔不是壞人？」

「他在吹哨，」我說，「用一個只有工程師才能解開的方式。」

學姊已經在找那些碎片了。

---

### 5.2　用 Stack 拼回時間

```
  碎片的結構：

  每個碎片 = {
      content:  "一段日誌內容",
      hash:     "這個碎片自己的 hash",
      prev:     "前一個碎片的 hash"     ← 指向更早的碎片
  }

  它們散佈在系統的不同角落。
  我們找到的順序不一定對。
  但每個碎片都告訴你「上一塊是誰」。

  這就像一條鎖鏈。你拉起最新的一環，它帶出前一環，
  前一環帶出更前一環......直到最初的那環。
```

```
  ┌──────────────────────────────────────────────────────┐
  │                                                      │
  │  找到碎片的順序（散亂的）：                          │
  │                                                      │
  │  碎片 D: hash="d3f2", prev="a1b0", content="......4" │
  │  碎片 A: hash="x7c9", prev=null,   content="......1" │
  │  碎片 C: hash="a1b0", prev="k4m2", content="......3" │
  │  碎片 B: hash="k4m2", prev="x7c9", content="......2" │
  │                                                      │
  │  用 HashMap 建索引：hash → 碎片                      │
  │                                                      │
  │  從最新的碎片（prev 沒有被任何人引用的那個）開始，    │
  │  往回追溯：                                          │
  │                                                      │
  │  碎片 D → prev="a1b0" → 碎片 C                      │
  │  碎片 C → prev="k4m2" → 碎片 B                      │
  │  碎片 B → prev="x7c9" → 碎片 A                      │
  │  碎片 A → prev=null   → 到底了！                     │
  │                                                      │
  │  追溯順序（Stack pop）：D, C, B, A                   │
  │  正確順序（反轉後）：  A, B, C, D                    │
  │                                                      │
  │  Stack:                                               │
  │  push D → push C → push B → push A                  │
  │  [D, C, B, A]                                        │
  │  pop A → pop B → pop C → pop D                      │
  │  → 時間正序：A → B → C → D                          │
  │                                                      │
  └──────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 偵探手札 #17 —— Stack 的本質：逆轉時間                  │
│                                                             │
│  Stack = 後進先出（LIFO）                                   │
│                                                             │
│  為什麼 Stack 在這裡派上用場？                              │
│                                                             │
│  因為我們在「逆轉」一個過程。                               │
│                                                             │
│  碎片是按時間順序產生的：A → B → C → D。                   │
│  但我們找到的是最新的 D，要往回追到 A。                     │
│  追溯是「反方向」的。                                       │
│                                                             │
│  Stack 天生就是用來「反轉順序」的工具：                     │
│  你把東西一個一個放進去，再一個一個拿出來，順序就反了。     │
│                                                             │
│  Stack 在程式設計裡的經典用途：                             │
│                                                             │
│  • 函數呼叫（Call Stack）：                                │
│    最後被呼叫的函數，最先 return。                          │
│    → 遞迴就是靠 Stack 記住「回到哪裡」。                   │
│                                                             │
│  • 括號匹配：                                               │
│    看到 ( 就 push，看到 ) 就 pop。                          │
│    如果 pop 出來的跟 ) 配對 → 合法。                       │
│    → 最後開的括號最先關。                                   │
│                                                             │
│  • Undo/Redo：                                              │
│    每個操作 push 到 undo stack。                            │
│    按 Ctrl+Z → pop 最近的操作 → 還原。                     │
│    → 最後的操作最先被撤銷。                                │
│                                                             │
│  • 瀏覽器的上一頁：                                         │
│    每訪問一個網頁就 push。按「返回」就 pop。               │
│    → 你回到的是「最近訪問的」那個頁面。                    │
│                                                             │
│  共同點：需要「逆序」的場景。                               │
│  Stack 是程式世界裡的「時光機」。                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### 5.3　日誌的內容

學姊從系統的各個角落找出了所有碎片。
用 HashMap 建索引，用 Stack 追溯，拼回正確順序。

最終的日誌出現在螢幕上。

```
╔══════════════════════════════════════════════════════════════╗
║  [DECRYPTED LOG]  #50742 的完整日誌                         ║
╠══════════════════════════════════════════════════════════════╣
║                                                              ║
║  2024-09-15                                                  ║
║  我發現校務系統有一個嚴重的安全漏洞。                        ║
║  選課資料庫的存取權限沒有正確設定。                          ║
║  任何有 read 權限的人都可以提升到 write。                    ║
║                                                              ║
║  2024-09-22                                                  ║
║  我向吳教授報告了這個問題。他說會處理。                      ║
║  但兩週過去了，什麼都沒改。                                  ║
║                                                              ║
║  2024-10-10                                                  ║
║  我發現有人已經在利用這個漏洞了。                            ║
║  有不明的 query 在深夜存取學生的個資。                       ║
║  來源 IP 指向......系計中內部。                              ║
║                                                              ║
║  2024-10-18                                                  ║
║  我收集了證據，但不知道該給誰。                              ║
║  吳教授沒有行動。如果我直接公開，可能被當成洩漏者。         ║
║  利用漏洞的人可能有內部權限。                                ║
║                                                              ║
║  2024-11-06                                                  ║
║  我決定用另一種方式。                                        ║
║  我要在資料庫裡留下一個訊號。                                ║
║  一個只有懂演算法的人才能解讀的訊號。                        ║
║  打亂、藏圖、設謎題。                                        ║
║  如果有人能走到這一步——他們就是對的人。                      ║
║                                                              ║
║  希望你們能看到這個。                                        ║
║                                                              ║
║                                           — 鄭宇翔          ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
```

房間裡沒有人說話。

阿翔摘下眼鏡擦了擦。我不確定他是在擦鏡片還是在擦眼角。

吳教授站在角落，臉色很複雜。

學姊關上筆電。

---

## 終幕　偵探的結語

下午五點。夕陽從系館的窗戶灑進來，把走廊染成橘色。

我們四個人走出伺服器室。吳教授拿著那份日誌的列印，
說他要直接去找系主任和資安中心。

阿翔去買晚餐了。他說用腦過度需要雞排補充。

走廊上只剩我和學姊。

「學姊。」

「嗯？」

「你一開始就猜到了吧。這不是攻擊，是求助。」

她沒正面回答。

「你有沒有發現，」她說，「我們今天用到的每一個演算法，
都對應一種思考方式？」

我想了想。

```
  Binary Search  →  用一個問題砍掉一半的可能性
  HashMap        →  不搜尋，用計算直接到達
  Two Pointers   →  利用結構，讓比對不回頭
  Sorting        →  先付出代價賦予秩序，後面一路省力
  BFS            →  一圈一圈擴散，保證最近的先到
  DFS            →  一條路走到底，走錯了再回頭
  Union-Find     →  快速判斷兩個東西是不是同一群的
  Dijkstra       →  在不同代價的選項中找最短路
  Topological Sort → 依照因果關係排出先後順序
  DP             →  記住過去的答案，用來推導未來
  Backtracking   →  嘗試所有可能，走錯就撤銷
  Greedy         →  每步選當下最好的，有時候就是最優的
  Stack          →  逆轉順序，回到過去
```

「這些不是只能用在 LeetCode 上的東西，」學姊說。

「我知道。」

「在分析任何問題的時候，你都可以問自己：」

她看著窗外的夕陽。

「我需要**排除**可能性嗎？—— Binary Search。」
「我需要快速**記住**什麼嗎？—— HashMap。」
「我需要看到**全貌**嗎？—— BFS。」
「我需要走一條**深入**的路嗎？—— DFS。」
「我需要找**最佳**方案嗎？—— DP 或 Greedy。」
「我需要**嘗試所有**可能嗎？—— Backtracking。」
「我需要**倒推**嗎？—— Stack。」
「我需要知道**因果順序**嗎？—— Topological Sort。」

「演算法是工具。但也是思考的框架。」

她轉過來看我。夕陽在她背後。

「記住了嗎？」

「記住了。」

她微微笑了一下。然後轉身走了。

走了幾步，她忽然停下來，回頭。

「下次不要在凌晨三點把我當成鬧鐘。」

「那是你打給我的——」

但她已經走遠了。

---

## 偵探手札　最終回

```
╔══════════════════════════════════════════════════════════════╗
║                                                              ║
║   ┌─────────────────────────────────────────────────────┐   ║
║   │         📓 偵 探 手 札 — 最 終 回                    │   ║
║   └─────────────────────────────────────────────────────┘   ║
║                                                              ║
║   案件結果：                                                 ║
║   鄭宇翔（#50742 = 自己建的後門帳號）                       ║
║   發現系統漏洞 → 通報無果 → 自行留下加密線索               ║
║   → 我們解開了 → 日誌轉交資安中心                          ║
║                                                              ║
║   ─── 全案使用的演算法 ───                                   ║
║                                                              ║
║   ┌──────────────┬────────────────┬──────────────────┐      ║
║   │   演算法     │  用在哪裡      │  核心直覺        │      ║
║   ├──────────────┼────────────────┼──────────────────┤      ║
║   │Binary Search │ 定位入侵時間   │ 每問一次砍一半   │      ║
║   │HashMap       │ 找重複資料     │ 用計算代替搜尋   │      ║
║   │Two Pointers  │ 比對兩版資料   │ 排序帶來單調性   │      ║
║   │Sorting       │ 分析打亂方式   │ 結構是效率的根基 │      ║
║   │BFS           │ 圖的分層展開   │ 水波最短路       │      ║
║   │DFS           │ 環偵測 / 路徑  │ 一條路走到底     │      ║
║   │Union-Find    │ 快速分群       │ 越用越快的結構   │      ║
║   │Dijkstra      │ 加權最短路     │ 永遠先處理最近的 │      ║
║   │Topo Sort     │ 重建操作順序   │ 因果關係的線性化 │      ║
║   │DP            │ 最大子區間和   │ 記住過去推導未來 │      ║
║   │DP (2D)       │ 編輯距離       │ 狀態的維度       │      ║
║   │Backtracking  │ 列舉無環子圖   │ 嘗試+剪枝+撤銷   │      ║
║   │Greedy        │ 活動選擇       │ 局部最優=全局最優 │      ║
║   │Stack         │ 拼回日誌碎片   │ 逆轉時間的工具   │      ║
║   └──────────────┴────────────────┴──────────────────┘      ║
║                                                              ║
║   ─── 最重要的三件事 ───                                     ║
║                                                              ║
║   1.「排序是一切的根基。」                                   ║
║      Binary Search、Two Pointers、Greedy、                   ║
║      很多 DP 的優化——全都建立在排序之上。                    ║
║      沒有結構的資料，什麼都做不了。                          ║
║                                                              ║
║   2.「DP = 記住 + 推導。Greedy = DP 的捷徑。                ║
║      Backtracking = 窮舉但聰明地剪。」                       ║
║      三者是同一條光譜上的不同點。                            ║
║      Greedy（O(n)）← DP（O(n²)）← Backtracking（O(2ⁿ)）   ║
║      能 Greedy 就 Greedy。不行就 DP。都不行就 Backtrack。   ║
║                                                              ║
║   3.「每個演算法都是一種提問方式。」                         ║
║      不是「這題要用什麼演算法」。                            ║
║      而是「我現在需要什麼角度來看這個問題」。               ║
║      需要找最佳？DP。需要找所有？Backtracking。             ║
║      需要最短路？BFS/Dijkstra。需要排除？Binary Search。   ║
║      需要記住？HashMap。需要倒推？Stack。                   ║
║                                                              ║
║   ─── 後記 ───                                               ║
║                                                              ║
║   一週後，系計中修補了那個漏洞。                             ║
║   鄭宇翔因為「未經授權操作伺服器」被記了一支申誡。          ║
║   但同時也因為「揭發安全漏洞」收到了資安中心的感謝狀。     ║
║                                                              ║
║   他後來加入了學校的紅隊（Red Team），                       ║
║   專門負責找漏洞。聽說做得很好。                             ║
║                                                              ║
║   阿翔說他因為這件事開始認真刷 LeetCode 了。                ║
║   但他的方法還是全都用暴力解。                               ║
║   有些事情不會變的。                                         ║
║                                                              ║
║   至於學姊——                                                 ║
║   她畢業之後去了 Google Taipei 的 SRE 團隊。                ║
║   離開前，她留給我一句話：                                   ║
║                                                              ║
║   「演算法不是終點。它是讓你看見問題本質的透鏡。            ║
║     問題會一直變，但透鏡不會。                               ║
║     把透鏡磨好。」                                           ║
║                                                              ║
║                                                              ║
║                             —— 林凱                          ║
║                             寫於那年冬天，新竹的風還是很冷   ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
```

---

> *《演算法偵探筆記》三部曲　—— 完 ——*

---

### 附錄：三部曲演算法索引

```
  想複習某個演算法的原理？回到對應的章節：

  ┌─ 上篇（被打亂的伺服器）──────────────────────────────┐
  │  Binary Search ·· 為什麼砍半就夠了（資訊理論角度）    │
  │  HashMap ········ 為什麼是 O(1)（計算代替搜尋）       │
  │  Two Pointers ··· 為什麼不回頭（排序的單調性）        │
  │  Sorting ········ 為什麼排序是投資（結構帶來效率）     │
  └──────────────────────────────────────────────────────┘

  ┌─ 中篇（社群網路的裂痕）──────────────────────────────┐
  │  Graph / BFS ···· 為什麼 BFS 保證最短（FIFO = 水波）  │
  │  DFS ··········· 遞迴 = 隱形 Stack                    │
  │  Cycle Detection  三色標記法（WHITE/GRAY/BLACK）       │
  │  Union-Find ···· 越用越快（路徑壓縮 + 按秩合併）      │
  │  Dijkstra ······ 加權最短路（Heap 取代 Queue）         │
  │  Topological Sort 因果的線性化（Kahn's Algorithm）     │
  └──────────────────────────────────────────────────────┘

  ┌─ 下篇（時間迴廊的最後推理）─────────────────────────┐
  │  DP (1D) ······· Maximum Subarray（記住上一步）        │
  │  DP (2D) ······· Edit Distance（狀態的維度）           │
  │  Backtracking ·· 嘗試所有可能 + 剪枝 + 撤銷           │
  │  Greedy ········ 局部最優 → 全局最優（需要證明）       │
  │  Stack ········· 逆轉順序的時光機                      │
  └──────────────────────────────────────────────────────┘
```
