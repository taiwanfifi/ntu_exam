# 演算法 題型鑑別指南

> **核心目的**：看到題目，立刻判斷用什麼演算法、什麼技巧、什麼證明方法。
> **本指南特色**：每個演算法都用小例子走一遍，讓你真正「會跑」，而不只是「知道名字」。

---

# 第一部分：最佳化問題 — DP vs Greedy vs D&C

## 決策流程圖

```
你要解一個最佳化問題
    │
    ├── 問題有最優子結構？ ──No──→ 暴力搜索 / 其他
    │        │
    │       Yes
    │        │
    ├── 貪心選擇性質成立？ ──Yes──→ Greedy ✓
    │        │                      （通常 O(n log n)）
    │       No / 不確定
    │        │
    ├── 子問題有重疊？ ──Yes──→ DP ✓
    │        │                  （通常 O(n²) 或 O(nW)）
    │       No
    │        │
    └── 子問題獨立？ ──Yes──→ Divide & Conquer ✓
                              （通常 O(n log n)）
```

## DP vs Greedy 核心差異

| | DP | Greedy |
|---|---|---|
| **決策方式** | 考慮所有子問題後做最佳選擇 | 每步做局部最佳選擇，不回頭 |
| **保證最優？** | 總是最優 | 需要證明（Exchange Argument） |
| **時間** | 通常較慢（填表） | 通常較快（一次掃描） |
| **典型** | Knapsack, LCS, Shortest Path | Activity Selection, Huffman, MST |

> **用 Greedy vs DP 同一個問題看差異**：
>
> **Fractional Knapsack**（物品可切割）→ **Greedy** ✓
>
> 背包容量 $W = 10$，物品：A(重6, 值30), B(重5, 值20), C(重5, 值15)
>
> CP 值：A = 30/6 = 5, B = 20/5 = 4, C = 15/5 = 3
>
> Greedy：先拿 A(全部6kg, 值30) → 剩4kg → 拿 B 的 4/5(值16) → **總值 = 46**
>
> ---
>
> **0/1 Knapsack**（物品不可切割）→ 必須用 **DP**
>
> 同樣物品，Greedy 先拿 A → 剩 4kg → B、C 都放不下 → **Greedy 得 30**
>
> 但最佳解是拿 B + C → 恰好 10kg → **DP 得 35** ← Greedy 失敗！
>
> **教訓**：0/1 限制讓 Greedy 失效，必須用 DP。

---

## Greedy 經典問題 + 數值範例

### Activity Selection（選最多不重疊活動）

**策略**：按結束時間排序，選最早結束的。

> **範例**：活動 (start, end) = {A(1,3), B(2,5), C(4,7), D(6,8), E(5,9), F(8,10)}
>
> 按結束時間排序：A(1,3), B(2,5), C(4,7), D(6,8), E(5,9), F(8,10)
>
> Step 1：選 A(1,3) → 下一個開始 ≥ 3 的
>
> Step 2：B(2,5) 不行（2 < 3），C(4,7) 可以 → 選 C(4,7)
>
> Step 3：D(6,8) 不行（6 < 7），E(5,9) 不行，F(8,10) 可以 → 選 F(8,10)
>
> **答案**：選了 {A, C, F} = 3 個活動，這是最多的。

### Huffman Coding（最小平均碼長）

**策略**：每次合併頻率最小的兩個節點。

> **範例**：字元頻率 a:5, b:9, c:12, d:13, e:16, f:45
>
> Step 1：合併最小 a(5) + b(9) = ab(14)
>
> Step 2：合併 c(12) + d(13) = cd(25)
>
> Step 3：合併 ab(14) + e(16) = abe(30)
>
> Step 4：合併 cd(25) + abe(30) = cdabe(55)
>
> Step 5：合併 f(45) + cdabe(55) = root(100)
>
> 編碼：f = 0 (1 bit), c = 100 (3 bits), d = 101 (3 bits), a = 1100 (4 bits), b = 1101 (4 bits), e = 111 (3 bits)
>
> 平均碼長 = (45×1 + 12×3 + 13×3 + 5×4 + 9×4 + 16×3) / 100 = (45+36+39+20+36+48)/100 = 224/100 = **2.24 bits/字元**
>
> 固定長度編碼需要 $\lceil \log_2 6 \rceil = 3$ bits/字元，Huffman 省了 25%！

---

## DP 經典問題 + 數值範例

### 0/1 Knapsack（填表法）

> **範例**：背包容量 $W = 7$，物品：
>
> | 物品 | 重量 | 價值 |
> |------|------|------|
> | A | 1 | 1 |
> | B | 3 | 4 |
> | C | 4 | 5 |
> | D | 5 | 7 |
>
> $dp[i][w]$ = 前 $i$ 個物品、容量 $w$ 時的最大價值
>
> 遞迴式：$dp[i][w] = \max(dp[i-1][w], \; dp[i-1][w-w_i] + v_i)$
>
> 填表結果：
>
> | | w=0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
> |--|-----|---|---|---|---|---|---|---|
> | 0(無) | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
> | A(1,1) | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
> | B(3,4) | 0 | 1 | 1 | 4 | 5 | 5 | 5 | 5 |
> | C(4,5) | 0 | 1 | 1 | 4 | 5 | 6 | 6 | 9 |
> | D(5,7) | 0 | 1 | 1 | 4 | 5 | 7 | 8 | 9 |
>
> **答案**：$dp[4][7] = 9$（選 B + C，重量 3+4=7，價值 4+5=9）
>
> **複雜度**：$O(nW) = O(4 \times 7) = O(28)$，pseudo-polynomial

### LCS（最長公共子序列）

> **範例**：$X = $ "ABCBDAB"，$Y = $ "BDCAB"
>
> $dp[i][j]$ = $X[1..i]$ 和 $Y[1..j]$ 的 LCS 長度
>
> 遞迴式：若 $X[i] = Y[j]$，$dp[i][j] = dp[i-1][j-1] + 1$；否則 $dp[i][j] = \max(dp[i-1][j], dp[i][j-1])$
>
> | | "" | B | D | C | A | B |
> |--|---|---|---|---|---|---|
> | "" | 0 | 0 | 0 | 0 | 0 | 0 |
> | A | 0 | 0 | 0 | 0 | **1** | 1 |
> | B | 0 | **1** | 1 | 1 | 1 | **2** |
> | C | 0 | 1 | 1 | **2** | 2 | 2 |
> | B | 0 | **1** | 1 | 2 | 2 | **3** |
> | D | 0 | 1 | **2** | 2 | 2 | 3 |
> | A | 0 | 1 | 2 | 2 | **3** | 3 |
> | B | 0 | **1** | 2 | 2 | 3 | **4** |
>
> **答案**：LCS 長度 = 4，回溯得 "BCAB"
>
> **複雜度**：$O(mn) = O(7 \times 5) = O(35)$

### Matrix Chain Multiplication

> **範例**：矩陣維度 $A_1(10 \times 30)$, $A_2(30 \times 5)$, $A_3(5 \times 60)$
>
> $dp[i][j]$ = 乘 $A_i$ 到 $A_j$ 的最少乘法數
>
> $dp[1][2] = 10 \times 30 \times 5 = 1500$
>
> $dp[2][3] = 30 \times 5 \times 60 = 9000$
>
> $dp[1][3] = \min\begin{cases} dp[1][1] + dp[2][3] + 10 \times 30 \times 60 = 0 + 9000 + 18000 = 27000 \\ dp[1][2] + dp[3][3] + 10 \times 5 \times 60 = 1500 + 0 + 3000 = 4500 \end{cases}$
>
> **答案**：最少 4500 次乘法，括號為 $(A_1 \cdot A_2) \cdot A_3$
>
> 如果不括號直接從左到右乘：$10 \times 30 \times 5 + 10 \times 5 \times 60 = 1500 + 3000 = 4500$（恰好一樣）
>
> 但如果先乘右邊：$30 \times 5 \times 60 + 10 \times 30 \times 60 = 9000 + 18000 = 27000$（差 6 倍！）

---

## Divide & Conquer 經典問題 + 數值範例

### Merge Sort（步驟追蹤）

> **範例**：排序 [38, 27, 43, 3, 9, 82, 10]
>
> **分**：[38,27,43,3] | [9,82,10]
>
> 繼續分：[38,27] | [43,3] | [9,82] | [10]
>
> 繼續分：[38] [27] | [43] [3] | [9] [82] | [10]
>
> **合**（merge）：
>
> [27,38] | [3,43] | [9,82] | [10]
>
> [3,27,38,43] | [9,10,82]
>
> [3,9,10,27,38,43,82] ✓
>
> **複雜度**：$T(n) = 2T(n/2) + O(n)$ → Master Theorem Case 2 → $O(n \log n)$

### Counting Inversions

> **範例**：陣列 [2, 4, 1, 3, 5]，inversion = 一對 $(i,j)$ 使得 $i < j$ 但 $A[i] > A[j]$
>
> 所有 inversions：(2,1), (4,1), (4,3) → 共 **3 個**
>
> 用 merge sort 方式計算：分成 [2,4,1] 和 [3,5]
>
> 左半的 inversions：(2,1), (4,1) = 2 個
>
> 右半的 inversions：0 個
>
> 跨越的 inversions（merge 時計數）：(4,3) = 1 個
>
> 總共 = 2 + 0 + 1 = **3** ✓

---

# 第二部分：圖論問題 + 數值範例

## BFS vs DFS — 什麼時候用哪個？

| 需求 | BFS | DFS |
|------|-----|-----|
| 最短路（無權） | ✓ | ✗ |
| 環偵測 | ✓ | ✓（back edge） |
| 拓撲排序 | ✓（Kahn's） | ✓（finish time） |
| SCC | ✗ | ✓（Kosaraju/Tarjan） |
| 二部圖判斷 | ✓ | ✓ |

### BFS 追蹤範例（最短路徑）

> **圖**（無權）：
> ```
> 0 — 1 — 3
> |       |
> 2 — — — 4
> ```
> 邊：(0,1), (0,2), (1,3), (2,4), (3,4)
>
> **從節點 0 開始 BFS**：
>
> | 步驟 | Queue | 訪問 | dist[] |
> |------|-------|------|--------|
> | 初始 | [0] | - | [0,∞,∞,∞,∞] |
> | 1 | [1,2] | 0 | [0,1,1,∞,∞] |
> | 2 | [2,3] | 1 | [0,1,1,2,∞] |
> | 3 | [3,4] | 2 | [0,1,1,2,2] |
> | 4 | [4] | 3 | [0,1,1,2,2] |
> | 5 | [] | 4 | [0,1,1,2,2] |
>
> **答案**：dist[3] = 2, dist[4] = 2（都是距離 0 兩步）

### DFS 追蹤範例（拓撲排序）

> **DAG**：課程先修關係
> ```
> 微積分(A) → 線代(C) → 機率(E)
> 微積分(A) → 離數(D)
> 程設(B) → 離數(D) → 演算法(F)
>                       機率(E) → 演算法(F)
> ```
>
> **DFS（記 finish time）**：
>
> 從 A 開始 → A → C → E → F (finish F=1, E=2) → 回 C (finish C=3) → D (finish D=4) → 回 A (finish A=5) → B (finish B=6)
>
> **拓撲排序**（finish time 遞減）：B, A, D, C, E, F
>
> 意思是：先修 B 或 A → 再修 D 或 C → 再修 E → 最後 F ✓

---

# 第三部分：最短路徑 + 數值範例

## 選擇算法的決策

```
最短路徑
  ├── 無權圖？ → BFS O(V+E)
  ├── 非負權？ → Dijkstra O(E + V log V)
  ├── 有負權？ → Bellman-Ford O(VE)
  ├── DAG？ → 拓撲排序 + relax O(V+E)
  └── All pairs？ → Floyd-Warshall O(V³)
```

### Dijkstra 追蹤範例

> **圖**（非負權）：
> ```
>     1 ──2── 3
>    /|       |
>   4 |       1
>  /  3       |
> 0   |       4
>  \  2       |
>   1 |       3
>    \|       |
>     2 ──5──
> ```
> 邊：0→1(4), 0→2(1), 1→3(2), 2→1(2), 2→3(5), 3→4(1), 2→4(3)
>
> **從 0 開始 Dijkstra**：
>
> | 步驟 | 取出 | dist[0] | dist[1] | dist[2] | dist[3] | dist[4] |
> |------|------|---------|---------|---------|---------|---------|
> | 初始 | - | 0 | ∞ | ∞ | ∞ | ∞ |
> | 1 | 0 | **0** | 4 | 1 | ∞ | ∞ |
> | 2 | 2 | 0 | 3 | **1** | 6 | 4 |
> | 3 | 1 | 0 | **3** | 1 | 5 | 4 |
> | 4 | 4 | 0 | 3 | 1 | 5 | **4** |
> | 5 | 3 | 0 | 3 | 1 | **5** | 4 |
>
> **答案**：0→2→1→3 距離 5，0→2→4 距離 4
>
> **關鍵**：dist[1] 先是 4（直接 0→1），後被更新為 3（繞道 0→2→1），因為 1+2 < 4

### Bellman-Ford（可處理負權）

> **圖**：邊 (u,v,w) = {(s,a,4), (s,b,5), (a,b,-2), (b,c,3), (a,c,6)}
>
> | 輪次 | dist[s] | dist[a] | dist[b] | dist[c] |
> |------|---------|---------|---------|---------|
> | 初始 | 0 | ∞ | ∞ | ∞ |
> | 1 | 0 | 4 | 2 | 5 |
> | 2 | 0 | 4 | 2 | 5 |
>
> Round 1：s→a: dist[a]=4, s→b: dist[b]=5, a→b: dist[b]=min(5, 4-2)=**2**, b→c: dist[c]=5, a→c: dist[c]=min(∞, 4+6)=10 → 但 b→c 給 dist[c]=min(10, 2+3)=**5**
>
> Round 2：無更新 → 收斂
>
> **答案**：s→a→b→c = 4+(-2)+3 = **5**

### 為什麼 Dijkstra 不能處理負權？

> **反例**：s→a = 1, s→b = 5, b→a = -10
>
> Dijkstra 第一步取出 a（dist=1），鎖定 dist[a]=1
>
> 但實際最短路：s→b→a = 5+(-10) = **-5** < 1
>
> Dijkstra 不會回去更新已確定的節點！

### Floyd-Warshall（All Pairs）

> **圖**（4 個頂點）：
>
> 初始距離矩陣（∞ 表示不直接相連）：
>
> |   | 0 | 1 | 2 | 3 |
> |---|---|---|---|---|
> | 0 | 0 | 3 | ∞ | 7 |
> | 1 | 8 | 0 | 2 | ∞ |
> | 2 | 5 | ∞ | 0 | 1 |
> | 3 | 2 | ∞ | ∞ | 0 |
>
> 核心：$dp[i][j] = \min(dp[i][j], \; dp[i][k] + dp[k][j])$，對 $k = 0,1,2,3$
>
> k=0 後：dist[1][3] = min(∞, 8+7) = 15, dist[2][1] = min(∞, 5+3) = 8, dist[3][1] = min(∞, 2+3) = 5
>
> k=1 後：dist[0][2] = min(∞, 3+2) = **5**, dist[3][2] = min(∞, 5+2) = 7
>
> k=2 後：dist[0][3] = min(7, 5+1) = **6**, dist[1][3] = min(15, 2+1) = **3**
>
> 最終 dist[0][3] = 6（路徑 0→1→2→3，成本 3+2+1=6，比直接 0→3=7 短）

---

# 第四部分：MST + 數值範例

### Kruskal vs Prim — 怎麼選？

| | Kruskal | Prim |
|---|---|---|
| 策略 | 所有邊排序，從最輕開始加 | 從一個點出發，每次加最輕跨越邊 |
| 資料結構 | Union-Find | Min-Heap |
| 適合 | 稀疏圖（邊少） | 稠密圖（邊多） |
| 複雜度 | $O(E \log E)$ | $O(E + V \log V)$ |

### Kruskal 追蹤範例

> **圖**（6 個頂點）：
>
> 邊（按權重排序）：(A,B,1), (C,D,2), (A,D,3), (B,C,3), (B,D,4), (A,C,5), (D,E,5), (C,E,6)
>
> | 步驟 | 考慮邊 | 權重 | 動作 | 原因 |
> |------|--------|------|------|------|
> | 1 | (A,B) | 1 | **加入** | A,B 不在同一集合 |
> | 2 | (C,D) | 2 | **加入** | C,D 不在同一集合 |
> | 3 | (A,D) | 3 | **加入** | {A,B} 和 {C,D} 不在同一集合 |
> | 4 | (B,C) | 3 | 跳過 | B,C 已在同一集合（會成環）|
> | 5 | (B,D) | 4 | 跳過 | 同上 |
> | 6 | (A,C) | 5 | 跳過 | 同上 |
> | 7 | (D,E) | 5 | **加入** | E 是新的 |
>
> **MST 邊**：{(A,B,1), (C,D,2), (A,D,3), (D,E,5)}，**總權重 = 11**
>
> 共 5 個頂點 → 需要 4 條邊 ✓

---

# 第五部分：Network Flow + 數值範例

### Ford-Fulkerson 追蹤範例

> **圖**（容量標註在邊上）：
> ```
> s ──10──→ a ──10──→ t
> |                   ↑
> └──10──→ b ──10──┘
>           ↑    │
>           └─1──┘ (b→a 容量 1)
> ```
> 邊容量：s→a=10, s→b=10, a→t=10, b→t=10, b→a=1
>
> **Round 1**：增廣路 s→a→t，流量 = min(10,10) = **10**
>
> **Round 2**：增廣路 s→b→t，流量 = min(10,10) = **10**
>
> **Round 3**：還有路嗎？s→b→a→t？殘餘容量 s→b=0，不行。結束。
>
> **最大流 = 20**
>
> **Max-Flow Min-Cut 定理**：最小割 = {s→a, s→b}，割容量 = 10+10 = 20 = 最大流 ✓

---

# 第六部分：遞迴式求解 + 數值範例

## Master Theorem 三步驟

$T(n) = aT(n/b) + f(n)$

**Step 1**：算 $n^{\log_b a}$

**Step 2**：和 $f(n)$ 比較大小

**Step 3**：對應 Case 1/2/3

### 範例走一遍

> **例 1**：$T(n) = 4T(n/2) + n$
>
> Step 1：$\log_2 4 = 2$，所以比較對象是 $n^2$
>
> Step 2：$f(n) = n$ vs $n^2$？$n$ 多項式小於 $n^2$（差了 $n^1$）
>
> Step 3：**Case 1** → $T(n) = \Theta(n^2)$
>
> **直覺**：遞迴樹底層（葉子）的工作量主導。

---

> **例 2**：$T(n) = 2T(n/2) + n$（Merge Sort）
>
> Step 1：$\log_2 2 = 1$，比較對象是 $n^1 = n$
>
> Step 2：$f(n) = n$ vs $n$？**相等**
>
> Step 3：**Case 2** → $T(n) = \Theta(n \log n)$
>
> **直覺**：每層工作量一樣（都是 $n$），共 $\log n$ 層。

---

> **例 3**：$T(n) = 2T(n/2) + n^2$
>
> Step 1：$\log_2 2 = 1$，比較對象是 $n$
>
> Step 2：$f(n) = n^2$ vs $n$？$n^2$ 多項式大於 $n$
>
> Step 3：驗證正規條件 $af(n/b) \leq cf(n)$：$2(n/2)^2 = n^2/2 \leq cn^2$ ✓（$c=1/2$）
>
> **Case 3** → $T(n) = \Theta(n^2)$
>
> **直覺**：頂層（root）的工作量主導。

---

> **例 4**：$T(n) = 7T(n/2) + n^2$（Strassen 矩陣乘法）
>
> Step 1：$\log_2 7 \approx 2.807$，比較對象是 $n^{2.807}$
>
> Step 2：$f(n) = n^2$ vs $n^{2.807}$？$n^2$ 多項式小
>
> Step 3：**Case 1** → $T(n) = \Theta(n^{\log_2 7}) \approx \Theta(n^{2.807})$
>
> 比普通矩陣乘法 $O(n^3)$ 快！

### Master Theorem 速查表

| $a$ | $b$ | $\log_b a$ | $f(n)$ | Case | $T(n)$ |
|-----|-----|------------|--------|------|--------|
| 4 | 2 | 2 | $n$ | 1 | $\Theta(n^2)$ |
| 2 | 2 | 1 | $n$ | 2 | $\Theta(n \log n)$ |
| 2 | 2 | 1 | $n^2$ | 3 | $\Theta(n^2)$ |
| 4 | 2 | 2 | $n^2$ | 2 | $\Theta(n^2 \log n)$ |
| 7 | 2 | 2.81 | $n^2$ | 1 | $\Theta(n^{2.81})$ |
| 3 | 4 | 0.79 | $n$ | 3 | $\Theta(n)$ |
| 2 | 4 | 0.5 | $1$ | 1 | $\Theta(\sqrt{n})$ |

---

# 第七部分：NP-Complete + 數值範例

## NPC 歸約的標準流程

1. 證明 $L \in NP$（描述 certificate + verifier）
2. 選擇已知 NPC 問題 $L'$
3. 構造歸約 $f$：$x \in L' \iff f(x) \in L$
4. 證明兩方向正確性
5. 證明歸約是 poly time

### 常用歸約鏈

```
SAT → 3-SAT → {Independent Set, Vertex Cover, Clique,
                Subset Sum, Ham Cycle, 3-Coloring}
```

### 歸約範例：3-SAT → Independent Set

> **輸入 3-SAT**：$\phi = (x_1 \lor \bar{x}_2 \lor x_3) \land (\bar{x}_1 \lor x_2 \lor x_3)$（2 個 clause）
>
> **構造圖**：
> - 每個 clause 的 3 個 literal 各建一個節點
> - 同一 clause 內的節點兩兩連邊（強迫每個 clause 最多選一個）
> - 互補 literal 之間連邊（$x_1$ 和 $\bar{x}_1$ 之間連邊，確保一致性）
>
> Clause 1 的節點：$x_1^{(1)}$, $\bar{x}_2^{(1)}$, $x_3^{(1)}$
>
> Clause 2 的節點：$\bar{x}_1^{(2)}$, $x_2^{(2)}$, $x_3^{(2)}$
>
> 邊：
> - Clause 1 內部：$(x_1^{(1)}, \bar{x}_2^{(1)})$, $(x_1^{(1)}, x_3^{(1)})$, $(\bar{x}_2^{(1)}, x_3^{(1)})$
> - Clause 2 內部：類似三條
> - 互補邊：$(x_1^{(1)}, \bar{x}_1^{(2)})$, $(\bar{x}_2^{(1)}, x_2^{(2)})$
>
> **目標**：找大小 $k = 2$（= clause 數量）的 Independent Set
>
> **解**：選 $x_1^{(1)}$ 和 $x_2^{(2)}$ → 不相鄰 ✓ → 對應賦值 $x_1 = T, x_2 = T$ → clause 1 滿足（$x_1 = T$），clause 2 滿足（$x_2 = T$）✓

---

## P 裡的「偽裝成 NPC」問題

| 看起來難... | 但其實 ∈ P 的原因 |
|------------|-------------------|
| 2-SAT | Implication graph + SCC $O(n+m)$ |
| MST | Greedy $O(E \log V)$ |
| Bipartite Matching | Max Flow $O(VE)$ |
| Euler Circuit | 每個頂點偶數度 → 存在 |
| Shortest Path | Dijkstra $O(E + V \log V)$ |

---

# 第八部分：攤銷分析 + 數值範例

## 三種方法

| 方法 | 做法 | 適合 |
|------|------|------|
| Aggregate | 算 $n$ 次操作總成本 $/ n$ | 知道昂貴操作頻率 |
| Accounting | 每次多收「信用」 | 直觀分配成本 |
| Potential | 定義 $\Phi$，$\hat{c} = c + \Delta\Phi$ | 嚴格證明 |

### Dynamic Table（Potential Method）

> **情境**：陣列滿了就 double size（搬移全部元素）
>
> **追蹤 8 次 insert**：
>
> | 操作 | size | num | 實際成本 | 說明 |
> |------|------|-----|----------|------|
> | Insert 1 | 1 | 1 | **1** | 初始建表 |
> | Insert 2 | 2 | 2 | **2** | 滿了→擴到2→搬1個+插1個 |
> | Insert 3 | 4 | 3 | **3** | 滿了→擴到4→搬2個+插1個 |
> | Insert 4 | 4 | 4 | 1 | 直接插 |
> | Insert 5 | 8 | 5 | **5** | 滿了→擴到8→搬4個+插1個 |
> | Insert 6 | 8 | 6 | 1 | 直接插 |
> | Insert 7 | 8 | 7 | 1 | 直接插 |
> | Insert 8 | 8 | 8 | 1 | 直接插 |
>
> **總成本**：1+2+3+1+5+1+1+1 = **15**
>
> **攤銷成本**：15/8 ≈ **1.875 per operation**
>
> 用 Potential Method（$\Phi = 2 \cdot num - size$）可以證明攤銷成本 $\leq 3$。
>
> **直覺**：擴張雖然貴（$O(n)$），但發生頻率指數遞減（每 $2^k$ 次才一次），所以平均下來每次操作只要 $O(1)$。

### Binary Counter（Aggregate Method）

> **追蹤 8 次 increment**（計數器 000 → 001 → 010 → ...）：
>
> | 值 | bit翻轉數 | 累積翻轉 |
> |---|-----------|---------|
> | 000→001 | 1 | 1 |
> | 001→010 | 2 | 3 |
> | 010→011 | 1 | 4 |
> | 011→100 | 3 | 7 |
> | 100→101 | 1 | 8 |
> | 101→110 | 2 | 10 |
> | 110→111 | 1 | 11 |
> | 111→1000 | 4 | 15 |
>
> 8 次操作共翻轉 15 次。但注意：
> - 最低位每次都翻 → 8 次
> - 第 2 位每 2 次翻一次 → 4 次
> - 第 3 位每 4 次 → 2 次
> - 第 4 位每 8 次 → 1 次
>
> 總翻轉 $= 8 + 4 + 2 + 1 = 15$。一般地：$n$ 次 increment 的總翻轉 $< 2n$。
>
> **攤銷成本**：$< 2n/n = 2 = O(1)$ per increment ✓

---

# 第九部分：證明方法 + 範例

## Exchange Argument（Greedy 正確性）

> **證明 Activity Selection 的 Greedy 最優**：
>
> **命題**：按結束時間排序、每次選最早結束的，得到最多活動。
>
> **證明**：
> 1. 設 Greedy 選了 $\{g_1, g_2, \ldots, g_k\}$（按結束時間排）
> 2. 設 OPT 選了 $\{o_1, o_2, \ldots, o_m\}$（$m \geq k$）
> 3. **Exchange**：$g_1$ 的結束時間 $\leq o_1$ 的結束時間（因為 Greedy 選最早結束的）
> 4. 把 OPT 的 $o_1$ 換成 $g_1$ → 新的解仍合法（$g_1$ 更早結束，不會和 $o_2$ 衝突）且大小不變
> 5. 歸納下去，可以把整個 OPT 換成 Greedy 的解
> 6. 所以 $k \geq m$ → Greedy 最優 $\blacksquare$

## Loop Invariant（迭代算法正確性）

> **證明 Insertion Sort 正確**：
>
> **Loop Invariant**：在第 $j$ 次迭代開始時，$A[1..j-1]$ 是原始 $A[1..j-1]$ 的排序版本。
>
> **Init**：$j=2$ 時，$A[1..1]$ 只有一個元素，已排序 ✓
>
> **Maintenance**：假設 $A[1..j-1]$ 已排序。把 $A[j]$ 插入正確位置後，$A[1..j]$ 已排序 ✓
>
> **Termination**：$j = n+1$ 時，$A[1..n]$ 已排序 = 整個陣列排好了 ✓

---

# 第十部分：複雜度速查

## 常見複雜度排序（由快到慢）

$$O(1) < O(\log n) < O(\sqrt{n}) < O(n) < O(n \log n) < O(n^2) < O(n^3) < O(2^n) < O(n!)$$

## 實際數字感受

| 複雜度 | $n = 10$ | $n = 100$ | $n = 1000$ | $n = 10^6$ |
|--------|----------|-----------|------------|------------|
| $O(\log n)$ | 3.3 | 6.6 | 10 | 20 |
| $O(n)$ | 10 | 100 | 1000 | $10^6$ |
| $O(n \log n)$ | 33 | 664 | $10^4$ | $2 \times 10^7$ |
| $O(n^2)$ | 100 | $10^4$ | $10^6$ | $10^{12}$ ← 太慢 |
| $O(2^n)$ | 1024 | $10^{30}$ | 宇宙爆炸 | 別想了 |

## 考試中的複雜度提示

| 題目要求 | 想什麼演算法 |
|----------|-------------|
| $O(n)$ | Greedy / Linear scan / Counting sort |
| $O(n \log n)$ | Sort + sweep / D&C / Heap |
| $O(n^2)$ | DP (2D table) |
| $O(n^3)$ | Floyd-Warshall / Matrix Chain |
| $O(V+E)$ | BFS / DFS / Topo sort |
| $O(E \log V)$ | Dijkstra / Kruskal / Prim |

---

> **使用建議**：先用「決策流程圖」判斷類型 → 查「經典問題分類」找對應算法 → 跟著「數值範例」走一遍確認理解 → 考試時直接套模式。
>
> 各演算法的完整推導和程式碼請參考 algo_01 ~ algo_10。
