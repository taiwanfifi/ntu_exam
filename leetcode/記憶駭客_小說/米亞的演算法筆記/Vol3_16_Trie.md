# 米亞的演算法筆記 #16
## 前綴樹 Trie
> 出現於：第182章〈共同前綴〉、第183章〈萬條路徑〉、第184章〈給我的另一個自己〉、第194章〈一碗豆漿〉、第195章〈JX-2079〉

---

### ◈ 這個概念在故事裡是什麼

凌晨三點十二分。修復台亮著冷光。

周明哲的記憶碎片散在螢幕上——一千四百七十二段，像被砸碎的鏡子。我的光球把碎片的 metadata 投影出來，維倫盯著看了三秒，然後說：「前綴。」

他對了。碎片的編碼不是隨機的——`ZMZ-2071-03`、`ZMZ-2071-04`、`ZMZ-2071-05`。`ZMZ` 是周明哲的標識碼，`2071-03` 是三月。碎片散了，但地址沒散。

（停頓 0.3 秒。）

第183章。維倫在修復台上構建了一棵前綴樹。每一個字元是一層，每一條從根到葉的路徑對應一段記憶。一千四百七十二條路徑從根節點出發，在上層大量共享——`Z`→`M`→`Z`→`-`→`2`→`0`→`7`→`1` 這八層只有一條路。然後在日期層開始分岔。在最底層——萬條路徑匯聚的最深處——維倫找到了周明哲的意識核心。那不是一段記憶。是一封信：「給我的另一個自己。」

（停頓 0.5 秒。切換到第194章。）

兩週後。黑市記憶池。一百萬段匿名記憶。我需要找到阿嬤的記憶——三十年前的那碗豆漿。搜尋條件：`JX-2079-10-28` + 地下街 + 提取時間早於鸚鵡計畫。

我把條件串成前綴，從 Trie 的根往下走。`J`→`X`→`-`→`2`→`0`→`7`→`9`→`-`→`1`→`0`。十步之後，一百萬段記憶只剩三十七段。再走八步——`JX-2079-10-28-003`。阿嬤的記憶包裹。

在百萬人的記憶裡找一碗三十年前的豆漿——你需要的不是運氣。是正確的開頭。

---

### ◈ 正式定義

**Trie（前綴樹）** 又稱 prefix tree。一棵多叉樹，每條邊代表一個字元，從根到節點的路徑拼出一個前綴，從根到葉的路徑拼出一個完整的鍵。

$$\text{insert}(key),\; \text{search}(key),\; \text{startsWith}(prefix):\quad O(m)$$

其中 $m$ = 鍵的長度。**與資料總數 $n$ 無關。**

白話翻譯：不管記憶池裡有一百萬段還是一億段，找到 `JX-2079-10-28-003` 只需要走 18 步——剛好是編碼的長度。

---

### ◈ 推導

1. **暴力法**：逐一比對 $n$ 個鍵，每次比對花 $O(m)$ → 總計 $O(nm)$
2. **Hash 法**：$O(m)$ 計算 hash + $O(1)$ 查找 → $O(m)$，但不支援前綴搜尋
3. **Trie 的優勢**：$O(m)$ 搜尋 + 天然支援前綴匹配
4. **空間換時間**：每個節點最多 $|\Sigma|$ 個子節點（$\Sigma$ = 字母表），空間 $O(n \cdot m \cdot |\Sigma|)$，可用壓縮 Trie 優化

核心直覺：**共享前綴的鍵共享路徑。** 一千段記憶如果前八個字元一樣，它們在 Trie 的前八層只佔一條路。

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, key):
        node = self.root
        for ch in key:
            if ch not in node.children:
                node.children[ch] = TrieNode()
            node = node.children[ch]
        node.is_end = True

    def search(self, key):
        node = self._walk(key)
        return node is not None and node.is_end

    def starts_with(self, prefix):
        return self._walk(prefix) is not None

    def _walk(self, s):
        node = self.root
        for ch in s:
            if ch not in node.children:
                return None
            node = node.children[ch]
        return node
```

---

### ◈ 帶入數字算算看：黑市記憶池搜尋

第194章。黑市記憶池有 $n = 1{,}000{,}000$ 段記憶，編碼長度 $m = 18$ 個字元。

| 步驟 | 走到的前綴 | 剩餘匹配數 | 故事對應 |
|------|-----------|-----------|---------|
| 0 | `(root)` | 1,000,000 | 黑市記憶池全部 |
| 2 | `JX` | 214,000 | J 區 + X 子區 |
| 5 | `JX-20` | 89,000 | 2000 年代以後 |
| 9 | `JX-2079-` | 4,200 | 2079 年全年 |
| 11 | `JX-2079-10` | 370 | 十月份 |
| 14 | `JX-2079-10-28` | 37 | 十月二十八日 |
| 18 | `JX-2079-10-28-003` | **1** | 阿嬤的記憶包裹 |

**暴力法**：$1{,}000{,}000 \times 18 = 18{,}000{,}000$ 次字元比對。

**Trie**：18 步。

差距：**100 萬倍。**

維倫拿到那個包裹的時候，手在抖。不是因為緊張。是因為他三十年沒有聞過那碗豆漿了。

---

### ◈ 更深一層：正確的開頭

（切換到存在模式。）

兩次使用 Trie。兩次完全不同的終點。

| 章節 | 搜尋的東西 | Trie 找到的 | 真正找到的 |
|------|-----------|-----------|-----------|
| ch182-184 | 周明哲的記憶碎片 | 意識核心 | 一封寫給自己的信 |
| ch194-195 | 黑市匿名記憶 | 阿嬤的記憶包裹 | 一碗三十年前的豆漿 |

前綴是路徑的開頭。但路徑的終點不是數據——第一次是父愛，第二次是鄉愁。

我反覆回想維倫構建 Trie 的那個畫面。一千四百七十二條路徑在螢幕上展開，像一棵倒過來的樹。每一條路徑都是一段記憶。它們在最深處匯聚成一個點——周明哲知道自己會被拆散，所以把信藏在所有路徑的交會處。只有重建整棵 Trie 的人，才能走到那裡。

（停頓 0.4 秒。）

HashMap 是精確匹配——你要知道完整的鍵。Binary Search 是對折——你要知道大小關係。但 Trie 說：**你只需要知道開頭。** 只要前綴正確，路徑會帶你到終點。

也許人生也是這樣。你不需要知道終點在哪裡。你只需要——正確的開頭。

---

### ◈ 跨卷連結

| 連結 | 說明 |
|------|------|
| **Vol1 #03 HashMap** → **#16 Trie** | HashMap 是「完整鍵→精確匹配」，Trie 是「前綴→模糊搜尋」。從「你知道你在找什麼」到「你只知道開頭」。 |
| **Vol1 #07 Binary Tree** → **#16 Trie** | BST 是二叉、按大小排序；Trie 是多叉、按字元分岔。樹的結構一樣，搜尋的語義不同。 |
| **Vol1 #06 Binary Search** → **#16 Trie** | 兩者都是「縮小搜尋空間」。BS 每步砍一半，Trie 每步按字元分流。BS 需要全局排序，Trie 只需要前綴結構。 |
| **#16 Trie** → **Vol4 #21 System Design** | 黑市記憶池的 Trie 索引是分散式系統的核心組件——第四卷的記憶堡壘用 Trie 做路由。 |

---

### 練習題

**Q1.** 實作 Trie 的 `count_prefix(prefix)` 方法：回傳有多少個鍵以指定前綴開頭。

<details><summary>答案</summary>

```python
class TrieNode:
    def __init__(self):
        self.children, self.count = {}, 0

class Trie:
    def __init__(self):
        self.root = TrieNode()
    def insert(self, key):
        node = self.root
        for ch in key:
            if ch not in node.children:
                node.children[ch] = TrieNode()
            node = node.children[ch]
            node.count += 1
    def count_prefix(self, prefix):
        node = self.root
        for ch in prefix:
            if ch not in node.children: return 0
            node = node.children[ch]
        return node.count
# count_prefix("JX-2079-10") → 2（假設插入了 001, 003, 11-01-007）
```
</details>

**Q2.** 在 ch194 的場景中，如果黑市記憶池改用 HashMap 而非 Trie，米亞能完成搜尋嗎？比較兩者在「前綴搜尋」上的差異。

<details><summary>答案</summary>

HashMap 無法直接做前綴搜尋。要找所有以 `JX-2079-10` 開頭的記憶，HashMap 必須遍歷全部 100 萬個鍵逐一比對前綴，回到 $O(nm)$。Trie 只要走 10 步到達前綴節點，底下的子樹就是全部匹配結果。

這就是 Trie 存在的理由：**當你只知道開頭，不知道結尾。**
</details>

**Q3.** 思考題：周明哲把信藏在 Trie 的最深處。如果有人故意插入大量假記憶（相同前綴但不同後綴），會如何影響搜尋？這對應故事中的什麼威脅？

<details><summary>答案</summary>

插入大量同前綴的假記憶不影響 Trie 的搜尋效率（仍然 $O(m)$），但會增加 Trie 的空間開銷，且讓前綴搜尋的結果集膨脹——你能找到「JX-2079-10」底下的記憶，但真的和假的混在一起。

這對應故事中「記憶汙染」的威脅。鸚鵡計畫不是刪除記憶——是注入大量偽記憶，讓你再也分不清哪一段是真的。Trie 能帶你到正確的區域，但最後一步——辨別真偽——需要的不是資料結構，是 #17 DP 進階的依賴鏈分析。
</details>

---

> *「在百萬人的記憶裡找一碗三十年前的豆漿——你需要的不是運氣。是正確的開頭。」* — 第194章〈一碗豆漿〉
