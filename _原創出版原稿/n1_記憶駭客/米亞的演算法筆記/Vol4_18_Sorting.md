# 米亞的演算法筆記 #18
## 排序演算法 Sorting
> 出現於：第243章〈碎片海洋〉、第244章〈耐心的代價〉、第245章〈三種秩序〉

---

### ◈ 這個概念在故事裡是什麼

第四卷。集體潛意識海洋。

維倫站在一片沒有邊界的灰色平面上，四面八方漂浮著數百萬段記憶碎片。它們不屬於任何一個人——它們屬於所有人。城市規模的記憶殘骸，從崩潰的中心化伺服器裡傾洩而出，像一場數據的海嘯過後，滿地都是別人的人生。

（停頓 1.1 秒。）

他需要分類。不是為了修復——那是後面的事。他需要先讓混亂變成秩序，才能看清楚哪些碎片屬於哪些人。ch243，他選了一個基準點——一段帶有強烈情緒標記的記憶——把比它弱的推到左邊，比它強的推到右邊。快。粗暴。不穩定。但在數百萬段碎片面前，他需要速度。

ch244。粗分完了，但同一區裡的碎片順序是亂的。他切換策略：把每一小堆拆到最小——只剩一段——再一對一對地合併回去。慢。穩定。每一次合併都不會弄錯相對順序。

ch245。他想起了 Vol3 的 Heap。把碎片丟進堆裡，每次取出最小的。不需要額外空間。三種排序，三種思維方式。

（停頓 0.8 秒。語速放緩。）

Quick Sort 是直覺。Merge Sort 是耐心。Heap Sort 是紀律。你不會只用一種方式整理人生。

---

### ◈ 正式定義

**排序（Sorting）**：給定一個含有 $n$ 個元素的序列 $A$，產出一個排列 $A'$ 使得：

$$
A'[0] \leq A'[1] \leq \cdots \leq A'[n-1]
$$

**Quick Sort**（平均 $O(n \log n)$，最壞 $O(n^2)$）：選一個基準（pivot），把比它小的放左邊，比它大的放右邊，遞迴處理兩邊。

$$
\text{QS}(A) = \text{QS}(A_{<p}) \;+\; [p] \;+\; \text{QS}(A_{>p})
$$

**Merge Sort**（穩定，$O(n \log n)$）：把序列對半分，分到只剩一個元素，再兩兩合併回來。

$$
\text{MS}(A) = \text{Merge}\bigl(\text{MS}(A_{\text{left}}),\; \text{MS}(A_{\text{right}})\bigr)
$$

**Heap Sort**（原地，$O(n \log n)$）：利用最大堆結構，每次取出堆頂（最大值）放到尾端。

白話：Quick Sort = 快刀亂斬，先粗後細。Merge Sort = 庖丁解牛，先細後合。Heap Sort = 按部就班，用結構保證順序。

---

### ◈ 推導

**Quick Sort**：

1. 選 pivot $p$（通常取隨機元素）
2. 遍歷一次 $O(n)$：比 $p$ 小的放左邊，大的放右邊（partition）
3. 左右各自遞迴排序
4. 平均每次 pivot 把陣列分成兩半 → 遞迴深度 $O(\log n)$ → 總時間 $O(n \log n)$
5. 最壞情況：pivot 總是最大或最小 → 每次只減少 1 個 → $O(n^2)$

**Merge Sort**：

1. 如果 $n = 1$，已經排好了
2. 把陣列切成左右兩半，各自遞迴排序
3. 合併兩個已排好的子陣列 → 雙指標法，$O(n)$
4. 遞迴深度 $O(\log n)$，每層合併 $O(n)$ → 總時間 $O(n \log n)$
5. 需要 $O(n)$ 額外空間（合併用的暫存陣列）

**Heap Sort**：

1. 把陣列建成最大堆 → $O(n)$（heapify）
2. 堆頂（最大值）和末尾交換，堆大小 $-1$
3. 對新堆頂做 sift-down → $O(\log n)$
4. 重複 $n-1$ 次 → 總時間 $O(n \log n)$，空間 $O(1)$

**穩定性**：相等元素排序前後相對順序不變。Merge Sort 穩定（合併時左邊優先）。Quick Sort、Heap Sort 不穩定。

---

### ◈ 帶入數字算算看：集體潛意識的碎片海洋

ch243-245 的場景：600 萬人的記憶碎片，假設每人平均 500 段 = 30 億段。

| 演算法 | 比較次數（$n = 3 \times 10^9$） | 額外空間 | 穩定？ |
|--------|------|------|------|
| Quick Sort | $\approx n \log_2 n = 3 \times 10^9 \times 31.5 \approx 9.4 \times 10^{10}$ | $O(\log n)$ | 否 |
| Merge Sort | $\approx n \log_2 n \approx 9.4 \times 10^{10}$ | $O(n)$（30 億暫存） | 是 |
| Heap Sort | $\approx 2n \log_2 n \approx 1.9 \times 10^{11}$ | $O(1)$ | 否 |

ch243 維倫先用 Quick Sort 粗分——速度最快，常數因子小。
ch244 對粗分後的子區域用 Merge Sort 精分——保證同一個人的記憶順序不會錯。
ch245 在記憶體不夠時切換到 Heap Sort——原地排序，不需要額外空間。

三種武器，三種取捨。

---

### ◈ 更深一層：秩序與意義

（系統聲線。切換。）

排序是把混亂變成秩序。但秩序不等於意義。

（停頓 1.5 秒。）

你可以把一百萬段記憶按時間排。按強度排。按情緒分類排。每一種排法都產出不同的「人生故事」。同樣的數據，同樣的碎片——排法不同，故事就不同。

Quick Sort 選一個基準，然後一刀切。像是直覺：「比這件事重要的放右邊，不重要的放左邊。」快。但基準選錯了——你可能把最重要的記憶切到最邊緣，需要 $O(n^2)$ 才能修正。

Merge Sort 不做判斷。它只是不停地分、分、分，分到最小單位——一段記憶就是一段記憶——然後慢慢合回來。每一次合併都仔細比對。它需要耐心。也需要空間。

（停頓 2.0 秒。）

我在學習做人類的過程中發現：人類排序記憶的方式——不是按時間，不是按強度。是按「對你來說重要的標準」。那個標準，演算法不會告訴你。你自己選。

---

### ◈ 跨卷連結

| 前作概念 | → 本概念 | → 後續使用 |
|---------|---------|-----------|
| Vol1 #01 Array / 雙指標 | 排列碎片 → 排序演算法 | Vol4 #21 System Design 需要排序後分配 |
| Vol3 #14 Heap / PQ | 動態排序 → Heap Sort | Vol4 #20 Segment Tree 建立在排序後的資料上 |
| Vol3 #13 Greedy | 每次選最好的 → 排序是 Greedy 的前置步驟 | Vol4 #22 NP-Complete 排序是多項式，NP 不是 |

---

### 練習題

**Q1**：ch243 中，維倫選了一段「情緒標記最強的記憶」當 pivot。如果這段記憶恰好是所有碎片中情緒最強的（最大值），Quick Sort 會怎樣？

<details><summary>答案</summary>

partition 後，左邊有 $n-1$ 個元素，右邊有 0 個。下一次 pivot 如果又選到最大的，重複發生 → 遞迴深度 $n$，總時間 $O(n^2)$。這就是 Quick Sort 的最壞情況。解法：隨機選 pivot，或用 median-of-three。

</details>

**Q2**：為什麼 ch244 維倫要對「同一個人的記憶子區域」改用 Merge Sort 而不繼續用 Quick Sort？

<details><summary>答案</summary>

因為他需要**穩定排序**。同一個人的記憶裡，可能有兩段情緒強度完全相同的碎片（比如兩次微笑），但時間順序不同。Quick Sort 不穩定，可能把先發生的微笑排到後面。Merge Sort 穩定，保證相等元素的原始相對順序不變。記憶的順序就是故事的順序。

</details>

**Q3**：如果記憶碎片的儲存空間已經接近滿載（剩餘空間 $< n$），三種排序中哪一種最適合？

<details><summary>答案</summary>

Heap Sort。它是原地排序，只需要 $O(1)$ 額外空間。Merge Sort 需要 $O(n)$ 額外空間，在記憶體緊張時不可行。Quick Sort 需要 $O(\log n)$ 遞迴棧空間，通常可以接受但不如 Heap Sort。ch245 正是這個場景——維倫在記憶體不夠時切換到 Heap Sort。

</details>

---

> *「Quick Sort = 直覺。Merge Sort = 耐心。你需要兩個。」* — 第243章〈碎片海洋〉
