# 數位邏輯教學講義 第一章：數字系統與編碼

---

## 🔰 **本章基礎觀念（零基礎必讀）**

你每天用的手機、電腦、遊戲機，裡面的晶片全部只認識兩個東西：**0 和 1**。
為什麼？因為電晶體最穩定的狀態就是「開」和「關」，對應到高電壓和低電壓。
這一章我們要學會：怎麼用 0 和 1 來表達數字、文字，以及怎麼在不同進位之間轉換。

> **學完本章，你應該能做到：**
> 1. 任意進位之間互相轉換（含小數）
> 2. 用 2's complement 做有號數加減法
> 3. 判斷溢位(Overflow)
> 4. 理解 BCD、格雷碼、ASCII 碼的用途

---

## 關鍵術語表

| 中文 | 英文 | 白話解釋 | 例子 |
|------|------|----------|------|
| 類比 | Analog | 連續的訊號，像水龍頭的水量 | 溫度計的水銀柱 |
| 數位 | Digital | 離散的訊號，只有有限個值 | 開關只有 ON/OFF |
| 位元 | Bit | 二進位的一個位數，只能是 0 或 1 | 1 bit 能表達 2 種狀態 |
| 位元組 | Byte | 8 個 bit 組成 | 1 Byte = 8 bits |
| 基底 | Radix / Base | 一個進位系統用幾個符號 | 二進位的基底是 2 |
| 最高有效位元 | MSB (Most Significant Bit) | 最左邊、權重最大的那個位元 | 1011 的 MSB 是 1 |
| 最低有效位元 | LSB (Least Significant Bit) | 最右邊、權重最小的那個位元 | 1011 的 LSB 是 1 |
| 補數 | Complement | 用來做減法的技巧 | 2's complement |
| 溢位 | Overflow | 運算結果超出可表示的範圍 | 4-bit 有號數最大 +7 |
| 格雷碼 | Gray Code | 相鄰數值只差一個 bit | 00→01→11→10 |

---

## 一、類比 vs 數位：為什麼數位系統重要？

### 類比訊號 (Analog Signal)
- 連續的、無限多種數值
- 例：溫度、聲音振幅、電壓
- 問題：**容易受雜訊干擾，傳輸越遠越失真**

### 數位訊號 (Digital Signal)
- 離散的、只有有限種數值（通常是 0 和 1）
- 例：電腦資料、數位音訊
- 優點：**抗雜訊強、可複製不失真、易於儲存與處理**

```
類比訊號：     數位訊號：
  ∧              ┌─┐   ┌─┐
 / \    /\       │ │   │ │
/   \  /  \      │ │   │ │
     \/         ─┘ └───┘ └──
（連續波形）     （方波，只有高/低）
```

### 為什麼現代系統幾乎都是數位？
1. **可靠性**：0 和 1 之間有明確門檻，雜訊不易造成判斷錯誤
2. **可重製性**：數位資料拷貝無限次都一模一樣
3. **可程式化**：同一個硬體，換程式就能做不同事
4. **摩爾定律**：電晶體越做越小，數位電路越來越便宜

---

## 二、數字系統：二進位、八進位、十六進位

### 2.1 位置記數法 (Positional Notation)

任何一個數字 N 在基底 r 之下可以展開為：

```
N = aₙ·rⁿ + aₙ₋₁·rⁿ⁻¹ + ... + a₁·r¹ + a₀·r⁰ + a₋₁·r⁻¹ + a₋₂·r⁻² + ...
```

其中 aᵢ 是第 i 位的數字（0 ≤ aᵢ < r）。

### 2.2 常用進位系統

| 進位系統 | 基底 | 使用的符號 | 常見標記 |
|----------|------|-----------|---------|
| 二進位 (Binary) | 2 | 0, 1 | 1010₂ 或 0b1010 |
| 八進位 (Octal) | 8 | 0~7 | 12₈ 或 012 |
| 十進位 (Decimal) | 10 | 0~9 | 10₁₀ |
| 十六進位 (Hex) | 16 | 0~9, A~F | 0xA3 或 A3₁₆ |

十六進位對照：A=10, B=11, C=12, D=13, E=14, F=15

### 2.3 為什麼要用八進位和十六進位？

因為二進位太長了！但它們跟二進位之間的轉換非常簡單：
- **八進位**：每 3 個 bit 一組
- **十六進位**：每 4 個 bit 一組

```
二進位：   1 011 101 010
八進位：   1  3   5   2   → (1352)₈

二進位：   1011 1010 1000
十六進位：  B    A    8   → (0xBA8)
```

---

## 三、進位轉換方法

### 3.1 任意進位 → 十進位：展開法

把每一位乘以對應的權重後加起來。

**【例題 1】將 (1011.01)₂ 轉為十進位**

```
1011.01₂
= 1×2³ + 0×2² + 1×2¹ + 1×2⁰ + 0×2⁻¹ + 1×2⁻²
= 8    + 0    + 2    + 1    + 0     + 0.25
= 11.25₁₀
```

**【例題 2】將 (2A.C)₁₆ 轉為十進位**

```
2A.C₁₆
= 2×16¹ + 10×16⁰ + 12×16⁻¹
= 32    + 10     + 0.75
= 42.75₁₀
```

### 3.2 十進位 → 任意進位

**整數部分：連除法（除以基底，取餘數，由下往上讀）**

**【例題 3】將 (156)₁₀ 轉為二進位**

```
156 ÷ 2 = 78 ... 0  ↑
 78 ÷ 2 = 39 ... 0  │
 39 ÷ 2 = 19 ... 1  │  （由下往上讀）
 19 ÷ 2 =  9 ... 1  │
  9 ÷ 2 =  4 ... 1  │
  4 ÷ 2 =  2 ... 0  │
  2 ÷ 2 =  1 ... 0  │
  1 ÷ 2 =  0 ... 1  │

結果：(10011100)₂
```

驗算：128 + 16 + 8 + 4 = 156 ✓

**小數部分：連乘法（乘以基底，取整數部分，由上往下讀）**

**【例題 4】將 (0.6875)₁₀ 轉為二進位**

```
0.6875 × 2 = 1.375  → 取 1  ↓
0.375  × 2 = 0.75   → 取 0  │  （由上往下讀）
0.75   × 2 = 1.5    → 取 1  │
0.5    × 2 = 1.0    → 取 1  ↓

結果：(0.1011)₂
```

驗算：0.5 + 0.125 + 0.0625 = 0.6875 ✓

> **注意**：有些十進位小數轉二進位會變成無限循環！
> 例如 (0.1)₁₀ = (0.000110011001100...)₂，這就是為什麼浮點數有精度問題。

### 3.3 二進位 ↔ 八進位 / 十六進位：分組法

**二 → 八**：從小數點往兩邊，每 3 bit 一組，不足補 0

```
(10 110 101.011 010)₂
= (  2   6   5 . 3   2  )₈    → (265.32)₈
```

**二 → 十六**：從小數點往兩邊，每 4 bit 一組，不足補 0

```
(0010 1101 0101.0110 1000)₂
= (  2    D    5  . 6    8  )₁₆  → (2D5.68)₁₆
```

---

## 四、補數系統 (Complement)

### 4.1 為什麼需要補數？

在電路中，加法器很容易做，但減法器比較複雜。
如果我們能把「A - B」轉成「A + (-B)」，那只需要一個加法器就行了！
補數就是用來表示負數的方法。

### 4.2 1's Complement（1 的補數 / 反相）

**對 n-bit 二進位數 N：1's complement = 2ⁿ - 1 - N**

白話：**每個 bit 都反轉（0→1, 1→0）**

```
N         = 0101 1010
1's comp  = 1010 0101  （每個 bit 反轉）
```

問題：
- 有「+0」和「-0」兩種零（00000000 和 11111111）
- 做加法時若最高位有進位，需要「end-around carry」（進位加回最低位）

### 4.3 2's Complement（2 的補數）

**對 n-bit 二進位數 N：2's complement = 2ⁿ - N**

白話：**先取 1's complement，再加 1**

```
N         = 0101 1010
1's comp  = 1010 0101
            +        1
2's comp  = 1010 0110
```

**捷徑法**：從 LSB 開始往左看，保留第一個 1 及其右邊的 0，其餘 bit 全部反轉。

```
N         = 0101 1000
                 ↑ 第一個1在這裡
2's comp  = 1010 1000  （1000 保留，左邊反轉）
```

### 4.4 為什麼用 2's Complement？

| 特性 | 1's Complement | 2's Complement |
|------|---------------|---------------|
| 零的表示 | 兩種（+0 和 -0） | **只有一種** |
| 加法需要特殊處理 | 需要 end-around carry | **不需要** |
| n-bit 表示範圍 | -(2ⁿ⁻¹-1) ~ +(2ⁿ⁻¹-1) | **-2ⁿ⁻¹ ~ +(2ⁿ⁻¹-1)** |
| 硬體實現 | 較複雜 | **較簡單** |

**結論：現代電腦幾乎全部使用 2's complement！**

---

## 五、有號數表示與運算

### 5.1 2's Complement 有號數

以 4-bit 為例：

| 二進位 | 無號數值 | 2's Comp 值 |
|--------|---------|-------------|
| 0000 | 0 | 0 |
| 0001 | 1 | +1 |
| 0010 | 2 | +2 |
| 0011 | 3 | +3 |
| 0100 | 4 | +4 |
| 0101 | 5 | +5 |
| 0110 | 6 | +6 |
| 0111 | 7 | **+7**（最大正數） |
| 1000 | 8 | **-8**（最小負數） |
| 1001 | 9 | -7 |
| 1010 | 10 | -6 |
| 1011 | 11 | -5 |
| 1100 | 12 | -4 |
| 1101 | 13 | -3 |
| 1110 | 14 | -2 |
| 1111 | 15 | -1 |

**MSB 就是符號位元**：0 代表正，1 代表負。

n-bit 2's complement 的範圍：**-2ⁿ⁻¹ ~ +2ⁿ⁻¹ - 1**
- 4-bit：-8 ~ +7
- 8-bit：-128 ~ +127
- 16-bit：-32768 ~ +32767

### 5.2 加法運算

直接用二進位加法，忽略超出 n-bit 的進位。

**【例題 5】用 4-bit 2's complement 計算 (+5) + (-3)**

```
 +5 = 0101
 -3 = 1101  （3 = 0011, 取2's comp = 1101）

   0101
+  1101
-------
 1 0010  ← 忽略第5位的進位

結果：0010 = +2  ✓  （+5 + (-3) = +2）
```

**【例題 6】用 4-bit 2's complement 計算 (-2) + (-3)**

```
 -2 = 1110
 -3 = 1101

   1110
+  1101
-------
 1 1011  ← 忽略第5位的進位

結果：1011 → 這是負數（MSB=1）
取 2's complement: 0100+1 = 0101 = 5
所以 1011 = -5  ✓  （(-2) + (-3) = -5）
```

---

## 六、溢位(Overflow)判斷

### 什麼時候會溢位？

**當兩個同號數相加，結果變號時，就發生溢位。**

規則：
- **正 + 正 → 負**：溢位！
- **負 + 負 → 正**：溢位！
- **正 + 負**：**絕不溢位**（結果一定在範圍內）

### 硬體判斷方法

**Overflow = Cₙ ⊕ Cₙ₋₁**

其中 Cₙ 是最高位的進位輸出，Cₙ₋₁ 是次高位的進位。
當這兩個進位不同時，就是溢位。

**【例題 7】用 4-bit 2's complement 計算 (+5) + (+4)**

```
   0101  (+5)
+  0100  (+4)
-------
   1001  → MSB=1，表示負數 = -7 ？？

+5 + 4 = 9，但 4-bit 最大只到 +7，溢位了！

進位分析：C₃=0, C₂=1 → C₃ ⊕ C₂ = 1 → 溢位 ✓
```

---

## 七、BCD碼、格雷碼、ASCII碼

### 7.1 BCD碼 (Binary-Coded Decimal)

每一個十進位數字用 **4 個 bit** 獨立表示。

```
十進位：  3    8    5
BCD：   0011 1000 0101
```

| 十進位 | BCD | 十進位 | BCD |
|--------|-----|--------|-----|
| 0 | 0000 | 5 | 0101 |
| 1 | 0001 | 6 | 0110 |
| 2 | 0010 | 7 | 0111 |
| 3 | 0011 | 8 | 1000 |
| 4 | 0100 | 9 | 1001 |

> 注意：1010~1111 在 BCD 中是**無效碼**！

**BCD 加法**：如果某一位的結果 > 9 或有進位，就要加 6（0110）修正。

```
BCD加法例：37 + 45

  0011 0111  (37)
+ 0100 0101  (45)
-----------
  0111 1100
        ↑ 1100 > 9，加 6 修正
  0111 1100
+      0110
-----------
  1000 0010  → BCD 的 82  ✓
```

### 7.2 格雷碼 (Gray Code)

**特性：相鄰兩個數值之間只有一個 bit 不同。**

| 十進位 | 二進位 | 格雷碼 |
|--------|--------|--------|
| 0 | 0000 | 0000 |
| 1 | 0001 | 0001 |
| 2 | 0010 | 0011 |
| 3 | 0011 | 0010 |
| 4 | 0100 | 0110 |
| 5 | 0101 | 0111 |
| 6 | 0110 | 0101 |
| 7 | 0111 | 0100 |
| 8 | 1000 | 1100 |
| 9 | 1001 | 1101 |
| 10 | 1010 | 1111 |
| 11 | 1011 | 1110 |
| 12 | 1100 | 1010 |
| 13 | 1101 | 1011 |
| 14 | 1110 | 1001 |
| 15 | 1111 | 1000 |

**二進位 → 格雷碼**：Gᵢ = Bᵢ ⊕ Bᵢ₊₁（最高位不變，其他位 = 原碼相鄰兩位 XOR）

```
B = 1 0 1 1
    │ ↓ ↓ ↓
G = 1 1 1 0

G₃ = B₃ = 1
G₂ = B₃ ⊕ B₂ = 1⊕0 = 1
G₁ = B₂ ⊕ B₁ = 0⊕1 = 1
G₀ = B₁ ⊕ B₀ = 1⊕1 = 0
```

**應用**：
- 旋轉編碼器（避免多個 bit 同時改變造成的瞬間錯誤）
- 卡諾圖的行列標記
- 跨時脈域(CDC)計數器

### 7.3 ASCII碼

**ASCII (American Standard Code for Information Interchange)**：用 7-bit 表示 128 個字元。

常見的要記住：
| 字元 | ASCII (十進位) | ASCII (十六進位) |
|------|---------------|-----------------|
| '0' | 48 | 0x30 |
| '9' | 57 | 0x39 |
| 'A' | 65 | 0x41 |
| 'Z' | 90 | 0x5A |
| 'a' | 97 | 0x61 |
| 'z' | 122 | 0x7A |
| 空格 | 32 | 0x20 |

> 小技巧：大寫 → 小寫只要 +32（差一個 bit）

---

## 八、題型鑑別表

| 題目關鍵字 | 該用什麼方法 |
|-----------|-------------|
| 「轉為十進位」 | 展開法（各位乘權重） |
| 「十進位轉為 X 進位」 | 整數部分連除，小數部分連乘 |
| 「二進位↔八進位/十六進位」 | 分組法（3 bit / 4 bit） |
| 「求 2's complement」 | 反轉所有 bit 再 +1 |
| 「有號數加法」 | 直接二進位加法，忽略溢出進位 |
| 「判斷溢位」 | 同號相加變號 = 溢位 |
| 「BCD 加法」 | 二進位加法後，>9 的要 +6 修正 |
| 「二進位↔格雷碼」 | XOR 相鄰位元 |

---

## ✅ 自我檢測

> 試著先自己做，再看答案！

### Q1：將 (10110.101)₂ 轉為十進位。

<details>
<summary>點擊查看答案</summary>

```
1×2⁴ + 0×2³ + 1×2² + 1×2¹ + 0×2⁰ + 1×2⁻¹ + 0×2⁻² + 1×2⁻³
= 16 + 0 + 4 + 2 + 0 + 0.5 + 0 + 0.125
= 22.625
```
</details>

### Q2：將 (200)₁₀ 轉為二進位。

<details>
<summary>點擊查看答案</summary>

```
200 ÷ 2 = 100 ... 0
100 ÷ 2 =  50 ... 0
 50 ÷ 2 =  25 ... 0
 25 ÷ 2 =  12 ... 1
 12 ÷ 2 =   6 ... 0
  6 ÷ 2 =   3 ... 0
  3 ÷ 2 =   1 ... 1
  1 ÷ 2 =   0 ... 1

由下往上讀：(11001000)₂
驗算：128 + 64 + 8 = 200 ✓
```
</details>

### Q3：用 8-bit 2's complement 表示 -50，並計算 30 + (-50)。

<details>
<summary>點擊查看答案</summary>

```
50 = 0011 0010
1's comp = 1100 1101
2's comp = 1100 1110  → 這就是 -50

 30 = 0001 1110
-50 = 1100 1110

  0001 1110
+ 1100 1110
-----------
  1110 1100  ← 結果

MSB=1 → 負數
取 2's comp: 0001 0011 + 1 = 0001 0100 = 20
所以結果 = -20  ✓ （30 + (-50) = -20）
```
</details>

### Q4：用 4-bit 2's complement 計算 (-4) + (-5)，並判斷是否溢位。

<details>
<summary>點擊查看答案</summary>

```
-4 = 1100
-5 = 1011

  1100
+ 1011
------
1 0111  ← 忽略第5位進位

結果 = 0111 = +7 ？？ 這不對！
負 + 負 = 正 → 溢位！

4-bit 2's comp 範圍是 -8 ~ +7
-4 + (-5) = -9 超出範圍，確認溢位。
```
</details>

### Q5：將十進位 94 轉為 BCD 碼。

<details>
<summary>點擊查看答案</summary>

```
9 → 1001
4 → 0100

BCD(94) = 1001 0100
```
</details>

### Q6：將二進位 1101 轉為格雷碼。

<details>
<summary>點擊查看答案</summary>

```
B = 1 1 0 1

G₃ = B₃ = 1
G₂ = B₃ ⊕ B₂ = 1⊕1 = 0
G₁ = B₂ ⊕ B₁ = 1⊕0 = 1
G₀ = B₁ ⊕ B₀ = 0⊕1 = 1

G = 1011
```
</details>

### Q7：為什麼 2's complement 比 1's complement 好？請列出至少三個理由。

<details>
<summary>點擊查看答案</summary>

1. **零只有一種表示**（1's comp 有 +0 和 -0 兩種）
2. **加法不需要 end-around carry**（硬體更簡單）
3. **可表示範圍多一個負數**（n-bit: -2ⁿ⁻¹ ~ +2ⁿ⁻¹-1）
4. **加法器就能做減法**（A - B = A + 2's comp of B）
</details>

---

> **下一章預告**：學完數字怎麼表示後，下一章我們要學怎麼用邏輯閘來「計算」這些數字 — 布林代數與邏輯閘！
