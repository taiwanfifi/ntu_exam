# 演算法筆記 08：網路流 (Network Flow)

> 台大演算法課教學講義
> 本篇涵蓋：Ford-Fulkerson、Edmonds-Karp、Max-Flow Min-Cut 定理、二部圖匹配、應用

---

## 一、Flow Network 的定義

### 1.1 基本定義

一個 **Flow Network（流量網路）** G = (V, E) 是一個有向圖，滿足：

1. **源點 (source) s**：流量的起點，只有流出沒有流入
2. **匯點 (sink) t**：流量的終點，只有流入沒有流出
3. **容量函數 c(u, v) ≥ 0**：每條邊 (u, v) 有一個非負的容量上限

### 1.2 流 (Flow) 的定義

一個**流 (flow)** 是一個函數 f: V × V → R，滿足：

1. **容量限制 (Capacity Constraint)**：對所有 u, v ∈ V，
   > 0 ≤ f(u, v) ≤ c(u, v)

2. **流守恆 (Flow Conservation)**：對所有 u ∈ V \ {s, t}，
   > Σ_{v ∈ V} f(v, u) = Σ_{v ∈ V} f(u, v)
   >
   > （流入 u 的總量 = 流出 u 的總量）

3. **流的值 (Value of flow)**：
   > |f| = Σ_{v ∈ V} f(s, v) - Σ_{v ∈ V} f(v, s) = 從 s 淨流出的量

### 1.3 Maximum Flow 問題

**問題**：給定 flow network G、源點 s、匯點 t，找到一個流 f 使得 |f| 最大。

直覺上：想像 s 是水源，t 是目的地，邊是水管，容量是水管能承受的最大流量。我們要讓從 s 到 t 的水流量最大。

---

## 二、Ford-Fulkerson 方法

### 2.1 核心思路

反覆找一條從 s 到 t 的「可以再多送一些流」的路徑（增廣路徑），然後沿這條路把流量推過去。直到找不到增廣路徑為止。

但要讓這個方法正確，關鍵在於**剩餘圖 (Residual Graph)** 的概念。

### 2.2 Residual Graph（剩餘圖）

給定流 f，剩餘圖 G_f = (V, E_f) 的定義是：

對每條原圖中的邊 (u, v)，剩餘圖中有：
- **正向邊 (u, v)**：剩餘容量 c_f(u, v) = c(u, v) - f(u, v)（還能多送多少）
- **反向邊 (v, u)**：剩餘容量 c_f(v, u) = f(u, v)（已經送了多少，可以「退回」多少）

只有剩餘容量 > 0 的邊才存在於 E_f 中。

### 2.3 為什麼需要「反向邊」？

這是初學者最容易困惑的地方。讓我用一個例子說明。

**範例**：

```
    s ---10--→ A ---10--→ t
    |                     ↑
    10                    10
    ↓                     |
    B --------10--------→ C
              ↑
              A ---10--→ C  (另一條邊)
```

簡化一下：

```
         10        10
    s -------→ a -------→ t
    |          |          ↑
    10         10         10
    ↓          ↓          |
    b -------→ c ---------+
         10
```

也就是：
- s→a: 10, s→b: 10
- a→t: 10, a→c: 10
- b→c: 10
- c→t: 10

最大流 = 20（s→a→t 送 10，s→b→c→t 送 10）。

但如果第一次找到的增廣路是 s→a→c→t（送 10），那之後：
- s→a 剩 0（滿了）
- a→c 剩 0（滿了）
- c→t 剩 0（滿了）

如果沒有反向邊，就找不到更多增廣路了。流量 = 10，不是最大的！

**有了反向邊**：剩餘圖中會出現 c→a（容量 10），表示我們可以「取消」a→c 的部分流量。

第二次增廣路：s→b→c→a→t（用了反向邊 c→a！），送 10。

這等價於：
- s→a→t 送 10
- s→b→c→t 送 10
- a→c 的 10 被取消了

最終流量 = 20。

> **口語理解**：反向邊的意義是「允許演算法修正之前的決定」。如果之前不小心把流量送到一條不是最佳的路上，反向邊讓你可以把它退回來，改送到更好的路上。

### 2.4 Augmenting Path（增廣路徑）

在剩餘圖 G_f 中，從 s 到 t 的一條路徑 P，就叫**增廣路徑**。

**瓶頸容量 (bottleneck)**：路徑上最小的剩餘容量。
> c_f(P) = min_{(u,v) ∈ P} c_f(u, v)

沿增廣路送 c_f(P) 的流量，可以增加總流量 c_f(P)。

### 2.5 完整虛擬碼

```
FORD-FULKERSON(G, s, t):
    // 初始化：所有邊流量為 0
    for each edge (u, v) in G.E:
        f(u, v) = 0

    // 建立初始剩餘圖
    G_f = RESIDUAL-GRAPH(G, f)

    while 存在從 s 到 t 的增廣路徑 P in G_f:
        // 找瓶頸容量
        c_f(P) = min { c_f(u, v) : (u, v) ∈ P }

        // 沿增廣路更新流量
        for each edge (u, v) in P:
            if (u, v) 是正向邊:
                f(u, v) = f(u, v) + c_f(P)
            else:  // (u, v) 是反向邊，即原圖有邊 (v, u)
                f(v, u) = f(v, u) - c_f(P)

        // 更新剩餘圖
        G_f = RESIDUAL-GRAPH(G, f)

    return f
```

### 2.6 Ford-Fulkerson 的時間複雜度

如果容量都是整數，每次增廣至少增加 1 的流量，而最大流 ≤ Σc(s,v)。設最大流值為 |f*|。

**時間**：O(E · |f*|)

問題：如果容量很大（例如 10⁹），這可能非常慢。如果容量是無理數，甚至可能不終止！

**解決方法**：選擇增廣路的策略很重要 → Edmonds-Karp。

---

## 三、Edmonds-Karp 演算法

### 3.1 核心改進

Edmonds-Karp 就是 Ford-Fulkerson，但規定**用 BFS 找增廣路**（即找最短增廣路，以邊數計）。

### 3.2 為什麼 O(VE²)？

**關鍵引理**：在 Edmonds-Karp 中，每條邊 (u, v) 成為增廣路上的**瓶頸邊**最多 O(V/2) 次。

**推導**：

定義 d_f(s, v) = 在剩餘圖 G_f 中，s 到 v 的最短距離（BFS 層數）。

**引理 1**：隨著增廣進行，d_f(s, v) 單調遞增（非遞減）。

> 直覺：BFS 找最短路，每次增廣後，s 到各點的距離不會變近。

**引理 2**：邊 (u, v) 成為瓶頸時，d_f(s, v) = d_f(s, u) + 1。瓶頸後 (u,v) 消失。要讓 (u,v) 再次出現在剩餘圖中，需要沿 (v,u) 增廣，此時 d_f'(s, u) = d_f'(s, v) + 1。所以下次 (u,v) 成為瓶頸時，d_f''(s, u) ≥ d_f(s, u) + 2。

因為 d_f(s, u) ≤ V-2（最遠距離），每條邊成為瓶頸最多 O(V) 次。

**合計**：
- 每條邊成為瓶頸 ≤ V/2 次
- 共 E 條邊
- 每次增廣至少消除一條瓶頸邊
- 所以最多 O(VE) 次增廣

但等等，更精確的分析：

- 增廣次數 ≤ O(VE)
- 每次增廣用 BFS，O(E)
- 總時間：**O(VE²)**

> 實際上，更仔細的分析會得到增廣次數 ≤ O(VE)，但每次 BFS 是 O(E)，所以是 O(VE · E) = O(VE²)。

---

## 四、Max-Flow Min-Cut 定理

這是網路流理論中最重要的定理。

### 4.1 Cut 的定義

一個 **s-t cut** (S, T) 是將 V 分成兩個集合 S 和 T = V\S，使得 s ∈ S 且 t ∈ T。

**Cut 的容量**：
> c(S, T) = Σ_{u ∈ S, v ∈ T} c(u, v)

注意：只計算從 S 到 T 的邊，不計算從 T 到 S 的邊。

**Minimum Cut（最小割）**：容量最小的 s-t cut。

### 4.2 定理陳述

以下三個條件等價：
1. f 是最大流
2. 剩餘圖 G_f 中不存在增廣路徑（從 s 到 t 的路）
3. 存在一個 s-t cut (S, T) 使得 |f| = c(S, T)

### 4.3 完整推導

**先證一個引理：對任意流 f 和任意 s-t cut (S, T)，|f| ≤ c(S, T)**

> 推導：
> |f| = Σ_{v} f(s,v) - Σ_{v} f(v,s)  （流的值的定義）
>
> 利用流守恆，對所有 u ∈ S \ {s}，Σ_v f(u,v) - Σ_v f(v,u) = 0
>
> 所以 |f| = Σ_{u ∈ S} [Σ_v f(u,v) - Σ_v f(v,u)]
>
> 把 v 分成 v ∈ S 和 v ∈ T：
>
> |f| = Σ_{u∈S, v∈T} f(u,v) - Σ_{u∈S, v∈T} f(v,u)
>
> （S 內部的流互相抵消了）
>
> 因為 f(u,v) ≤ c(u,v) 且 f(v,u) ≥ 0：
>
> |f| ≤ Σ_{u∈S, v∈T} c(u,v) - 0 = c(S, T)

所以**任何流的值 ≤ 任何割的容量**。這很重要！

---

**現在證明三個條件等價**：

**(1) → (2)**：反證法。如果存在增廣路，還能增加流量，和 f 是最大流矛盾。

**(2) → (3)**：

假設 G_f 中沒有從 s 到 t 的路徑。

定義 S = {v ∈ V : G_f 中存在從 s 到 v 的路徑}。T = V \ S。

- s ∈ S（自己到自己）
- t ∈ T（因為沒有 s→t 的路徑）

所以 (S, T) 是一個 s-t cut。

對於 u ∈ S, v ∈ T：
- 剩餘圖中沒有邊 (u, v)（否則 v 從 s 可達，應在 S 中）
- 所以 c_f(u, v) = 0，即 c(u, v) - f(u, v) = 0，即 **f(u, v) = c(u, v)**（正向邊滿載）

對於 u ∈ S, v ∈ T 的反向邊：
- 剩餘圖中沒有邊 (v, u)，所以 c_f(v, u) = 0，即 f(u, v) = 0... 不對，

  讓我更仔細地寫。對 v ∈ T, u ∈ S：
- 剩餘圖中沒有邊 (v, u)... 等等 v ∈ T，u ∈ S。在剩餘圖中，(v, u) 的容量是 c(v,u) - f(v,u)（正向）和 f(u,v)（反向）。

  重新整理：

  對 u ∈ S, v ∈ T：
  - G_f 中 (u,v) 的剩餘容量 = c(u,v) - f(u,v) = 0（否則 v 可達）→ f(u,v) = c(u,v)

  對 v ∈ T, u ∈ S：
  - G_f 中 (v,u) 的剩餘容量包含 f(u,v) 的反向部分。但我們要看 (v,u) 是否存在。
  - 更精確地：G_f 中由 T 到 S 的正向邊 (v,u)（如果原圖有邊 (v,u)）：c(v,u)-f(v,u)。如果這 > 0 且 v 能從 s 到達...但 v ∈ T 表示 v 不可從 s 到達，所以不影響。

  讓我回到計算 |f|：

  |f| = Σ_{u∈S, v∈T} f(u,v) - Σ_{v∈T, u∈S} f(v,u)

  我們知道 f(u,v) = c(u,v) 對所有 u∈S, v∈T。

  對 v∈T, u∈S：G_f 中 (v,u) 邊的反向部分的剩餘容量是 f(v,u)。如果 f(v,u) > 0，那 G_f 中會有反向邊 (u,v)... 不，f(v,u) 是原圖邊 (v,u) 上的流量，在剩餘圖中會產生反向邊 (u,v) 容量 f(v,u)。但 u ∈ S，v ∈ T，如果 G_f 中有邊 (u,v) 容量 > 0（來自反向），那 v 應該可從 s 經 u 到達... 等等，但我們已經說了 G_f 中 (u,v) 的剩餘容量 = c(u,v) - f(u,v) = 0。反向邊的貢獻是：如果原圖有 (v,u)，G_f 中有 (u,v) 容量 f(v,u)。但 (u,v) 的正向剩餘已是 0，反向來的容量 f(v,u)...

  好，讓我重新更清楚地定義。在剩餘圖中，對於一對頂點 (u,v)，剩餘容量為：

  c_f(u,v) = [c(u,v) - f(u,v)] + f(v,u)

  （如果原圖有邊 (u,v)，可以多送 c(u,v)-f(u,v)；如果原圖有邊 (v,u)，可以退回 f(v,u)）

  對 u ∈ S, v ∈ T：c_f(u,v) = 0（否則 v 可達）。

  所以：c(u,v) - f(u,v) + f(v,u) = 0
  → f(u,v) - f(v,u) = c(u,v)

  因此：|f| = Σ_{u∈S,v∈T} [f(u,v) - f(v,u)] = Σ_{u∈S,v∈T} c(u,v) = c(S,T)

所以 |f| = c(S, T)。 ∎

**(3) → (1)**：

由引理，任何流 |f| ≤ 任何割 c(S, T)。如果 |f| = c(S, T)，那 f 一定是最大流（不可能有更大的，因為被 c(S, T) 擋住了），而 (S, T) 一定是最小割（不可能有更小的，因為被 |f| 頂住了）。 ∎

### 4.4 如何從 Max Flow 找 Min Cut

1. 計算最大流 f
2. 在剩餘圖 G_f 上，從 s 做 BFS/DFS
3. S = 所有 s 可達的頂點，T = V \ S
4. (S, T) 就是最小割
5. 最小割的邊 = 從 S 到 T 的所有原圖邊（這些邊都是滿載的）

---

## 五、手動 Trace Through 完整範例

考慮以下 flow network：

```
         10         10
    s --------→ a --------→ t
    |           ↑ \          ↑
    |           |   \        |
    10          4    2       10
    |           |     ↘      |
    ↓           |      ↘     |
    b --------→ c --------→ d
         9            8
```

邊和容量：
- s→a: 10
- s→b: 10
- a→t: 10
- a→d: 2
- b→c: 9
- c→a: 4
- c→d: 8
- d→t: 10

初始：所有流量 = 0。

---

### 增廣 #1：找增廣路

**剩餘圖 G_f（初始 = 原圖）**：

BFS 從 s 開始：s → a → t。找到增廣路 s→a→t。

瓶頸 = min(c_f(s,a), c_f(a,t)) = min(10, 10) = 10。

**更新流量**：
- f(s,a) = 0 + 10 = 10
- f(a,t) = 0 + 10 = 10

|f| = 10。

**更新剩餘圖**：
- s→a：剩餘 10-10 = 0（消失）；反向 a→s：剩餘 10
- a→t：剩餘 10-10 = 0（消失）；反向 t→a：剩餘 10

```
剩餘圖：
    a→s: 10        t→a: 10
    s→b: 10        a→d: 2
    b→c: 9         c→a: 4
    c→d: 8         d→t: 10
```

---

### 增廣 #2：找增廣路

BFS 從 s：s → b → c → a → ...（a→t 已消失）；c → d → t。

找到增廣路 **s→b→c→d→t**。

瓶頸 = min(10, 9, 8, 10) = 8。

**更新流量**：
- f(s,b) = 0 + 8 = 8
- f(b,c) = 0 + 8 = 8
- f(c,d) = 0 + 8 = 8
- f(d,t) = 0 + 8 = 8

|f| = 10 + 8 = 18。

**更新剩餘圖**：
```
    a→s: 10        t→a: 10
    s→b: 10-8=2    b→s: 8（反向新增）
    a→d: 2
    b→c: 9-8=1     c→b: 8（反向新增）
    c→a: 4
    c→d: 8-8=0（消失）  d→c: 8（反向新增）
    d→t: 10-8=2    t→d: 8（反向新增）
```

---

### 增廣 #3：找增廣路

BFS 從 s：s → b (剩餘 2) → c (剩餘 1)。從 c 可以去 a (剩餘 4) 或 b（反向，不回頭）。

c → a (4)：但 a→t 已滿。a→d (2)。d→t (2)。

找到增廣路 **s→b→c→a→d→t**。

瓶頸 = min(2, 1, 4, 2, 2) = 1。

**更新流量**：
- f(s,b) = 8 + 1 = 9
- f(b,c) = 8 + 1 = 9
- f(c,a) = 0 → 此為原圖的邊 c→a，f(c,a) = 0 + 1 = 1
- f(a,d) = 0 + 1 = 1
- f(d,t) = 8 + 1 = 9

|f| = 18 + 1 = 19。

**更新剩餘圖**：
```
    a→s: 10         t→a: 10
    s→b: 2-1=1      b→s: 9
    a→d: 2-1=1      d→a: 1
    b→c: 1-1=0（消失） c→b: 9
    c→a: 4-1=3      a→c: 1
    d→c: 8           c→d: 0
    d→t: 2-1=1      t→d: 9
```

---

### 增廣 #4：找增廣路

BFS 從 s：s→b (1)。b→c 已消失。b 無其他出邊。

s→a？s→a 剩餘 = 0。但 s 也只有 s→b 了。

等等，讓我重新看剩餘圖。a→s 有容量 10，但那是從 a 到 s，不是 s 出去的。

從 s 出發的邊：s→b (1)。
從 b 出發的邊（在剩餘圖中）：b→s (反向，回頭了，BFS 不會走回 s)。c→b 是 c 到 b。b 沒有往前的邊了。

看起來找不到增廣路了！

等等，讓我再仔細檢查剩餘圖：

從 s：只有 s→b (1)
從 b：只有 b→s (9)，沒有 b→c（已消失），沒有其他邊

所以確實找不到從 s 到 t 的增廣路了。

**最大流 |f*| = 19**。

---

### 驗證：找 Min Cut

在最終剩餘圖上，從 s 做 BFS：
- s 可達 b（通過 s→b）
- b 沒有往前的路了

S = {s, b}，T = {a, c, d, t}

Min Cut 的邊（S 到 T 的原圖邊）：
- s→a：容量 10
- b→c：容量 9

Min Cut 容量 = 10 + 9 = 19 = |f*|。 Max-Flow Min-Cut 定理驗證成功！

---

### 最終流量表

| 邊 | 容量 | 流量 |
|----|------|------|
| s→a | 10 | 10 |
| s→b | 10 | 9 |
| a→t | 10 | 10 |
| a→d | 2 | 1 |
| b→c | 9 | 9 |
| c→a | 4 | 1 |
| c→d | 8 | 8 |
| d→t | 10 | 9 |

驗證流守恆：
- 頂點 a：流入 = f(s,a) + f(c,a) = 10 + 1 = 11。流出 = f(a,t) + f(a,d) = 10 + 1 = 11。OK。
- 頂點 b：流入 = f(s,b) = 9。流出 = f(b,c) = 9。OK。
- 頂點 c：流入 = f(b,c) = 9。流出 = f(c,a) + f(c,d) = 1 + 8 = 9。OK。
- 頂點 d：流入 = f(a,d) + f(c,d) = 1 + 8 = 9。流出 = f(d,t) = 9。OK。

---

## 六、應用

### 6.1 二部圖匹配 (Bipartite Matching)

#### 問題

給定二部圖 G = (L ∪ R, E)，L 是左邊的頂點，R 是右邊的頂點，邊只在 L 和 R 之間。找**最大匹配 (Maximum Matching)**——最多能配幾對不共享頂點的邊。

#### 轉化為 Flow Network

1. 新增源點 s 和匯點 t
2. 從 s 到 L 中每個頂點加一條容量 1 的邊
3. 從 R 中每個頂點到 t 加一條容量 1 的邊
4. L 到 R 的原始邊，容量設為 1（或 ∞，效果一樣，因為 s→L 和 R→t 已限制為 1）

```
    s --1-→ L₁ --1-→ R₁ --1-→ t
    |        |  ╲      ↑        ↑
    1        1    1    1        1
    ↓        ↓      ╲  |        |
    s --1-→ L₂ --1-→ R₂ --1-→ t
    |                  ↑        ↑
    1                  1        1
    ↓                  |        |
    s --1-→ L₃ -------+  --1-→ t
```

更精確的圖：

```
         1         1         1
    s ------→ L₁ ------→ R₁ ------→ t
    |          \                     ↑
    |1          1                    |1
    ↓            ↘                   |
    s ------→ L₂ ------→ R₂ ------→ t
    |1        ↗ \    1    ↑    1     ↑
    ↓        /    ↘       |         |1
    s --1-→ L₃    → R₃ --+---1---→ t
```

不好畫，讓我用文字描述一個具體例子。

#### 範例

左邊頂點：{L₁, L₂, L₃}
右邊頂點：{R₁, R₂, R₃}
邊：L₁-R₁, L₁-R₂, L₂-R₂, L₂-R₃, L₃-R₃

建構 flow network：
- s→L₁:1, s→L₂:1, s→L₃:1
- L₁→R₁:1, L₁→R₂:1
- L₂→R₂:1, L₂→R₃:1
- L₃→R₃:1
- R₁→t:1, R₂→t:1, R₃→t:1

跑最大流：
- 增廣路 1：s→L₁→R₁→t，流量 1
- 增廣路 2：s→L₂→R₂→t，流量 1
- 增廣路 3：s→L₃→R₃→t，流量 1

最大流 = 3 = 最大匹配。

匹配：{(L₁,R₁), (L₂,R₂), (L₃,R₃)}。

但如果邊不同呢？假設 L₃ 只能配 R₃，L₂ 也只能配 R₃：

邊：L₁-R₁, L₁-R₂, L₂-R₃, L₃-R₃

- 增廣路 1：s→L₁→R₁→t，流量 1
- 增廣路 2：s→L₂→R₃→t，流量 1
- 增廣路 3：找 s→L₃→R₃→...  R₃→t 已滿。

  在剩餘圖中：R₃→L₂（反向邊），L₂ 沒有其他可去的 R 了。找不到。

最大匹配 = 2：{(L₁,R₁), (L₂,R₃)}。L₃ 沒有配對。

**但如果用 Edmonds-Karp (BFS)**，可能找到更好的增廣順序。讓我改一下：

邊：L₁-R₁, L₁-R₂, L₂-R₂, L₂-R₃, L₃-R₃

如果先走了：
- 增廣路 1：s→L₁→R₂→t
- 增廣路 2：s→L₂→R₃→t
- 增廣路 3：s→L₃→R₃→？R₃ 滿了。剩餘圖中 R₃→L₂（反向），L₂→R₂？R₂ 滿了。R₂→L₁（反向），L₁→R₁，R₁→t。

  增廣路 3：s→L₃→R₃→L₂→R₂→L₁→R₁→t，流量 1。

  這就是反向邊的威力！結果重新分配為：
  - L₁↔R₁, L₂↔R₂, L₃↔R₃

最大匹配 = 3。

#### 時間複雜度

二部圖匹配用 Edmonds-Karp：O(V · E)（因為增廣次數 ≤ O(V)，每次 BFS O(E)）。
更精確的分析：O(E√V)（用 Hopcroft-Karp 演算法）。

### 6.2 人員/旅館分配問題

#### 問題

有 n 個人和 m 間旅館。每個人有偏好的旅館列表。每間旅館有容量上限 cⱼ。每個人只能住一間。問最多能安排多少人入住？

#### 建模為 Flow Network

1. 源點 s，匯點 t
2. s 到每個人 pᵢ：容量 1（每人只能住一間）
3. 人 pᵢ 到偏好的旅館 hⱼ：容量 1
4. 旅館 hⱼ 到 t：容量 cⱼ（旅館的容量上限）

```
    s --1-→ p₁ --1-→ h₁ --c₁-→ t
    |         \       ↑          ↑
    1          1      1         c₂
    ↓           ↘     |          |
    s --1-→ p₂ --→ h₂ ---------→ t
```

最大流 = 最多能安排入住的人數。

#### 延伸

如果每個人可以住多間（例如出差多天），把 s→pᵢ 的容量改成天數 dᵢ。

### 6.3 Edge-Disjoint Paths

#### 問題

給定有向圖 G 和兩個頂點 s, t。找從 s 到 t 的最多條**邊不相交 (edge-disjoint)** 路徑。

#### 建模

直接把原圖當 flow network，每條邊容量設為 1。

最大流 = 最多的 edge-disjoint paths 數量。

**為什麼？** 因為每條邊容量 1，流量是整數時，每條邊要嘛流 0 要嘛流 1。流量為 k 的整數流可以分解成 k 條 s-t 路徑（和一些環），而邊容量 1 保證路徑邊不重複。

#### Menger's Theorem

**定理**：從 s 到 t 的最多 edge-disjoint paths 數量 = 為了斷開所有 s-t 路所需移除的最少邊數。

這就是 Max-Flow Min-Cut 定理在 edge-disjoint paths 上的特殊情況！

### 6.4 最小頂點覆蓋（Konig's Theorem 簡介）

#### 定義

**頂點覆蓋 (Vertex Cover)**：一個頂點子集 C ⊆ V，使得每條邊至少有一個端點在 C 中。

**最小頂點覆蓋**：最小的頂點覆蓋。

#### Konig's Theorem

**定理**：在二部圖中，最小頂點覆蓋的大小 = 最大匹配的大小。

> **公式**：min vertex cover = max matching（僅限二部圖！）

這是一個非常漂亮的結果。一般圖中，最小頂點覆蓋是 NP-hard 問題，但在二部圖中，因為 Konig's Theorem，可以用最大流在多項式時間解決。

**和 Max-Flow Min-Cut 的關係**：

二部圖最大匹配 = 最大流 = 最小割 = 最小頂點覆蓋

**如何從 min cut 構造 min vertex cover**：

1. 跑最大流得到最小割 (S, T)
2. 最小頂點覆蓋 C = (L ∩ T) ∪ (R ∩ S)
   - L 中被 T 包含的頂點（左邊沒被 s 可達的）
   - R 中被 S 包含的頂點（右邊被 s 可達的）

#### 延伸：最大獨立集

**獨立集 (Independent Set)**：一個頂點子集，其中沒有任何兩個頂點相鄰。

**定理**：最大獨立集 = V - 最小頂點覆蓋。

在二部圖中：最大獨立集 = |V| - 最大匹配。

---

## 七、常見陷阱

### 7.1 忘記加反向邊

這是最致命的錯誤。沒有反向邊，Ford-Fulkerson 可能找不到最大流。

**錯誤程式碼**（只加正向邊的剩餘容量）：
```
// 錯！缺少反向邊
if c(u,v) - f(u,v) > 0:
    add edge (u,v) with capacity c(u,v) - f(u,v) to G_f
```

**正確程式碼**：
```
// 正向邊
if c(u,v) - f(u,v) > 0:
    add edge (u,v) with capacity c(u,v) - f(u,v) to G_f
// 反向邊
if f(u,v) > 0:
    add edge (v,u) with capacity f(u,v) to G_f
```

### 7.2 忘記更新 Residual Graph

每次增廣後，剩餘圖必須更新。常見錯誤是只更新正向邊的剩餘容量，忘記更新反向邊。

**更新規則**：沿增廣路 P 送 Δ 流量後，對路上每條邊 (u,v)：
- 正向剩餘容量 c_f(u,v) 減少 Δ
- 反向剩餘容量 c_f(v,u) 增加 Δ

### 7.3 容量為無理數時 Ford-Fulkerson 可能不終止

如果不限制增廣路的選擇方式，且容量是無理數，Ford-Fulkerson 可能無限循環且不收斂到最大流。解決方法：用 Edmonds-Karp（BFS）保證 O(VE²)。

### 7.4 把 Min Cut 的容量算錯

Min Cut 的容量只計算**從 S 到 T** 的邊，不計算從 T 到 S 的邊。

**錯誤**：c(S,T) = Σ 所有跨越 cut 的邊容量
**正確**：c(S,T) = Σ_{u∈S, v∈T} c(u,v)（只有 S→T 方向）

### 7.5 二部圖匹配忘記容量都是 1

建模時，s→L 和 R→t 的邊容量必須是 1（如果每個頂點只能匹配一次）。如果設成 ∞，同一個人/物品可能被匹配多次。

### 7.6 混淆「流」和「容量」

- **容量 c(u,v)**：邊能承載的最大流量（固定不變）
- **流 f(u,v)**：目前實際通過的流量（演算法過程中改變）
- **剩餘容量 c_f(u,v)**：還能再多送的量（= c(u,v) - f(u,v)）

### 7.7 忘記整數流定理

**整數流定理 (Integrality Theorem)**：如果所有容量都是整數，那麼存在一個最大流，使得所有邊的流量都是整數。

這在二部圖匹配中很重要——保證了流量為 0 或 1，正好對應「匹配」或「不匹配」。

---

## 八、演算法比較表

| 演算法 | 時間複雜度 | 特點 |
|--------|-----------|------|
| Ford-Fulkerson (DFS) | O(E · \|f*\|) | 簡單但可能很慢 |
| Edmonds-Karp (BFS) | O(VE²) | 多項式時間保證 |
| Dinic's | O(V²E) | 更快，使用 blocking flow |
| Push-Relabel | O(V²E) 或 O(V³) | 不基於增廣路 |

> **實務建議**：Dinic's 演算法在大多數競賽和實際應用中表現最好。二部圖匹配推薦 Hopcroft-Karp（O(E√V)）。

---

*網路流是一個強大的工具，很多看似無關的問題都可以建模為 max flow。關鍵是學會「如何把問題轉化為 flow network」——這是最重要的技能。*
