# EDA 08：DFT 測試與良率

> **目標讀者**：零基礎學生、準備 TSMC / 聯發科 DFT 工程師面試者
> **預備知識**：基礎數位邏輯（Flip-Flop、組合邏輯）
> **學習時間**：約 110 分鐘

---

## 🔰 本章基礎觀念（零基礎必讀）

### 為什麼要測試？

一顆先進 IC 有數十億個電晶體。即使在最好的晶圓廠，製造過程中也會有微小的缺陷（如微塵、蝕刻不完全、薄膜破損）。這些缺陷可能導致部分電路不正常。

- **不測試**：把壞的晶片賣給客戶 → 產品失效 → 客戶信任崩潰
- **測試**：在出貨前找出壞晶片 → 只出貨好的 → 保證品質

### 測試的成本

| 事項 | 說明 |
|------|------|
| ATE 設備 | 一台高階 ATE > $1,000 萬 |
| 測試時間 | 每顆晶片測試 1～10 秒 |
| 測試成本佔比 | 佔晶片總成本的 **20～40%** |

### 生活比喻

| DFT 概念 | 生活比喻 |
|---------|---------|
| 故障模型 | 假設水管可能漏水或堵住 |
| 掃描設計 | 在每個水龍頭旁加一個檢測孔 |
| ATPG | 自動計算「怎麼放水才能找出每個漏洞」 |
| BIST | 水管系統內建自我測試裝置 |
| 良率 | 一批水管中，合格品的比例 |

---

## 一、缺陷模型（Fault Models）

### 1.1 為什麼需要模型？

真實的物理缺陷千變萬化。為了有系統地產生測試向量，需要把物理缺陷**抽象化**為邏輯層面的故障模型。

### 1.2 常見故障模型

#### Stuck-at Fault（固著故障）★最基本

假設電路中某條線永遠固定在 0（stuck-at-0, SA0）或 1（stuck-at-1, SA1）。

```
    正常電路：                故障電路（b stuck-at-1）：
    a ──┐                   a ──┐
        ├─AND── f               ├─AND── f = a·1 = a
    b ──┘                   1 ──┘ ← b 永遠是 1

    若 a=0, b=0：                若 a=0, b=0（但 b SA1）：
    f = 0 (正確)                  f = 0·1 = 0 ← 碰巧一樣！偵測不到

    若 a=1, b=0：                若 a=1, b=0（但 b SA1）：
    f = 0 (正確)                  f = 1·1 = 1 ← 不一樣！可以偵測到 ★
```

要偵測 stuck-at fault：
1. **活化（Activate）**：讓故障線的正常值和故障值不同
2. **傳播（Propagate）**：讓不同的值傳播到可觀察的輸出端

#### Transition Fault（轉態故障）

線路的 **0→1** 或 **1→0** 轉態太慢（延遲缺陷）。

- **Slow-to-Rise**：0→1 太慢
- **Slow-to-Fall**：1→0 太慢

用兩個連續的測試向量（V1, V2）來偵測：
1. V1：初始化故障線到某個值
2. V2：觸發轉態，並在規定時間內觀察輸出

#### Bridging Fault（橋接故障）

兩條不該相連的線被短路。

```
    正常：              Bridging fault：
    a ── 線A            a ── 線A ───┐
                                     ├── 短路！
    b ── 線B            b ── 線B ───┘
```

根據短路後的邏輯行為：
- **AND-bridge**：短路處表現為 AND（值為 a·b）
- **OR-bridge**：短路處表現為 OR（值為 a+b）

### 1.3 故障模型比較

| 模型 | 模擬的物理缺陷 | 測試複雜度 | 應用 |
|------|--------------|-----------|------|
| Stuck-at | 斷路、短路到電源/地 | 低 | 基本測試 ★ |
| Transition | 延遲缺陷 | 中 | at-speed 測試 ★ |
| Bridging | 線間短路 | 高 | 深層缺陷檢測 |

---

## 二、可測試性設計（DFT, Design for Testability）

### 2.1 測試的基本困難

組合邏輯的測試相對簡單：給輸入 → 看輸出。
但**時序電路**有記憶（Flip-Flop），狀態不可直接觀察和控制 → 測試極為困難。

| 需求 | 說明 |
|------|------|
| **可控性（Controllability）** | 能否輕易地把內部節點設成想要的值？ |
| **可觀察性（Observability）** | 能否輕易地在輸出端觀察到內部節點的值？ |

### 2.2 掃描設計（Scan Design）★DFT 的核心

#### 掃描正反器（Scan Flip-Flop, Scan FF）

把普通的 D 正反器（DFF）改造成可以切換到「掃描模式」的版本：

```
    普通 DFF：                    Scan FF：

        ┌─────┐                     ┌───────────┐
    D ──┤     │                 D ──┤ 0         │
        │ DFF ├── Q             SI ─┤ 1   MUX   ├──┤ DFF ├── Q
    CLK─┤     │                     │     ↑     │  │     │
        └─────┘                     │    SE     │  │     │
                                    └───────────┘  └─────┘

                                 SE = 0 → 功能模式（D 輸入）
                                 SE = 1 → 掃描模式（SI 輸入）
```

- **SE（Scan Enable）**：控制 MUX 選擇
  - SE = 0：正常功能模式，資料從 D 端進入
  - SE = 1：掃描模式，資料從 SI（Scan In）端進入

#### 掃描鏈（Scan Chain）

把所有 Scan FF 的 SI → Q 串成一條長鏈：

```
    Scan Chain（掃描鏈）

    ┌────────┐    ┌────────┐    ┌────────┐    ┌────────┐
    │Scan FF │    │Scan FF │    │Scan FF │    │Scan FF │
SI─▶│ 1      ├──▶│ 2      ├──▶│ 3      ├──▶│ 4      ├──▶ SO
    │        │    │        │    │        │    │        │
    └───┬────┘    └───┬────┘    └───┬────┘    └───┬────┘
        │             │             │             │
        CLK           CLK           CLK           CLK
```

- **SI（Scan In）**：掃描鏈的輸入端
- **SO（Scan Out）**：掃描鏈的輸出端
- 在掃描模式下，所有 FF 形成一個**移位暫存器**

#### 掃描測試的步驟

```
    步驟 1：掃描載入（Scan Shift In）
    ─────────────────────────────────
    SE = 1（掃描模式）
    透過 SI 端，一個時脈一個 bit 地把測試向量「推進」所有 FF

    步驟 2：捕捉（Capture）
    ─────────────────────────
    SE = 0（功能模式）
    施加一個或少數幾個時脈
    組合邏輯計算結果被 FF 捕捉

    步驟 3：掃描卸載（Scan Shift Out）
    ─────────────────────────────────
    SE = 1（掃描模式）
    透過 SO 端，把 FF 中的值「推出來」
    與期望值比對 → 判斷 Pass/Fail

    （同時步驟 1 也在進行，推入下一個測試向量）
```

#### 掃描設計的代價

| 代價 | 量化 |
|------|------|
| 面積增加 | 每個 FF 增加一個 MUX → 面積增加 **~5～15%** |
| 速度影響 | MUX 增加 $t_{cq}$ 的延遲 → 功能模式速度略降 |
| 功耗 | 掃描時所有 FF 在跳動 → 測試時功耗可能 **2～10 倍** |
| 額外接腳 | SI, SO, SE 需要額外的 I/O pin |

### 2.3 測試模式 vs 功能模式

| 模式 | SE | 資料來源 | 用途 |
|------|-----|---------|------|
| **功能模式** | 0 | D（正常邏輯） | 晶片正常運作 |
| **掃描模式** | 1 | SI（掃描鏈） | 測試：載入/卸載測試向量 |
| **捕捉模式** | 0（短暫） | D（一個 CLK） | 測試：捕捉組合邏輯結果 |

---

## 三、ATPG（Automatic Test Pattern Generation，自動測試向量產生）

### 3.1 ATPG 的目標

給定一組故障（如所有可能的 stuck-at fault），自動產生一組**測試向量**，能偵測這些故障。

### 3.2 D 算法（D-Algorithm）

最經典的 ATPG 演算法，使用「D 符號」表示故障效果：

| 符號 | 正常值 | 故障值 | 意義 |
|------|--------|--------|------|
| D | 1 | 0 | 正常=1, 故障=0（偵測 SA0） |
| D̄ | 0 | 1 | 正常=0, 故障=1（偵測 SA1） |
| 0 | 0 | 0 | 確定是 0 |
| 1 | 1 | 1 | 確定是 1 |
| X | X | X | 未定（don't care） |

步驟：
1. **活化故障**：在故障點產生 D 或 D̄
2. **傳播 D-frontier**：利用 D 運算規則把 D 推向輸出
3. **回溯（Backtrack）**：找滿足條件的輸入值
4. 若衝突則回溯嘗試其他值

### 3.3 PODEM（Path-Oriented Decision Making）

D 算法的改良版：
- 只在**主要輸入（PI）**上做決策（不在內部節點）
- 減少搜索空間
- 更有效率

### 3.4 故障覆蓋率（Fault Coverage）

$$\boxed{\text{Fault Coverage} = \frac{\text{被偵測到的故障數}}{\text{所有可偵測的故障數}} \times 100\%}$$

| 覆蓋率 | 品質 |
|--------|------|
| < 90% | 不可接受 |
| 90～95% | 最低要求 |
| 95～99% | 良好 |
| > 99% | ★ 高品質（業界標準） |

### 3.5 測試向量壓縮

現代 IC 的故障數量極大（數十億），直接的掃描測試需要太長時間。

**壓縮技術**：
- **輸入壓縮（Input Compaction）**：少量 SI pin → 多條掃描鏈（用解壓器）
- **輸出壓縮（Output Compaction）**：多條掃描鏈 → 少量 SO pin（用壓縮器）
- 壓縮比：50:1 ～ 200:1

商用工具：
- **Tessent**（Siemens EDA）★業界標準
- **DFT Compiler**（Synopsys）

---

## 四、BIST（Built-In Self-Test，內建自測試）

### 4.1 為什麼需要 BIST？

| 問題 | BIST 解法 |
|------|----------|
| ATE 設備昂貴 | 晶片**自己測試自己** → 不需要 ATE（或大幅簡化） |
| 測試向量太多 | 用硬體**隨機產生**測試向量 |
| 輸出比對困難 | 用硬體**壓縮**輸出成一個簽章（Signature） |

### 4.2 BIST 架構

```
    ┌──────────────────────────────────────┐
    │                 晶片                  │
    │                                      │
    │  ┌──────┐                ┌──────┐   │
    │  │ LFSR │── 測試向量 ──▶│ CUT  │   │
    │  │(產生) │               │(被測  │   │
    │  └──────┘               │ 電路) │   │
    │                          └──┬───┘   │
    │                             │       │
    │                             ▼       │
    │                         ┌──────┐   │
    │                         │ MISR │   │
    │                         │(壓縮) │   │
    │                         └──┬───┘   │
    │                             │       │
    │                          Signature  │
    │                         (與期望值比較)│
    └──────────────────────────────────────┘
```

### 4.3 LFSR（Linear Feedback Shift Register，線性回授移位暫存器）

LFSR 用簡單的硬體產生**偽隨機序列**，作為測試向量。

```
    4-bit LFSR 範例（多項式 x⁴ + x + 1）：

    ┌───┐   ┌───┐   ┌───┐   ┌───┐
    │ Q3├──▶│ Q2├──▶│ Q1├──▶│ Q0├──▶ 輸出
    └─┬─┘   └───┘   └───┘   └─┬─┘
      │                        │
      └──────── XOR ◀──────────┘
                 │
                 └──▶ 回授到 Q3 的輸入
```

特性：
- $n$-bit LFSR 最多產生 $2^n - 1$ 個不同的狀態（最大長度序列）
- 硬體成本極低（幾個 FF + XOR）
- 序列具有良好的隨機特性（但不是真隨機）

### 4.4 MISR（Multiple Input Signature Register，多輸入特徵暫存器）

MISR 把所有輸出的長序列**壓縮**成一個短的「簽章（Signature）」。

```
    多個輸出
    o0  o1  o2  o3
    │   │   │   │
    ▼   ▼   ▼   ▼
    ┌───┬───┬───┬───┐
    │ Q3│ Q2│ Q1│ Q0│  ← 帶 XOR 回授的移位暫存器
    └─┬─┴───┴───┴─┬─┘
      │            │
      └──── XOR ───┘
```

- 每個時脈週期，輸出值被 XOR 進入移位暫存器
- 最後暫存器中的值就是簽章
- 簽章與期望值比對：相同 → Pass，不同 → Fail

**混疊（Aliasing）**：錯誤的輸出碰巧產生正確的簽章的機率。

$$P(\text{aliasing}) \approx 2^{-n}$$

$n = 32$ 時，$P = 2^{-32} \approx 2.3 \times 10^{-10}$（幾乎不可能）。

---

## 五、JTAG / Boundary Scan（IEEE 1149.1）

### 5.1 什麼是 JTAG？

JTAG（Joint Test Action Group）是一個標準的測試介面，用於：
- 板級互連測試（Board-level interconnect test）
- 晶片內部掃描鏈存取
- 在線除錯（On-chip debug）
- FPGA 程式燒錄

### 5.2 JTAG 介面

只需要 **4～5 個 pin**：

| Pin | 名稱 | 功能 |
|-----|------|------|
| TCK | Test Clock | 測試時脈 |
| TMS | Test Mode Select | 控制 TAP 狀態機 |
| TDI | Test Data In | 測試資料輸入 |
| TDO | Test Data Out | 測試資料輸出 |
| TRST | Test Reset（可選） | 重置 |

### 5.3 Boundary Scan

在每個 I/O pad 旁加一個 Boundary Scan Cell：

```
    ┌─────────────────────────────────────┐
    │              晶片內部                 │
    │                                     │
    │  ┌───┐    ┌───┐    ┌───┐    ┌───┐  │
TDI─▶─│BS │──▶│BS │──▶│BS │──▶│BS │──▶── TDO
    │  │Cell│    │Cell│    │Cell│    │Cell│  │
    │  └─┬─┘    └─┬─┘    └─┬─┘    └─┬─┘  │
    │    │        │        │        │     │
    └────┼────────┼────────┼────────┼─────┘
         │        │        │        │
        Pin1     Pin2     Pin3     Pin4
         │        │        │        │
    ═════╪════════╪════════╪════════╪═════
                    PCB
```

用途：
- **板級測試**：不需要物理探針就能測試晶片間的連線
- **存取內部**：透過 JTAG 存取內部掃描鏈和除錯暫存器

---

## 六、記憶體測試：March Test

### 6.1 記憶體的故障模型

| 故障 | 說明 |
|------|------|
| SAF（Stuck-At Fault） | 某個 cell 永遠是 0 或 1 |
| TF（Transition Fault） | 某個 cell 無法從 0→1 或 1→0 |
| CF（Coupling Fault） | 寫入一個 cell 會影響另一個 cell |
| NPSF（Neighborhood Pattern Sensitive Fault） | 受鄰近 cell 圖案影響 |

### 6.2 March Test 格式

March Test 由一系列的 **March Element** 組成，每個 element 對所有地址依序執行一組操作。

格式：$\{⇑(r0, w1); ⇓(r1, w0, r0); ...\}$

- $⇑$：地址從小到大遍歷
- $⇓$：地址從大到小遍歷
- $⇕$：任意順序
- $r0$：讀取，期望值為 0
- $w1$：寫入 1

### 6.3 March C- 演算法 ★常用

$$\{⇕(w0); ⇑(r0, w1); ⇑(r1, w0); ⇓(r0, w1); ⇓(r1, w0); ⇕(r0)\}$$

- 6 個 March Element
- 總操作數：$10n$（n = 記憶體大小）
- 可偵測：SAF, TF, 部分 CF

複雜度：**O(n)**（線性！遠比窮舉法 O(n²) 好）

---

## 七、良率分析（Yield Analysis）★面試重點

### 7.1 基本概念

$$\boxed{Y = \frac{\text{良品數}}{\text{總晶片數}} \times 100\%}$$

良率是晶圓廠最重要的指標之一，直接影響成本和利潤。

### 7.2 隨機缺陷良率模型

#### Poisson 模型

假設缺陷完全隨機且均勻分佈：

$$\boxed{Y = e^{-A \cdot D_0}}$$

- $A$：晶片面積（cm²）
- $D_0$：缺陷密度（defects/cm²）

```
    Y(良率)
    ▲
  1.0│──╲
    │   ╲
  0.8│    ╲
    │     ╲
  0.6│      ╲
    │       ╲
  0.4│        ╲╲
    │          ╲╲
  0.2│            ╲╲╲
    │               ╲╲╲╲──
  0.0└─────────────────────▶ A·D₀
    0    1    2    3    4    5
```

#### Murphy 模型

考慮缺陷密度在晶圓上不均勻（更現實）：

$$\boxed{Y = \left(\frac{1 - e^{-A \cdot D_0}}{A \cdot D_0}\right)^2}$$

Murphy 模型比 Poisson 更樂觀（實際晶圓上有些區域缺陷多，有些少，好的區域良率很高）。

#### Negative Binomial 模型 ★最常用

$$\boxed{Y = \left(1 + \frac{A \cdot D_0}{\alpha}\right)^{-\alpha}}$$

- $\alpha$：群聚參數（Clustering Parameter）
  - $\alpha → ∞$：退化成 Poisson（完全隨機）
  - $\alpha → 0$：缺陷高度群聚

| 參數 | 意義 |
|------|------|
| $\alpha$ 大 | 缺陷分佈均勻 → 接近 Poisson |
| $\alpha$ 小 | 缺陷群聚嚴重 → 部分區域很好，部分很差 |
| 典型值 | $\alpha = 1～5$ |

### 7.3 三種模型比較

對相同的 $AD_0$ 值，三種模型的良率排序：

$$Y_{Murphy} > Y_{NegBin} > Y_{Poisson}$$

Poisson 最悲觀，Murphy 最樂觀。業界最常用 **Negative Binomial**。

---

### 數值例題 1：Poisson 良率計算

**題目**：晶片面積 $A = 100$ mm² = 1.0 cm²，缺陷密度 $D_0 = 0.5$ /cm²。使用 Poisson 模型計算良率。

**解答**：

$$Y = e^{-AD_0} = e^{-1.0 \times 0.5} = e^{-0.5} = \boxed{60.7\%}$$

---

### 數值例題 2：面積對良率的影響

**題目**：$D_0 = 0.3$ /cm²，用 Poisson 模型。比較面積為 50 mm², 100 mm², 200 mm² 的良率。

**解答**：

| 面積 | $A$ (cm²) | $AD_0$ | $Y = e^{-AD_0}$ |
|------|----------|--------|-----------------|
| 50 mm² | 0.5 | 0.15 | $e^{-0.15} = \boxed{86.1\%}$ |
| 100 mm² | 1.0 | 0.30 | $e^{-0.30} = \boxed{74.1\%}$ |
| 200 mm² | 2.0 | 0.60 | $e^{-0.60} = \boxed{54.9\%}$ |

面積加倍，良率大幅下降。這就是為什麼 Chiplet（小面積）的良率策略有優勢。

---

### 數值例題 3：Negative Binomial 模型

**題目**：$A = 1.5$ cm², $D_0 = 0.4$ /cm², $\alpha = 2$。用 Negative Binomial 和 Poisson 分別計算良率。

**解答**：

**Negative Binomial**：
$$Y = \left(1 + \frac{1.5 \times 0.4}{2}\right)^{-2} = \left(1 + 0.3\right)^{-2} = 1.3^{-2} = \frac{1}{1.69} = \boxed{59.2\%}$$

**Poisson**：
$$Y = e^{-1.5 \times 0.4} = e^{-0.6} = \boxed{54.9\%}$$

Negative Binomial（59.2%）> Poisson（54.9%）。差異來自缺陷群聚效應 —— 有些區域缺陷集中，其他區域反而乾淨。

---

## 八、測試流程：WAT → CP → FT

### 8.1 三階段測試

```
    製造完成
        │
        ▼
    ┌──────────┐
    │ WAT      │  晶圓允收測試
    │(Wafer    │  • 測試製程參數（Vt, Idsat, 電阻率...）
    │ Accept   │  • 在測試結構上（不是實際晶片）
    │ Test)    │  • 目的：確認製程是否在規格內
    └──────────┘
        │ Pass
        ▼
    ┌──────────┐
    │ CP       │  晶片探針測試
    │(Chip     │  • 用探針卡接觸晶圓上的每顆晶片
    │ Probing) │  • 執行功能測試和掃描測試
    │          │  • 標記壞的晶片（Ink dot 或 e-map）
    └──────────┘
        │ Pass
        ▼
    切割（Dicing）+ 封裝（Packaging）
        │
        ▼
    ┌──────────┐
    │ FT       │  最終測試
    │(Final    │  • 封裝後的完整測試
    │ Test)    │  • 包含 at-speed test, 溫度測試
    │          │  • 分 Bin（品質等級分類）
    └──────────┘
        │ Pass
        ▼
    出貨給客戶
```

### 8.2 三階段比較

| 項目 | WAT | CP | FT |
|------|-----|-----|-----|
| 測試對象 | 測試結構 | 晶圓上的晶片 | 封裝後晶片 |
| 測試目的 | 製程監控 | 篩選壞 die | 最終品質確認 |
| 測試內容 | 電性參數 | Scan + 功能 | 全面測試 |
| 溫度 | 室溫 | 室溫或熱測 | 多溫度 |
| 速度 | 低速 | 中速 | **at-speed** ★ |

### 8.3 Binning（分級）

FT 測試後，晶片依品質分成不同等級（Bin）：

| Bin | 說明 | 售價 |
|-----|------|------|
| Bin 1 | 最高性能，全部通過 | 最高 |
| Bin 2 | 性能稍低（可能降頻） | 中等 |
| Bin 3 | 部分功能關閉 | 較低 |
| Fail | 不合格 | 廢棄 |

> 例：CPU 中關閉部分核心、GPU 中關閉部分計算單元 → 以較低等級出售 → 提高整體良率

---

## 九、良率提升（Yield Learning / Yield Improvement）

### 9.1 良率爬坡曲線

```
    良率
    ▲
    │                          ────────── 成熟期
    │                     ╱
    │                  ╱
    │               ╱    ← 良率爬坡（Yield Ramp）
    │            ╱
    │         ╱
    │      ╱
    │   ╱
    │╱
    └────────────────────────────────────▶ 時間
     研發期    量產初期    成熟期

    從首次矽（First Silicon）到量產級良率
    通常需要 6～18 個月
```

### 9.2 良率提升方法

| 方法 | 說明 |
|------|------|
| 缺陷分析 | 用 SEM/TEM 分析失效晶片，找出根因（Root Cause） |
| 冗餘設計 | 記憶體加入備用列/行（Redundancy） |
| 製程改善 | 調整蝕刻、沉積參數 |
| 設計改善 | DFM（Design for Manufacturability） |
| 統計分析 | 分析 WAT/CP 數據，找出製程偏移趨勢 |

---

## 關鍵術語表

| 術語 | 英文全名 | 說明 |
|------|---------|------|
| DFT | Design for Testability | 可測試性設計 |
| SA0/SA1 | Stuck-at-0 / Stuck-at-1 | 固著故障 |
| Scan FF | Scan Flip-Flop | 掃描正反器 |
| Scan Chain | — | 掃描鏈 |
| SE | Scan Enable | 掃描致能信號 |
| SI/SO | Scan In / Scan Out | 掃描輸入/輸出 |
| ATPG | Automatic Test Pattern Generation | 自動測試向量產生 |
| D-Algorithm | — | 經典 ATPG 演算法 |
| PODEM | Path-Oriented Decision Making | 改良 ATPG 演算法 |
| Fault Coverage | — | 故障覆蓋率 |
| BIST | Built-In Self-Test | 內建自測試 |
| LFSR | Linear Feedback Shift Register | 線性回授移位暫存器 |
| MISR | Multiple Input Signature Register | 多輸入特徵暫存器 |
| JTAG | Joint Test Action Group | 標準測試介面 |
| Boundary Scan | — | 邊界掃描（IEEE 1149.1） |
| March Test | — | 記憶體測試演算法 |
| Yield | — | 良率 |
| $D_0$ | Defect Density | 缺陷密度（defects/cm²） |
| WAT | Wafer Acceptance Test | 晶圓允收測試 |
| CP | Chip Probing | 晶片探針測試 |
| FT | Final Test | 最終測試 |
| ATE | Automatic Test Equipment | 自動測試設備 |
| KGD | Known Good Die | 已知良品晶粒 |
| Binning | — | 晶片分級 |
| DFM | Design for Manufacturability | 可製造性設計 |
| Aliasing | — | 混疊（BIST 的假通過機率） |

---

## 題型鑑別

| 看到什麼關鍵字 | 對應主題 | 答題方向 |
|---------------|---------|---------|
| Stuck-at, SA0, SA1 | 故障模型 | 活化 + 傳播 |
| Scan, SE, SI, SO | 掃描設計 | 掃描鏈結構、功能/測試模式 |
| ATPG, D算法 | 測試向量產生 | D/D̄ 傳播 |
| Fault Coverage | 故障覆蓋率 | 百分比計算 |
| LFSR, MISR, BIST | 內建自測試 | 偽隨機序列、簽章壓縮 |
| JTAG, Boundary Scan | 板級測試 | IEEE 1149.1 介面 |
| March Test | 記憶體測試 | 操作序列、複雜度 |
| 良率, $D_0$, 面積 | 良率分析 | Poisson / Neg Binomial |
| WAT, CP, FT | 測試流程 | 三階段比較 |

---

## ✅ 自我檢測

### 基礎題

<details>
<summary>Q1：掃描設計（Scan Design）的基本原理是什麼？為什麼要把 DFF 改成 Scan FF？</summary>

**答案**：
**原理**：把所有 D 正反器改成 Scan FF（加一個 MUX），並串成掃描鏈。在掃描模式下，所有 FF 形成一個長的移位暫存器，可以從 SI 端載入任意測試向量，並從 SO 端讀出結果。

**為什麼要改造**：
1. 時序電路有內部狀態（FF 的值），外部不可直接控制和觀察
2. Scan FF 讓測試時可以**直接設定**每個 FF 的值（提高可控性）
3. 也可以**直接讀出**每個 FF 的值（提高可觀察性）
4. 這樣就把時序電路的測試問題**簡化為組合邏輯的測試問題**
</details>

<details>
<summary>Q2：BIST 中 LFSR 和 MISR 的角色分別是什麼？</summary>

**答案**：
- **LFSR（線性回授移位暫存器）**：**測試向量產生器**。用簡單的硬體（幾個 FF + XOR）產生偽隨機序列作為測試向量。$n$-bit LFSR 可產生最多 $2^n - 1$ 個不同向量

- **MISR（多輸入特徵暫存器）**：**輸出壓縮器**。把被測電路的多個輸出在多個時脈週期的結果壓縮成一個短的「簽章」（Signature）。最後只需比對簽章是否正確，不需逐一比對每個輸出

混疊（Aliasing）機率 ≈ $2^{-n}$（$n$ = MISR 位元數），通常 $n ≥ 32$，混疊機率極低
</details>

<details>
<summary>Q3：Stuck-at fault 模型中，如何偵測「線 b 的 SA0」故障？需要什麼條件？</summary>

**答案**：
偵測 b SA0 需要兩個條件：

1. **活化（Activate）**：讓 b 的正常值為 1（這樣 SA0 才會造成差異）
   - 意味著輸入組合必須讓 b = 1

2. **傳播（Propagate）**：讓 b 的值差異能傳播到主要輸出（PO）
   - 從 b 到某個輸出的路徑上，所有其他閘的輸入必須設為「非控制值」（non-controlling value）
   - 例如 AND 閘的非控制值是 1，OR 閘的非控制值是 0

如果同時滿足活化和傳播，就能在輸出觀察到差異，從而偵測這個故障
</details>

<details>
<summary>Q4：WAT, CP, FT 三個測試階段各自的目的和測試對象是什麼？</summary>

**答案**：

| 階段 | 目的 | 測試對象 | 測試內容 |
|------|------|---------|---------|
| **WAT** | 製程監控 | 晶圓上的**測試結構** | 電性參數（Vt, Idsat, 電阻率） |
| **CP** | 篩選壞 die | 晶圓上的**每顆晶片** | Scan test + 基本功能測試 |
| **FT** | 最終品質確認 | **封裝後**的晶片 | 全面測試 + at-speed + 多溫度 |

重要差異：
- WAT 不測實際晶片，只測特殊設計的測試結構
- CP 用探針卡在晶圓上直接測試，壞的晶片會被標記不切割
- FT 是最嚴格的測試，包含 at-speed 測試和溫度變化測試
</details>

### 計算題

<details>
<summary>Q5：晶片面積 150 mm², 缺陷密度 D₀ = 0.2 /cm²。用 Poisson 模型和 Neg Binomial（α=3）分別計算良率。</summary>

**答案**：

$A = 1.5$ cm², $D_0 = 0.2$ /cm², $AD_0 = 0.3$

**Poisson**：
$$Y = e^{-0.3} = \boxed{74.1\%}$$

**Negative Binomial**（$\alpha = 3$）：
$$Y = \left(1 + \frac{0.3}{3}\right)^{-3} = (1.1)^{-3} = \frac{1}{1.331} = \boxed{75.1\%}$$

Neg Binomial（75.1%）略高於 Poisson（74.1%），因為考慮了缺陷群聚效應。
</details>

<details>
<summary>Q6：一片 300mm 晶圓上可切出多少顆 10mm × 10mm 的晶片？若良率 70%，可得多少顆良品？</summary>

**答案**：

晶圓面積 = $\pi \times (150)^2 = 70,686$ mm²
晶片面積 = $10 \times 10 = 100$ mm²

粗估晶片數：$70,686 / 100 = 707$ 顆

但晶圓是圓形，邊緣切不出完整晶片。用 Dies per Wafer 近似公式：

$$N \approx \frac{\pi d^2}{4A} - \frac{\pi d}{\sqrt{2A}}$$
$$= \frac{\pi \times 300^2}{4 \times 100} - \frac{\pi \times 300}{\sqrt{200}}$$
$$= 707 - 66.6 \approx \boxed{640 \text{ 顆}}$$

良品數 = $640 \times 0.70 = \boxed{448 \text{ 顆}}$
</details>

<details>
<summary>Q7：Chiplet 良率優勢：比較一顆 400mm² 的大 die vs 4 顆 100mm² 的 Chiplet。D₀ = 0.3/cm²，用 Poisson 模型。</summary>

**答案**：

**大 Die（400 mm² = 4 cm²）**：
$$Y = e^{-4 \times 0.3} = e^{-1.2} = \boxed{30.1\%}$$

**單顆 Chiplet（100 mm² = 1 cm²）**：
$$Y_{chiplet} = e^{-1 \times 0.3} = e^{-0.3} = 74.1\%$$

**4 顆都好的組合良率**：
$$Y_{system} = 0.741^4 = \boxed{30.1\%}$$

表面上一樣！但 Chiplet 的真正優勢是：
1. 可以**分別測試**，壞的不用（只浪費 100mm² 而非 400mm²）
2. 可以用**不同製程**（省成本）
3. **可重用**相同的 Chiplet 在不同產品中

考慮分別測試的有效良率：
- 需要 4 顆好的，每顆 74.1% pass → 平均嘗試 4/0.741 = 5.4 顆 Chiplet
- 浪費的矽面積 = 1.4 × 100 = 140 mm²（vs 大 Die 失敗浪費 400 mm²）
</details>

---

> **恭喜完成全部 8 章！** 你現在已具備 EDA 與 IC 製程的完整基礎知識。
> 回到 [eda_01_IC設計流程總覽.md](eda_01_IC設計流程總覽.md) 複習全流程。
