# 解題思考過程：面試官視角 — 你的大腦「作業系統」

> **適用對象**：已學完 01-18 基礎算法、準備 Google / NVIDIA 面試的工程師
> **本文主題**：不是教你算法，是教你「怎麼想」— 面試時腦中的 mental framework
> **語言**：繁體中文解說 + English technical terms
> **核心價值**：把「亂猜算法」升級為「系統性定位算法」的思考作業系統

---

## 第一章：面試的前兩分鐘決定一切

面試 45 分鐘，前 2 分鐘的思考方向決定了你 80% 的命運。

想像你是一位急診醫生：病人進來，你不會立刻開刀。你會先做 **triage**（分診）：量血壓、看瞳孔、問病史。2 分鐘內決定送哪一科。

解 LeetCode 一模一樣。你需要一個 **2 分鐘 triage algorithm**。

### 你的大腦應該跑的 4-Step Algorithm

```
┌─────────────────────────────────────────────────────────────────┐
│                   2-Minute Triage Algorithm                      │
│                                                                  │
│  Step 1 (30s): 讀題 → 識別「資料結構」                            │
│  ┌──────────────────────────────────────────────────────┐        │
│  │  Input 是什麼？  Array? String? Tree? Graph? Matrix? │        │
│  │  Output 要什麼？ 一個值? 一組值? True/False? 一個結構? │        │
│  └──────────────────────────────────────────────────────┘        │
│                            ▼                                     │
│  Step 2 (30s): 識別「問題類型」                                   │
│  ┌──────────────────────────────────────────────────────┐        │
│  │  找？數？最？排？建？驗？列？連？                       │        │
│  │  (Find? Count? Optimize? Sort? Build? Validate?      │        │
│  │   Enumerate? Connect?)                                │        │
│  └──────────────────────────────────────────────────────┘        │
│                            ▼                                     │
│  Step 3 (30s): 識別「關鍵約束」                                   │
│  ┌──────────────────────────────────────────────────────┐        │
│  │  有排序嗎？有重複嗎？有負數嗎？                        │        │
│  │  資料規模多大？有什麼特殊條件？                        │        │
│  └──────────────────────────────────────────────────────┘        │
│                            ▼                                     │
│  Step 4 (30s): 連結到「算法家族」                                 │
│  ┌──────────────────────────────────────────────────────┐        │
│  │  根據 Step 1-3，從情境地圖中定位算法                   │        │
│  │  → "Sorted array + find target = Binary Search"       │        │
│  │  → "Graph + shortest = BFS / Dijkstra"                │        │
│  └──────────────────────────────────────────────────────┘        │
└─────────────────────────────────────────────────────────────────┘
```

### Step 1 詳解：讀題 → 識別資料結構

很多人讀題只看「故事」，但你要看的是**資料的形狀**。

```
題目描述                              → 你應該看到的
─────────────────────────────────────────────────────────────
"Given an array of integers..."       → Input: Array<int>
"Given a string s..."                 → Input: String (= char array)
"Given the root of a binary tree..."  → Input: TreeNode (tree structure)
"There are n cities connected by..."  → Input: Graph (adjacency list/matrix)
"Given a m x n grid..."              → Input: 2D Matrix
"Given a linked list..."              → Input: LinkedList
"Given a stream of integers..."       → Input: Stream (→ need online algorithm)

Output 判斷：
"return true if..."                   → Output: Boolean
"return the minimum cost..."          → Output: Single value (optimization)
"return all possible..."              → Output: List of results (enumeration)
"return the kth largest..."           → Output: Single value (selection)
"return the length of..."             → Output: Single value (counting/measuring)
```

### Step 2 詳解：識別問題類型（8 大類）

```
類型    English        典型關鍵字                   常見算法方向
────────────────────────────────────────────────────────────────────
找(Find)  Search       "find", "search", "contains"  HashMap, Binary Search, DFS/BFS
數(Count) Count        "how many", "count", "number"  DP, HashMap, Math
最(Opt)   Optimize     "minimum", "maximum", "best"   DP, Greedy, Binary Search on Answer
排(Sort)  Sort/Order   "sort", "order", "arrange"     Sorting, Heap, Bucket Sort
建(Build) Construct    "design", "implement", "build" OOP + 合適的 Data Structure
驗(Valid) Validate     "valid", "possible", "check"   DFS/BFS reachability, DP, Greedy
列(Enum)  Enumerate    "all", "every", "generate"     Backtracking, BFS
連(Conn)  Connect      "connected", "path", "reach"   Union-Find, BFS/DFS, Dijkstra
```

### Step 3 詳解：識別關鍵約束

約束條件不是廢話，每一個字都在暗示你該用什麼算法：

```
約束條件                     暗示
──────────────────────────────────────────────────────────────
"array is sorted"           → Binary Search / Two Pointers
"array is not sorted"       → 可能需要 Sort，或用 HashMap 避免排序
"no duplicates"             → HashSet 可用，不用擔心去重
"with duplicates"           → 排序 + 跳過重複 / HashMap counting
"negative numbers allowed"  → 不能用某些 Greedy / Sliding Window 可能失效
"n ≤ 20"                   → 暴力/Backtracking/Bitmask OK
"n ≤ 10^5"                 → 需要 O(n) 或 O(n log n)
"1 ≤ n ≤ 10^9"            → O(log n) 必須，Binary Search on Answer
"in-place"                  → Two Pointers / Swap
"constant extra space"      → 不能用 HashMap，要用 Math / Bit tricks
```

### Step 4 詳解：連結到算法家族

這一步是前三步的**交叉查詢**：

```
IF input == sorted_array AND goal == find:
    → Binary Search
ELIF input == unsorted_array AND goal == find_pair:
    → HashMap
ELIF input == array AND goal == find_subarray AND constraint == contiguous:
    → Sliding Window / Prefix Sum
ELIF input == tree AND goal == any:
    → DFS (first choice) or BFS
ELIF input == graph AND goal == shortest_path:
    → BFS (unweighted) / Dijkstra (weighted)
ELIF input == graph AND goal == connectivity:
    → Union-Find / DFS
ELIF goal == enumerate_all:
    → Backtracking
ELIF goal == optimize AND structure == overlapping_subproblems:
    → DP
ELIF goal == optimize AND greedy_choice_property:
    → Greedy
```

### 完整 2 分鐘示範

**題目**：「Given a string s, find the length of the longest substring without repeating characters.」

```
你的大腦（2 分鐘）：

Step 1 (讀題):
  - Input = String
  - Output = 一個數字（長度）

Step 2 (問題類型):
  - "longest" → 最(Optimize) → 求最大值
  - "substring" → 連續子序列

Step 3 (關鍵約束):
  - "without repeating" → 需要追蹤元素是否出現過
  - "substring" (not subsequence) → 連續！
  - String 長度通常 ≤ 10^5 → 需要 O(n) 或 O(n log n)

Step 4 (連結算法):
  - 連續子序列 + 條件限制 → Sliding Window!
  - 追蹤是否重複 → 用 HashSet 在視窗內檢查
  - 算法確定: Sliding Window + HashSet, O(n) time

結論: 用 variable-length Sliding Window，
      左右指標維護一個「無重複字元」的視窗，
      右指標擴張時加入 HashSet，
      遇到重複時左指標收縮並移除 HashSet。
```

---

## 第二章：資料規模 → 複雜度 → 算法 的逆推法

這是大多數候選人不知道的 **secret weapon**。

面試官給你 constraint `1 ≤ n ≤ 10^5`，這不只是告訴你 edge case，
更是在**暗示你算法的複雜度上限**。

### 2.1 核心對照表

LeetCode 的 judge 大約能在 1-2 秒內執行 **10^7 ~ 10^8** 次操作。
根據這個，我們可以反推：

```
┌────────────┬──────────────────┬─────────────────────────────────────┐
│ n 的範圍    │ 可接受的複雜度     │ 可能的算法                           │
├────────────┼──────────────────┼─────────────────────────────────────┤
│ n ≤ 10     │ O(n!) or O(2^n)  │ Brute force, Backtracking 全枚舉     │
│ n ≤ 20     │ O(2^n)           │ Backtracking, Bitmask DP             │
│ n ≤ 100    │ O(n^3)           │ 3 層 DP, Floyd-Warshall              │
│ n ≤ 500    │ O(n^3)           │ 3 層迴圈 DP                          │
│ n ≤ 1,000  │ O(n^2)           │ 2D DP, Brute force + 優化            │
│ n ≤ 5,000  │ O(n^2)           │ 2D DP（剛好能過）                    │
│ n ≤ 10^5   │ O(n log n)       │ Sort, Binary Search, Heap, Divide&C │
│ n ≤ 10^6   │ O(n)             │ HashMap, Two Pointers, Sliding Win  │
│            │                  │ Greedy, Prefix Sum                   │
│ n ≤ 10^9   │ O(log n) or O(1) │ Binary Search on Answer, Math, Bit  │
└────────────┴──────────────────┴─────────────────────────────────────┘
```

### 2.2 逆推法的思考流程

```
讀到 constraint → 算出複雜度上限 → 排除不可能的算法 → 縮小搜尋範圍

例如：
  n ≤ 10^5
  → 最多 O(n log n)
  → 排除 O(n^2) 的暴力枚舉 / 2D DP
  → 可能是: Sorting? Binary Search? Heap? Greedy? HashMap?
  → 結合 Step 1-3 的資訊，進一步縮小
```

### 2.3 十個逆推法實戰範例

**範例 1: Two Sum (n ≤ 10^4)**
```
n ≤ 10^4 → O(n^2) 勉強可以，但 O(n) 更好
→ O(n^2) 暴力解: 雙重迴圈，每對都檢查 → 能過但不夠好
→ O(n) 優化: HashMap 存 {value: index}，一次遍歷
→ 選擇 HashMap，O(n) ✓
```

**範例 2: Longest Increasing Subsequence (n ≤ 2500)**
```
n ≤ 2500 → O(n^2) 可以！
→ DP: dp[i] = 以 nums[i] 結尾的最長遞增子序列長度
→ 轉移: dp[i] = max(dp[j] + 1) for all j < i where nums[j] < nums[i]
→ O(n^2) DP 可行 ✓
→ 進階: O(n log n) 用 Binary Search + patience sorting（面試加分）
```

**範例 3: Maximum Subarray (n ≤ 10^5)**
```
n ≤ 10^5 → 最多 O(n log n)，最好 O(n)
→ 排除 O(n^2) 暴力枚舉所有 subarray
→ O(n) 方案: Kadane's Algorithm (DP 變形)
→ 或 Prefix Sum: max_subarray = max(prefix[j] - prefix[i]) for i < j
→ 選擇 Kadane's，O(n) ✓
```

**範例 4: N-Queens (n ≤ 9)**
```
n ≤ 9 → O(n!) 完全可以！
→ 這就是在暗示你：用 Backtracking 暴力枚舉
→ 9! = 362,880 → 加上剪枝，實際更少
→ Backtracking + 三條對角線/行/列的剪枝 ✓
```

**範例 5: Coin Change (amount ≤ 10^4, coins.length ≤ 12)**
```
amount ≤ 10^4 → O(n × amount) 可以，n 是 coin 種類數
→ DP: dp[i] = 湊出金額 i 的最少硬幣數
→ O(12 × 10^4) = O(1.2 × 10^5) → 輕鬆 ✓
```

**範例 6: Median of Two Sorted Arrays (m + n ≤ 2 × 10^6)**
```
題目明確要求 O(log(m+n))
→ m + n ≤ 2 × 10^6 但複雜度要求是 O(log n)
→ 排除 merge 後取中位數的 O(m+n)（雖然能過，但不符合要求）
→ Binary Search on shorter array ✓
```

**範例 7: Word Search II (board ≤ 12×12, words ≤ 3×10^4)**
```
Board 很小但 words 很多
→ 如果每個 word 做一次 DFS: O(words × m × n × 4^L) → 太慢
→ 反過來：用 Trie 存所有 words，在 board 上 DFS 一次
→ Trie + Backtracking ✓
```

**範例 8: Koko Eating Bananas (piles.length ≤ 10^4, piles[i] ≤ 10^9)**
```
piles[i] ≤ 10^9 → 答案空間是 [1, 10^9]
→ O(10^9) 線性搜尋不行
→ 但答案有單調性：速度越快，所需時間越少
→ Binary Search on Answer! O(n × log(max_pile)) ✓
→ n = 10^4, log(10^9) ≈ 30 → 3 × 10^5，輕鬆
```

**範例 9: Course Schedule (numCourses ≤ 2000, prerequisites ≤ 5000)**
```
V ≤ 2000, E ≤ 5000 → O(V + E) 完全可以
→ 有向圖 + 依賴關係 → Topological Sort
→ 如果有環就不可能完成 → 檢測 cycle
→ Kahn's Algorithm (BFS) 或 DFS + 狀態標記 ✓
```

**範例 10: Travelling Salesman (n ≤ 20)**
```
n ≤ 20 → O(2^n × n) 可以！
→ 2^20 × 20 = 20,971,520 ≈ 2 × 10^7 → 能過
→ Bitmask DP: dp[mask][i] = 訪問過 mask 集合的城市，最後在城市 i 的最短路
→ Bitmask DP ✓
```

---

## 第三章：「看到什麼 → 想到什麼」的條件反射訓練

這一章的目標：把 pattern recognition 訓練成 **muscle memory**。
就像籃球員看到防守站位就知道該傳哪裡，你看到題目特徵就要反射性想到算法。

### 3.1 Input 信號 → 算法映射

```
┌─────────────────────────────┬──────────────────────────────────────────┐
│ 看到什麼 Input               │ 立刻想到                                  │
├─────────────────────────────┼──────────────────────────────────────────┤
│ sorted array                │ Binary Search / Two Pointers              │
│ unsorted array + find pair  │ HashMap (complement lookup)               │
│ unsorted array + find range │ Sort first, then Binary Search/Two Ptr   │
│ string + substring          │ Sliding Window                            │
│ string + subsequence        │ DP (2D) / Two Pointers (if simple)       │
│ string + permutation/anagram│ HashMap (frequency count) / Sort          │
│ binary tree                 │ DFS (recursive, 90% of the time)          │
│ n-ary tree                  │ DFS / BFS (same idea, more children)     │
│ BST                         │ Inorder = sorted! Binary Search on tree   │
│ graph + unweighted          │ BFS (shortest path in unweighted)        │
│ graph + weighted            │ Dijkstra (non-negative) / Bellman-Ford   │
│ graph + negative weights    │ Bellman-Ford (can detect neg cycles)     │
│ grid of 0 and 1             │ BFS/DFS (island/region problems)         │
│ prerequisites/dependencies  │ Topological Sort (DAG)                    │
│ "is X connected to Y?"      │ Union-Find / BFS / DFS                   │
│ parentheses / nesting       │ Stack                                     │
│ expression evaluation       │ Stack (operator precedence)               │
│ stream of data / online     │ Heap (maintain top-K dynamically)        │
│ dictionary + prefix query   │ Trie                                      │
│ intervals                   │ Sort by start + Greedy / Sweep Line      │
│ matrix + path               │ DP / BFS / DFS                           │
│ linked list                 │ Two Pointers (fast/slow) / Dummy Head    │
└─────────────────────────────┴──────────────────────────────────────────┘
```

### 3.2 Output / Goal 信號 → 算法映射

```
┌──────────────────────────────────────────┬────────────────────────────────────────┐
│ 題目要什麼                                │ 立刻想到                                │
├──────────────────────────────────────────┼────────────────────────────────────────┤
│ "return true/false if possible"          │ DP / Greedy / BFS/DFS reachability     │
│ "return minimum/maximum value"           │ DP / Greedy / Binary Search on Answer  │
│ "return all possible results"            │ Backtracking (DFS + pruning)           │
│ "return count of ways"                   │ DP (counting problems)                 │
│ "return shortest path / minimum steps"   │ BFS (unweighted) / Dijkstra (weighted)│
│ "return kth largest/smallest"            │ Heap / QuickSelect / Sort              │
│ "return longest/shortest substring"      │ Sliding Window / DP                    │
│ "return longest subsequence"             │ DP (LIS/LCS pattern)                   │
│ "return connected components"            │ Union-Find / DFS / BFS                 │
│ "return valid ordering"                  │ Topological Sort                       │
│ "return the median"                      │ Two Heaps (max-heap + min-heap)        │
│ "return next greater/smaller element"    │ Monotonic Stack                        │
│ "return if string matches pattern"       │ DP / Recursion + Memo                  │
│ "design a data structure"                │ HashMap + LinkedList / Heap / Trie     │
└──────────────────────────────────────────┴────────────────────────────────────────┘
```

### 3.3 Constraint 信號 → 算法映射

```
┌──────────────────────────────────┬──────────────────────────────────────────┐
│ 看到什麼限制                      │ 意味著                                    │
├──────────────────────────────────┼──────────────────────────────────────────┤
│ "in-place, O(1) space"          │ Two Pointers / Swap tricks / Math        │
│ "O(n) time required"            │ HashMap / Sliding Window / Greedy        │
│ "without extra space"           │ Bit manipulation / Math / Morris Trav.   │
│ "consecutive / contiguous"      │ Sliding Window / Prefix Sum              │
│ "subsequence (not contiguous)"  │ DP / Greedy (if LIS-type)               │
│ "at most K distinct"            │ Sliding Window + HashMap counter         │
│ "exactly K times"               │ atMost(K) - atMost(K-1) 技巧             │
│ "non-decreasing order"          │ 已排序 → Binary Search / Two Pointers    │
│ "cyclic / circular array"       │ 模運算 i % n / 拆成兩倍長度               │
│ "immutable array (cannot modify)"│ 不能排序 → HashMap / Binary Search       │
│ "follow-up: O(log n)?"          │ Binary Search (幾乎確定)                  │
│ "values in range [1, n]"        │ 用 index 當 HashMap (O(1) space trick)   │
│ "32-bit integer"                │ 注意 overflow，可能需要 long              │
└──────────────────────────────────┴──────────────────────────────────────────┘
```

### 3.4 組合信號的威力

單一信號可能模糊，但 **兩個以上信號交叉** 幾乎可以鎖定算法：

```
Input: sorted array + Goal: find target
→ 信號交叉: sorted + find → Binary Search (99% 確定)

Input: array + Goal: find subarray with sum = k + Constraint: contiguous
→ 信號交叉: subarray + contiguous + sum → Prefix Sum + HashMap

Input: string + Goal: longest substring + Constraint: at most k distinct chars
→ 信號交叉: substring + longest + constraint → Sliding Window

Input: graph + Goal: shortest path + Constraint: unweighted
→ 信號交叉: graph + shortest + unweighted → BFS

Input: array + Goal: all subsets + Constraint: n ≤ 20
→ 信號交叉: all + subsets + small n → Backtracking or Bitmask
```

---

## 第四章：面試中的溝通模板

面試不只考 coding，更考你**能不能清楚地表達思路**。
以下是 Google 面試官期望聽到的溝通結構。

### Phase 1: Clarify（1-2 min）

**目的**：確認你理解題目，同時展現嚴謹的思維。

```
模板句型（英文面試）：

"Let me make sure I understand the problem correctly.
 We're given [input description], and we need to return [output description].
 A few clarifying questions:"

必問的問題清單：
──────────────────────────────────────────────────
1. Input format:
   "What's the range of n? Can n be 0?"

2. Edge cases:
   "Can the array be empty?"
   "Can there be negative numbers?"
   "Can there be duplicates?"

3. Output format:
   "Should I return indices or values?"
   "If there are multiple answers, should I return any one or all of them?"
   "If no answer exists, what should I return? -1? empty array?"

4. Constraints:
   "Is the input sorted?"
   "Are there any time/space complexity requirements?"
```

**常見 clarifying question 範例**：

```
Two Sum:
  "Can the same element be used twice?" → No
  "Is there exactly one solution?"       → Yes
  "Can the array contain negatives?"     → Yes

Valid Parentheses:
  "Can the string be empty?"            → Yes, return true
  "Can it contain non-bracket chars?"   → No, only ()[]{}

Number of Islands:
  "Is the grid always rectangular?"      → Yes
  "Can it be empty?"                     → No, at least 1x1
  "Do diagonals count as connected?"     → No, only 4-directional
```

### Phase 2: Approach（3-5 min）

**黃金法則：先說暴力解，再優化。**

這不是示弱，這是展現你的思維深度。面試官想看到你從 O(n^2) 到 O(n) 的進化過程。

```
模板句型：

Step A - 暴力解:
"The brute force approach would be to [describe].
 That would be O(n^2) time and O(1) space."

Step B - 觀察:
"However, I notice that [key insight].
 For example, [concrete example]."

Step C - 優化:
"So instead, we can use [algorithm/data structure].
 The idea is [1-2 sentence explanation].
 This gives us O(n) time and O(n) space."

Step D - 確認:
"Does this approach make sense? Should I go ahead and code it?"
```

**範例（Two Sum）**：

```
"The brute force would be to check every pair —
 two nested loops, O(n^2) time.

 But I notice that for each number, I just need to find
 if (target - num) exists somewhere else in the array.
 That's a lookup problem.

 So I can use a HashMap: as I iterate, I store each number
 and its index. For each new number, I check if the complement
 is already in the map. One pass, O(n) time, O(n) space.

 Shall I code this up?"
```

### Phase 3: Code（10-15 min）

**邊寫邊說**，讓面試官知道你在想什麼。

```
不好的寫法（沈默 10 分鐘然後說 "done"）

好的寫法（邊寫邊解釋）：
"First, I'll initialize a HashMap to store values we've seen..."
  seen = {}

"Then I'll iterate through the array with index and value..."
  for i, num in enumerate(nums):

"For each number, I check if the complement exists in our map..."
  complement = target - num
  if complement in seen:
      return [seen[complement], i]

"If not, I store the current number and its index..."
  seen[num] = i

"If we exhaust the array without finding a pair, we return empty..."
  return []

"Wait — the problem guarantees exactly one solution,
 so we should never reach that last line. But I'll keep it
 for defensive programming."
```

### Phase 4: Test（3-5 min）

```
模板句型：

"Let me walk through this with an example.
 Given nums = [2, 7, 11, 15], target = 9..."

Trace:
  i=0: num=2, complement=7, seen={} → 7 not in seen → seen={2:0}
  i=1: num=7, complement=2, seen={2:0} → 2 IS in seen! → return [0, 1] ✓

"Now let me think about edge cases..."
  - Empty array → loop doesn't execute → return []
  - Single element → complement can't be found → return []
  - Negative numbers → works fine, HashMap handles negatives
  - Duplicate values → e.g., [3, 3], target=6 → works because
    we check BEFORE inserting

"Time: O(n) — one pass through the array.
 Space: O(n) — HashMap stores at most n entries."
```

---

## 第五章：「卡住了」的急救指南

卡住是正常的。Google 面試官知道你會卡住。
他們觀察的是：**你卡住之後怎麼 recover**。

以下 10 個策略，每個都有具體範例。

### 策略 1：畫圖！（Draw it out!）

很多問題用文字想很抽象，畫出來就清楚了。

**範例 A — Linked List Cycle Detection**
```
卡住：怎麼偵測環？記得走過的所有 node？太浪費空間。

畫圖：
  1 → 2 → 3 → 4 → 5
                ↑       ↓
                8 ← 7 ← 6

畫完後靈感：如果有兩個人在跑道上跑，
一個快一個慢，有環的話遲早會相遇！
→ 快慢指標 (Floyd's Cycle Detection) ✓
```

**範例 B — Trapping Rain Water**
```
卡住：怎麼計算每個位置能存多少水？

畫圖：
  elevation = [0,1,0,2,1,0,1,3,2,1,2,1]

        █
    █   ██ █
  █ ██ ████ █
  ─────────────

畫完後觀察：每個位置的水量 = min(左邊最高, 右邊最高) - 自己的高度
→ 需要左最大和右最大 → Two Pointers from both ends ✓
```

### 策略 2：暴力解先行（Brute force first）

**範例 A — Best Time to Buy and Sell Stock**
```
卡住：怎麼找最大利潤？

暴力解：嘗試每一對 (buy, sell) → O(n^2)
  for i in range(n):      # buy day
    for j in range(i+1, n):  # sell day
      profit = max(profit, prices[j] - prices[i])

觀察暴力解：我在找 max(prices[j] - prices[i])，其中 j > i
→ 如果我記住「到目前為止的最低價」，每天算利潤就好
→ 一次遍歷，O(n) ✓
```

**範例 B — 3Sum**
```
卡住：怎麼找三個數和為 0？

暴力解：三層迴圈 → O(n^3)
觀察：如果先排序，固定一個數 a，
問題變成「在剩餘中找兩個數和為 -a」→ 這是 Two Sum！
→ Sort + Two Pointers → O(n^2) ✓
```

### 策略 3：反向思考（Think backwards）

**範例 A — Product of Array Except Self**
```
卡住：不能用除法，怎麼算「除了自己以外的乘積」？

反向思考：result[i] = 左邊所有數的乘積 × 右邊所有數的乘積
→ 先算 prefix product (從左到右)
→ 再算 suffix product (從右到左)
→ 兩者相乘即可 ✓
```

**範例 B — First Missing Positive**
```
卡住：O(n) time, O(1) space 怎麼找第一個缺失的正整數？

反向思考：答案一定在 [1, n+1] 範圍內
（因為最多 n 個位置，最好的情況是 1,2,...,n 都在）
→ 可以把 array 自己當成 HashMap！
→ 把數字 x 放到 index x-1 的位置
→ 掃一遍找第一個 nums[i] != i+1 的位置 ✓
```

### 策略 4：簡化問題（Start with n=1, 2, 3）

**範例 A — Climbing Stairs**
```
卡住：有幾種方式爬到第 n 階？

簡化：
  n=1: 1 種 (1步)
  n=2: 2 種 (1+1, 2)
  n=3: 3 種 (1+1+1, 1+2, 2+1)
  n=4: 5 種 ...

觀察：f(n) = f(n-1) + f(n-2) → Fibonacci!
→ DP: dp[i] = dp[i-1] + dp[i-2] ✓
```

**範例 B — Unique Paths in Grid**
```
卡住：從左上到右下有幾條路？

簡化：
  1×1 grid: 1 path
  1×2 grid: 1 path (只能往右)
  2×1 grid: 1 path (只能往下)
  2×2 grid: 2 paths (右下 or 下右)
  2×3 grid: 3 paths
  3×3 grid: 6 paths

觀察：dp[i][j] = dp[i-1][j] + dp[i][j-1]
→ 2D DP ✓
```

### 策略 5：看約束條件（Let constraints guide you）

**範例 A — Subsets (n ≤ 10)**
```
卡住：不知道用什麼算法。
看約束：n ≤ 10 → 2^10 = 1024 → 非常小！
→ 可以用 Bitmask 枚舉所有子集
→ 或用 Backtracking ✓
```

**範例 B — Longest Valid Parentheses (s.length ≤ 3×10^4)**
```
卡住：不知道用 Stack 還是 DP。
看約束：n ≤ 3×10^4 → O(n) 或 O(n log n)
→ Stack 解法: O(n) → 可以
→ DP 解法: O(n) → 也可以
→ 兩種都行，選你更熟的 ✓
```

### 策略 6：找重複計算（Spot repeated work → DP）

**範例 A — Fibonacci**
```
Recursive: fib(5) = fib(4) + fib(3)
                   = (fib(3) + fib(2)) + (fib(2) + fib(1))
                   = ...

觀察：fib(3) 被算了 2 次，fib(2) 被算了 3 次
→ 有 overlapping subproblems → Memoization / DP ✓
```

**範例 B — Minimum Path Sum**
```
暴力 DFS 走所有路徑 → 很多格子被重複訪問
→ 同一個格子到終點的最短路只需要算一次
→ DP: dp[i][j] = grid[i][j] + min(dp[i+1][j], dp[i][j+1]) ✓
```

### 策略 7：換資料結構（Try a different data structure）

**範例 A — Sliding Window Maximum**
```
卡住：Sliding Window 內怎麼快速取最大值？
原本用 array 存視窗 → 取 max 是 O(k)
→ 換成 Monotonic Deque → 取 max 是 O(1) ✓
```

**範例 B — LRU Cache**
```
卡住：怎麼同時做到 O(1) get 和 O(1) put？
HashMap → O(1) get ✓，但不知道 LRU 順序
Linked List → 知道順序，但 O(n) get
→ 兩個一起用！HashMap + Doubly Linked List ✓
```

### 策略 8：分而治之（Divide and Conquer）

**範例 A — Merge Sort**
```
卡住：怎麼用 O(n log n) 排序？
→ 把 array 切成兩半，分別排序，再 merge
→ T(n) = 2T(n/2) + O(n) → O(n log n) ✓
```

**範例 B — Maximum Subarray (Divide & Conquer approach)**
```
卡住：除了 Kadane's 還有別的方法嗎？
→ 最大子陣列要嘛在左半邊、右半邊、或跨越中點
→ 左右遞迴解決，跨越中點的 O(n) 掃描
→ T(n) = 2T(n/2) + O(n) → O(n log n) ✓
```

### 策略 9：跟面試官討論（Collaborate, don't suffer silently）

```
這不是示弱，這是展現溝通能力！

好的求助方式：
"I'm considering using [algorithm A] because [reason],
 but I'm not sure about [specific uncertainty].
 Can you give me a hint about [specific direction]?"

不好的求助方式：
"I have no idea."  ← 太消極
"Is it DP?"         ← 太隨意，像在猜

面試官常見的暗示：
  "What if the array were sorted?" → 暗示先排序 / Binary Search
  "Can you think of a way to reduce the search space?" → Binary Search
  "Is there repeated work?" → DP / Memoization
  "What data structure gives O(1) lookup?" → HashMap
```

### 策略 10：先寫暴力解（A working solution beats no solution）

```
面試評分：
  完美解 > 暴力解 > 接近但有 bug > 沒有解

不要因為追求完美而交白卷。
如果剩下 10 分鐘還沒有優化解，立刻寫暴力解。

暴力解寫完後：
  "Here's a working O(n^2) solution.
   If I had more time, I would optimize it by [explain the idea]
   to get O(n log n) / O(n)."

面試官會因為你：
  1. 有 working code ✓
  2. 知道如何優化 ✓
  3. 展現了思維深度 ✓
給你一個不錯的評分。
```

---

## 第六章：面試官的評分維度

了解面試官怎麼評分，才能有目的地展現自己。

### 6.1 Problem Solving（問題解決能力）

```
Poor（不及格）:
  - 讀完題就直接寫 code，沒有分析
  - 被卡住後完全沒有方向，等面試官給答案
  - 選了錯誤的算法但堅持到底

Average（及格）:
  - 能想出暴力解
  - 需要 1-2 個提示才能到達最佳解
  - 最終能到達正確算法

Excellent（優秀）:
  - 系統性分析：識別 input/output/constraint → 定位算法
  - 自己推導出暴力解 → 觀察 → 最佳解的完整過程
  - 能解釋 WHY 這個算法正確，不只是 WHAT
```

### 6.2 Coding Ability（編碼能力）

```
Poor:
  - 語法錯誤頻繁
  - 變數命名 a, b, c, x, y
  - Code 結構混亂，難以閱讀
  - 邊界條件全部錯誤

Average:
  - Code 基本正確，有 1-2 個 bug 但能自己找到
  - 變數命名還可以
  - 結構合理

Excellent:
  - Clean code: 有意義的命名、適當的函數抽取
  - 一次寫對（或幾乎寫對）
  - 主動處理 edge cases
  - 使用語言的 idiomatic features（如 Python 的 enumerate, defaultdict）
```

### 6.3 Communication（溝通能力）

```
Poor:
  - 沈默 15 分鐘然後說 "I got it"
  - 無法解釋自己的思路
  - 對面試官的提問反應遲鈍

Average:
  - 能解釋算法，但不夠流暢
  - 偶爾停頓思考（正常）
  - 能回答面試官的追問

Excellent:
  - 清楚地 walk through 整個思考過程
  - 主動提出 trade-offs: "We could use approach A for O(n) time
    but O(n) space, or approach B for O(n log n) time but O(1) space"
  - 邊寫 code 邊解釋每一段在做什麼
  - 預判面試官的問題："You might wonder why I chose HashMap here —
    it's because we need O(1) lookup for the complement"
```

### 6.4 Testing（測試能力）

```
Poor:
  - 寫完就說 "done"，不檢查
  - 面試官問 edge case 時一臉茫然

Average:
  - 用一個 normal case 走過一遍
  - 能在提示後想到 edge cases

Excellent:
  - 主動用 normal case 做 dry run
  - 自己提出 edge cases 並驗證:
    * 空 input
    * 單元素
    * 全部相同元素
    * 最大/最小值
    * 有重複 / 無重複
  - 分析時間/空間複雜度並解釋
```

### 6.5 Optimization（優化能力）

```
Poor:
  - 只會暴力解，不知道怎麼優化
  - 無法分析自己的時間/空間複雜度

Average:
  - 知道暴力解的複雜度
  - 能在提示後優化

Excellent:
  - 自主從暴力解推導出最佳解
  - 能分析 trade-offs: 時間 vs 空間
  - 知道多種解法並比較優劣:
    "Approach A: O(n) time, O(n) space — uses HashMap.
     Approach B: O(n log n) time, O(1) space — sorts first.
     Since the problem has n up to 10^5, both work.
     I'll go with A since it's faster."
  - 提出 follow-up 的想法:
    "If memory is a concern, we could switch to approach B."
```

### 6.6 評分公式（非官方但準確的模型）

```
Google 面試的 4 個評級：
  Strong Hire > Hire > No Hire > Strong No Hire

各維度加權（近似）：
  Problem Solving: 35%
  Coding:          25%
  Communication:   20%
  Testing:         10%
  Optimization:    10%

要拿 Hire:
  - Problem Solving ≥ Average（最好 Excellent）
  - Coding ≥ Average
  - Communication ≥ Average
  - 其他不能 Poor

要拿 Strong Hire:
  - Problem Solving = Excellent
  - Coding ≥ Average (最好 Excellent)
  - Communication = Excellent
  - Testing + Optimization ≥ Average
```

---

## 第七章：20 個實戰思考過程演練

以下 20 題，我會模擬一個 **Google-level 候選人的完整思考過程**。
不是教你算法（前面的教材已經教了），而是教你**怎麼想到**要用那個算法。

---

### 演練 1: Two Sum (Easy)

**題目**：Given an array of integers `nums` and an integer `target`, return indices of the two numbers that add up to `target`.

```
Step 1 (資料結構): Input = array of ints, Output = two indices
Step 2 (問題類型): 找(Find) → 找一對數的組合
Step 3 (約束):     n ≤ 10^4, 保證有唯一解
Step 4 (連結算法):
  - 暴力: O(n^2) 雙迴圈 → 可以但太慢
  - 觀察: 對每個 num，需要查 (target - num) 是否存在 → lookup 問題
  - O(1) lookup → HashMap
  - 一邊遍歷一邊存 → 一次遍歷 O(n)
Decision: HashMap, O(n) time, O(n) space ✓
```

---

### 演練 2: Valid Parentheses (Easy)

**題目**：Given a string containing just `()[]{}`, determine if the input string is valid.

```
Step 1: Input = string (括號), Output = boolean
Step 2: 驗(Validate) → 驗證結構合法性
Step 3: s.length ≤ 10^4, 只有 6 種字元
Step 4:
  - 信號: 括號/嵌套 → Stack!
  - 遇到左括號: push
  - 遇到右括號: pop 並檢查是否匹配
  - 結束時 stack 應該為空
Decision: Stack, O(n) time, O(n) space ✓
```

---

### 演練 3: Best Time to Buy and Sell Stock (Easy)

**題目**：Given an array `prices`, find the maximum profit from one transaction.

```
Step 1: Input = array of prices, Output = max profit (single value)
Step 2: 最(Optimize) → 最大化利潤
Step 3: n ≤ 10^5 → 需要 O(n) 或 O(n log n)
Step 4:
  - 暴力: O(n^2) 檢查每一對 → 太慢
  - 觀察: 賣出價 - 買入價 最大化，且賣出在買入之後
  - 一次遍歷: 記住到目前為止最低價 min_price
  - 每天計算 prices[i] - min_price，更新 max_profit
Decision: Greedy/one pass, O(n) time, O(1) space ✓
```

---

### 演練 4: Maximum Subarray (Medium)

**題目**：Find the contiguous subarray with the largest sum.

```
Step 1: Input = array, Output = max sum (single value)
Step 2: 最(Optimize) → 最大子陣列和
Step 3: n ≤ 10^5, 有負數 → Sliding Window 不適用（因為負數）
Step 4:
  - 暴力: O(n^2) 枚舉所有 subarray → 太慢
  - 觀察: 如果前面的和 < 0，不如從自己重新開始
  - Kadane's: current_sum = max(nums[i], current_sum + nums[i])
Decision: Kadane's Algorithm (DP variant), O(n) time, O(1) space ✓
```

---

### 演練 5: Merge Intervals (Medium)

**題目**：Given a collection of intervals, merge all overlapping intervals.

```
Step 1: Input = array of intervals, Output = merged intervals
Step 2: 建(Build) → 合併建構新的區間集
Step 3: n ≤ 10^4, intervals 可能無序
Step 4:
  - 信號: intervals → Sort by start + sweep
  - 排序後，如果 current.end >= next.start → 合併
  - 否則 current 結束，next 成為新的 current
Decision: Sort + linear scan, O(n log n) time, O(n) space ✓
```

---

### 演練 6: Longest Substring Without Repeating Characters (Medium)

**題目**：Find the length of the longest substring without repeating characters.

```
Step 1: Input = string, Output = length (single value)
Step 2: 最(Optimize) → 最長的合法子串
Step 3: s.length ≤ 5 × 10^4 → O(n) or O(n log n)
Step 4:
  - 信號: string + substring + constraint → Sliding Window!
  - 用 HashSet 追蹤視窗內的字元
  - 右指標擴張，遇到重複時左指標收縮
Decision: Sliding Window + HashSet, O(n) time, O(min(n, charset)) space ✓
```

---

### 演練 7: Number of Islands (Medium)

**題目**：Given a 2D grid of '1's (land) and '0's (water), count the number of islands.

```
Step 1: Input = 2D grid, Output = count (single value)
Step 2: 數(Count) → 數連通區域的數量
Step 3: m,n ≤ 300 → O(m×n) 可以
Step 4:
  - 信號: grid of 0/1 → BFS/DFS island problem!
  - 遍歷 grid，遇到 '1' → island count++，DFS/BFS 把整個島標記為 visited
Decision: DFS or BFS, O(m×n) time, O(m×n) space (recursion/queue) ✓
```

---

### 演練 8: Binary Tree Level Order Traversal (Medium)

**題目**：Return the level order traversal of a binary tree.

```
Step 1: Input = tree root, Output = list of lists (each level)
Step 2: 列(Enumerate) → 按層列出所有節點
Step 3: node 數 ≤ 2000
Step 4:
  - 信號: tree + level-by-level → BFS with queue!
  - 每層處理 queue 中所有節點，子節點入 queue
Decision: BFS with queue, O(n) time, O(n) space ✓
```

---

### 演練 9: Course Schedule (Medium)

**題目**：Given prerequisites, determine if you can finish all courses.

```
Step 1: Input = graph (courses = nodes, prereqs = edges), Output = boolean
Step 2: 驗(Validate) → 驗證是否存在合法順序
Step 3: numCourses ≤ 2000, prerequisites ≤ 5000
Step 4:
  - 信號: dependencies/prerequisites → Topological Sort!
  - 如果 graph 有環 → 不可能完成所有課程
  - Kahn's Algorithm: 不斷移除入度為 0 的節點
  - 如果最後移除了所有節點 → 沒有環 → return true
Decision: Topological Sort (Kahn's BFS), O(V+E) time ✓
```

---

### 演練 10: Coin Change (Medium)

**題目**：Given coins of different denominations, find fewest coins to make up amount.

```
Step 1: Input = array of coin values + target amount, Output = min count
Step 2: 最(Optimize) → 最少硬幣數
Step 3: amount ≤ 10^4, coins ≤ 12 種
Step 4:
  - 信號: "minimum" + "ways to make up" → DP!
  - 為什麼不是 Greedy? 反例: coins=[1,3,4], amount=6, greedy=4+1+1=3枚,
    但最佳是 3+3=2 枚
  - dp[i] = 湊出金額 i 的最少硬幣數
  - dp[i] = min(dp[i - coin] + 1) for coin in coins
Decision: 1D DP, O(amount × len(coins)) time, O(amount) space ✓
```

---

### 演練 11: Word Search (Medium)

**題目**：Given a board and a word, find if the word exists in the grid by adjacent cells.

```
Step 1: Input = 2D grid of chars + target word, Output = boolean
Step 2: 找(Find) → 找路徑是否存在
Step 3: board ≤ 6×6, word ≤ 15
Step 4:
  - 信號: grid + path + backtrack → Backtracking!
  - 小規模 (6×6) → 暴力 DFS 可以
  - 從每個格子開始 DFS，匹配 word 的每個字元
  - 走過的格子標記避免重複使用，回溯時恢復
Decision: Backtracking (DFS on grid), O(m×n×4^L) time ✓
```

---

### 演練 12: Kth Largest Element in an Array (Medium)

**題目**：Find the kth largest element in an unsorted array.

```
Step 1: Input = unsorted array + k, Output = single value
Step 2: 找(Find) → 找第 k 大的元素
Step 3: n ≤ 10^5, 1 ≤ k ≤ n
Step 4:
  - 信號: "kth largest" → Heap or QuickSelect!
  - 方法 A: Sort → O(n log n)，取 nums[n-k]
  - 方法 B: Min-Heap of size k → O(n log k)
  - 方法 C: QuickSelect → O(n) average
  - 面試中推薦 B（穩定且好寫）或 C（展現深度）
Decision: Min-Heap of size k, O(n log k) time ✓
```

---

### 演練 13: LRU Cache (Medium)

**題目**：Design a data structure that supports `get` and `put` in O(1).

```
Step 1: Input = operations (get/put), Output = design a class
Step 2: 建(Build) → 設計資料結構
Step 3: O(1) for both get and put
Step 4:
  - O(1) get → 需要 HashMap
  - O(1) 知道 LRU 順序 + O(1) 移動 → 需要 Doubly Linked List
  - 單獨用任何一個都不夠，所以兩個結合！
  - HashMap: key → node pointer
  - Doubly Linked List: 維護使用順序 (head = most recent, tail = LRU)
Decision: HashMap + Doubly Linked List, O(1) time ✓
```

---

### 演練 14: Longest Increasing Subsequence (Medium)

**題目**：Find the length of the longest strictly increasing subsequence.

```
Step 1: Input = array of ints, Output = length (single value)
Step 2: 最(Optimize) → 最長遞增子序列
Step 3: n ≤ 2500
Step 4:
  - 信號: "subsequence" (not contiguous) → DP!
  - n ≤ 2500 → O(n^2) 可以
  - dp[i] = 以 nums[i] 結尾的 LIS 長度
  - dp[i] = max(dp[j] + 1) for j < i where nums[j] < nums[i]
  - 進階: O(n log n) 用 patience sorting + Binary Search
Decision: DP O(n^2), or Binary Search O(n log n) ✓
```

---

### 演練 15: Serialize and Deserialize Binary Tree (Hard)

**題目**：Design an algorithm to serialize and deserialize a binary tree.

```
Step 1: Input = tree, Output = string (serialize) / tree (deserialize)
Step 2: 建(Build) → 建立編碼/解碼機制
Step 3: node ≤ 10^4
Step 4:
  - 樹的遍歷可以唯一確定結構嗎？
  - Preorder + 記錄 null 節點 → 可以！
  - Serialize: preorder traversal, null 記為 "#"
  - Deserialize: 按 preorder 順序重建，遇 "#" 返回 null
Decision: Preorder DFS + null markers, O(n) time ✓
```

---

### 演練 16: Trapping Rain Water (Hard)

**題目**：Given elevation map, compute how much water it can trap.

```
Step 1: Input = array of heights, Output = total water (single value)
Step 2: 數(Count) → 計算總水量
Step 3: n ≤ 2 × 10^4
Step 4:
  - 畫圖後觀察: 每個位置的水量 = min(leftMax, rightMax) - height[i]
  - 方法 A: 預計算 leftMax[] 和 rightMax[] → O(n) time, O(n) space
  - 方法 B: Two Pointers 從兩端往中間 → O(n) time, O(1) space
  - 為什麼 Two Pointers 可行？因為水量由「較矮的那一邊」決定
Decision: Two Pointers, O(n) time, O(1) space ✓
```

---

### 演練 17: Word Ladder (Hard)

**題目**：Find the shortest transformation sequence from beginWord to endWord, changing one letter at a time.

```
Step 1: Input = beginWord, endWord, wordList, Output = min steps
Step 2: 最(Optimize) → 最短轉換步數 = 最短路徑
Step 3: wordList ≤ 5000, word.length ≤ 10
Step 4:
  - 信號: "shortest" + "step by step transformation" → BFS!
  - 每個 word 是一個 node
  - 兩個 word 相差一個字母 → 有 edge
  - BFS 找最短路徑
  - 優化建邊: 對每個 word，嘗試改每個位置的 26 個字母
Decision: BFS, O(M^2 × N) time (M=word length, N=wordList size) ✓
```

---

### 演練 18: Median of Two Sorted Arrays (Hard)

**題目**：Find the median of two sorted arrays in O(log(m+n)).

```
Step 1: Input = two sorted arrays, Output = median (single value)
Step 2: 找(Find) → 找中位數
Step 3: 明確要求 O(log(m+n)), arrays are sorted
Step 4:
  - 信號: sorted + O(log n) → Binary Search!
  - 但不是在 array 上搜值，而是搜「分割位置」
  - 在較短的 array 上 Binary Search 分割點
  - 確保左半邊所有元素 ≤ 右半邊所有元素
  - 分割點正確時，median = 左半邊最大值與右半邊最小值的組合
Decision: Binary Search on partition, O(log(min(m,n))) time ✓
```

---

### 演練 19: Alien Dictionary (Hard)

**題目**：Given a sorted list of words in alien language, find the order of characters.

```
Step 1: Input = sorted list of strings, Output = character order (string)
Step 2: 排(Sort) → 推導出排序規則
Step 3: words ≤ 100, word.length ≤ 100
Step 4:
  - 信號: ordering/dependencies → Topological Sort!
  - 相鄰兩個 word 比較 → 找到第一個不同的字元 → 建立 edge (前 < 後)
  - 收集所有 edges → 建 directed graph
  - Topological Sort → 得到字母順序
  - 如果有環 → 不合法，return ""
Decision: Build graph + Topological Sort, O(C) time (C = total chars) ✓
```

---

### 演練 20: Minimum Window Substring (Hard)

**題目**：Given strings `s` and `t`, find the minimum window in `s` that contains all characters of `t`.

```
Step 1: Input = string s + string t, Output = shortest substring
Step 2: 最(Optimize) → 最小視窗
Step 3: s.length ≤ 10^5, t.length ≤ 10^5
Step 4:
  - 信號: string + substring + minimum → Sliding Window!
  - 用 HashMap 記錄 t 中每個字元的需求量
  - 右指標擴張直到視窗包含 t 的所有字元
  - 然後左指標收縮以求最小視窗
  - 用 counter 追蹤「還需要幾個字元」避免每次比較整個 map
Decision: Sliding Window + HashMap, O(|s| + |t|) time ✓
```

---

## 總結：你的解題作業系統

```
┌──────────────────────────────────────────────────────────────────┐
│                     你的大腦作業系統 v2.0                          │
│                                                                   │
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │ Layer 1: 2-Minute Triage                                    │  │
│  │   Input → Problem Type → Constraints → Algorithm Family     │  │
│  └─────────────────────────────────────────────────────────────┘  │
│                            ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │ Layer 2: 逆推法 (Reverse Engineering from Constraints)      │  │
│  │   n 的大小 → 複雜度上限 → 排除不可能的算法                     │  │
│  └─────────────────────────────────────────────────────────────┘  │
│                            ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │ Layer 3: 條件反射 (Pattern Matching Muscle Memory)          │  │
│  │   Input Signal × Output Signal × Constraint Signal = 算法   │  │
│  └─────────────────────────────────────────────────────────────┘  │
│                            ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │ Layer 4: 溝通框架 (Communication Template)                  │  │
│  │   Clarify → Approach (brute→optimal) → Code → Test          │  │
│  └─────────────────────────────────────────────────────────────┘  │
│                            ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │ Layer 5: 急救系統 (Emergency Recovery)                      │  │
│  │   10 strategies when stuck                                  │  │
│  └─────────────────────────────────────────────────────────────┘  │
│                                                                   │
│  載入這個作業系統 → 任何題目都有系統性的思考路徑                      │
│  不再「亂猜」，而是「定位」                                        │
└──────────────────────────────────────────────────────────────────┘
```

**記住**：面試不是考你背了多少算法，而是考你**能不能在陌生問題前，系統性地找到正確的方向**。

這份指南教你的不是答案，而是**找到答案的方法**。
