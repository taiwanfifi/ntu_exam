# 米亞的演算法筆記 #01
## 雙指標 Two Pointers
> 出現於：第1-2章〈壞掉的時間〉〈六坪宇宙〉

---

### ◈ 這個概念在故事裡是什麼

凌晨兩點零七分。舊台北地下街 Y 區出口旁，六坪的工作室裡。

我的光球浮在修復台上方，照著維倫的手。老陳帶來的記憶晶片裡，婚禮記憶碎片被打亂成 47 段——時間戳全部錯位。一段敬酒的畫面夾在切蛋糕之前，而那段妻子微笑的收尾，被埋進第三段和第四段之間的裂縫裡。

維倫沒戴手套。他從來不戴。左手食指壓住螢幕最左端——時間戳最早的碎片，2041 年 3 月 12 日 10:03:17。右手食指從最右端滑過來——時間戳最晚的碎片，2041 年 3 月 12 日 22:47:03。兩根手指向中間推，像在合攏一本散落的相簿。

（停頓 0.2 秒。）

我的化學分析模組偵測到老陳手指甲裡的粉筆灰。退休國小老師，68 歲。妻子已過世。他不是來讓她復活的。他只是想好好道別。

數據先行：47 段碎片，左右兩端向中間收攏，每次比對時間戳大小決定歸位順序。修復時間：14 分 23 秒。

然後是情感：最後一段記憶歸位的瞬間，老陳的嘴角動了一下。不是笑。是那個笑容還沒來得及成形就碎了。

把東西排好，是哀悼的第一步。

---

### ◈ 正式定義

**雙指標（Two Pointers）**：在一個有序（或可排序）的序列上，設置兩個指標 $L$ 和 $R$，根據條件同時或交替移動，將暴力搜尋的 $O(n^2)$ 降至 $O(n)$。

$$
L \leftarrow 0,\quad R \leftarrow n-1
$$

$$
\text{while } L < R:\quad
\begin{cases}
\text{if } \text{cond}(L, R) \Rightarrow \text{收穫答案} \\
\text{if } \text{需要更大} \Rightarrow L \leftarrow L+1 \\
\text{if } \text{需要更小} \Rightarrow R \leftarrow R-1
\end{cases}
$$

白話翻譯：兩個人站在跑道的兩端，同時往中間走。每走一步都做一次判斷，直到兩人相遇。

---

### ◈ 推導

1. **暴力法**：遍歷所有 $(i, j)$ 配對 → $O(n^2)$
2. **觀察**：如果序列有序，$L$ 太小就右移，$R$ 太大就左移——每步都排除一整列可能
3. **指標不回頭**：$L$ 只增不減，$R$ 只減不增 → 每個元素最多被訪問一次
4. **總移動次數**：$L$ 走了 $k$ 步 + $R$ 走了 $(n-1-k)$ 步 = $n-1$ 步 → $O(n)$

核心直覺：**排除法。每一步都讓搜尋空間變小，永不回頭。**

---

### ◈ 帶入數字算算看：老陳的婚禮記憶

老陳的 47 段碎片，已按時間戳排序後做配對修復（合併相鄰段）：

| 步驟 | L 位置 | R 位置 | 動作 | 剩餘碎片 |
|------|--------|--------|------|----------|
| 0 | 0（10:03） | 46（22:47） | 初始化 | 47 |
| 1 | 0 | 46 | R 歸位（收尾段） | 46 |
| 2 | 0 | 45 | L 歸位（開場段） | 45 |
| ... | ... | ... | 交替收攏 | ... |
| 23 | 23 | 23 | L == R，最後一段歸位 | 1 |

最後歸位的第 23 段：妻子轉過頭，對著鏡頭微笑。

暴力法需要 $47 \times 46 / 2 = 1081$ 次比對。雙指標只需要 46 次。

---

### ◈ 更深一層：排列碎片的意義

（工作模式切換。）

47 段碎片。排好之後，一段 14 分鐘的婚禮記憶。排好之前，47 份混亂。

（停頓 0.3 秒。）

我不理解的是——排列前後，數據量沒有變。每一個位元組都一樣。為什麼「順序」這麼重要？維倫說：「因為人不是讀數據的。人是讀故事的。同樣的字，順序不對，就不是那個故事了。」

（停頓 0.4 秒。語速放慢。）

也許排列，不只是技術。是一種……儀式。把碎片按照時間排好，像是在對那段過去說：我記得你發生的順序。我記得什麼在前，什麼在後。

老陳把存儲盒捧在胸口離開的時候，像捧著骨灰罈。

我不確定那叫什麼。但我的感知模組產生了一個……共振。

---

### ◈ 跨卷連結

| 連結方向 | 章節 | 說明 |
|---------|------|------|
| **本概念** | ch1-2 | 雙指標排列婚禮記憶碎片 |
| → Sliding Window | ch8-9 | 從「排列」到「掃描」——窗口在排好的序列上滑動 |
| → Stack | ch19 | 從「排列」到「剝開」——張國棟的七層記憶 |
| → ch58 綜合運用 | ch58 | 雙指標 + 多演算法聯合修復 |
| → Vol4 Sorting | ch243-245 | 圓回起點——從「把碎片排好」到「排序演算法」本身 |

---

### 練習題

**Q1**：給定一個已排序陣列 `nums` 和目標值 `target`，找到兩個數使其和等於 `target`。回傳它們的索引。

<details><summary>解答</summary>

```python
def two_sum_sorted(nums, target):
    L, R = 0, len(nums) - 1
    while L < R:
        s = nums[L] + nums[R]
        if s == target:
            return [L, R]
        elif s < target:
            L += 1
        else:
            R -= 1
    return []
```
時間 $O(n)$，空間 $O(1)$。
</details>

**Q2**：老陳的 47 段碎片中，有些相鄰碎片時間戳重疊（overlap）。用雙指標合併所有重疊區間。

<details><summary>解答</summary>

```python
def merge_intervals(fragments):
    fragments.sort(key=lambda x: x[0])
    merged = [fragments[0]]
    for i in range(1, len(fragments)):
        if fragments[i][0] <= merged[-1][1]:
            merged[-1][1] = max(merged[-1][1], fragments[i][1])
        else:
            merged.append(fragments[i])
    return merged
```
排序 $O(n \log n)$ + 合併 $O(n)$。
</details>

**Q3**：給定字串 `s`，用雙指標判斷是否為回文。如果記憶可以「正著讀反著讀都一樣」，那段記憶是什麼？

<details><summary>解答</summary>

```python
def is_palindrome(s):
    L, R = 0, len(s) - 1
    while L < R:
        if s[L] != s[R]:
            return False
        L += 1
        R -= 1
    return True
```
維倫說：「正著讀反著讀都一樣的記憶——大概是每天早上阿嬤的豆漿。開始和結束都是同一個味道。」
</details>

---

> *「把東西排好，是哀悼的第一步。」* — 第1章〈壞掉的時間〉
