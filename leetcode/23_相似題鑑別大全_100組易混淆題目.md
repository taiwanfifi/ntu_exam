# 相似題鑑別大全：85+ 組易混淆 LeetCode 題目

> **定位**：你已經懂算法，但每次都選錯 -- 這份指南解決「看起來一樣，但要用不同解法」的痛點
> **核心產出**：每組一句話鑑別法，讓你 3 秒內判斷出正確算法
> **語言**：繁體中文 + English 技術術語
> **前置要求**：已讀完 01-17 各算法教學，本文不解釋算法原理，只講鑑別

---

## 目錄

| 類別 | 組數 | 頁內連結 |
|------|------|---------|
| A. 搜尋配對類 | 10 組 | [Part A](#part-a搜尋配對類) |
| B. 子陣列/子字串類 | 10 組 | [Part B](#part-b子陣列子字串類) |
| C. Tree 類 | 10 組 | [Part C](#part-ctree-類) |
| D. Graph 類 | 10 組 | [Part D](#part-dgraph-類) |
| E. DP 類 | 15 組 | [Part E](#part-edp-類) |
| F. Stack/Queue 類 | 5 組 | [Part F](#part-fstackqueue-類) |
| G. Backtracking 類 | 5 組 | [Part G](#part-gbacktracking-類) |
| H. Greedy vs DP 類 | 10 組 | [Part H](#part-hgreedy-vs-dp-類) |
| I. 混合/進階類 | 10 組 | [Part I](#part-i混合進階類) |
| **合計** | **85 組** | |

---

# Part A：搜尋配對類

---

### 鑑別組 1：Two Sum (unsorted) vs Two Sum II (sorted)

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 1 | Two Sum (unsorted array) | 雙指針掃描 | **HashMap** O(n) | 未排序，無法用排除邏輯 |
| LC 167 | Two Sum II (sorted array) | HashMap | **Two Pointers** O(n) | 已排序，對向夾擊即可 |

> 一句話鑑別法：**看到 sorted 就雙指針，unsorted 就 HashMap。**

---

### 鑑別組 2：Two Sum vs 3Sum vs 4Sum

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 1 | Two Sum | 雙指針 | HashMap (unsorted) | 2 個變數，O(n) |
| LC 15 | 3Sum | 三重迴圈 | 排序 + 固定 1 個 + 雙指針 | 降維：3→固定1+2指針 |
| LC 18 | 4Sum | 四重迴圈 | 排序 + 固定 2 個 + 雙指針 | 降維：4→固定2+2指針 |

> 一句話鑑別法：**KSum 的通用解法是「固定 K-2 個，最內層用雙指針」，先排序。**

---

### 鑑別組 3：Contains Duplicate I vs II vs III

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 217 | Contains Duplicate | 排序找相鄰 | **HashSet** | 整個陣列有無重複 |
| LC 219 | Contains Dup II (index diff <= k) | HashSet | **Sliding Window HashSet** (size k) | 有索引距離限制 |
| LC 220 | Contains Dup III (value diff <= t, index diff <= k) | 同上 | **Sorted Set / Bucket Sort** | 同時有值和索引兩個限制 |

> 一句話鑑別法：**無限制用 Set；限制索引用 Sliding Window Set；限制索引+值用 Bucket/TreeSet。**

---

### 鑑別組 4：Find Duplicate Number vs Missing Number

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 287 | Find the Duplicate Number | 排序/HashSet | **Floyd Cycle Detection** (O(1) space) | 不能改陣列，值域=索引→鏈表有環 |
| LC 268 | Missing Number | Floyd Cycle | **XOR / 數學加總** | 缺一個數，用 XOR 消去配對 |

> 一句話鑑別法：**「多了一個重複」用 Floyd Cycle；「少了一個」用 XOR 或 sum 公式。**

---

### 鑑別組 5：Search Sorted Array vs Rotated vs Rotated+Duplicates

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 704 | Binary Search (sorted) | -- | 標準 Binary Search | 完全有序，直接比較 |
| LC 33 | Search in Rotated Sorted Array | 同上 | Binary Search + 判斷哪半邊有序 | 有一個旋轉點，但無重複 |
| LC 81 | Search in Rotated + Duplicates | 同上 | 同上 + 遇到 `nums[lo]==nums[mid]` 時 lo++ | 重複值導致無法判斷哪邊有序 |

> 一句話鑑別法：**無旋轉→標準二分；有旋轉→先判斷哪半有序；有旋轉+重複→多一步 lo++ 跳過。**

---

### 鑑別組 6：Search 2D Matrix vs Search 2D Matrix II

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 74 | Search 2D Matrix | 逐行搜尋 | **攤平成 1D Binary Search** | 每行首 > 上行尾 → 全局有序 |
| LC 240 | Search 2D Matrix II | 同上 | **從右上角走樓梯** O(m+n) | 只保證行內+列內各自有序 |

> 一句話鑑別法：**「下一行接上一行」→攤平二分；「行列各自排序」→右上角出發。**

---

### 鑑別組 7：First Bad Version vs Search Insert Position

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 278 | First Bad Version | Binary Search | Binary Search (找左邊界) | 結果是第一個 True 的位置 |
| LC 35 | Search Insert Position | Binary Search | Binary Search (找插入點) | 結果是第一個 >= target 的位置 |

> 一句話鑑別法：**本質都是「找左邊界」，但 First Bad 的 check 是 boolean API，Insert 是值比較 -- 模板一樣。**

---

### 鑑別組 8：Kth Largest (unsorted) vs Kth Smallest in BST

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 215 | Kth Largest Element in Array | 排序 | **Min-Heap (size k)** 或 QuickSelect | 無序陣列，用 Heap/Partition |
| LC 230 | Kth Smallest Element in BST | Heap | **Inorder Traversal** 數到第 k 個 | BST 本身就是有序結構 |

> 一句話鑑別法：**無序資料找第 K 大用 Heap/QuickSelect；BST 找第 K 小用 Inorder（天然排序）。**

---

### 鑑別組 9：Find Peak Element vs Find Minimum in Rotated

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 162 | Find Peak Element | Binary Search | Binary Search：往較大鄰居走 | 保證存在 peak（兩端為 -inf） |
| LC 153 | Find Min in Rotated Sorted | Binary Search | Binary Search：比較 mid vs right | 最小值在「斷崖」那邊 |

> 一句話鑑別法：**Find Peak 比較鄰居方向「往上爬」；Find Min 比較 mid 和 right「往斷崖走」。**

---

### 鑑別組 10：Intersection vs Union of Two Arrays

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 349 | Intersection (unique) | 排序+雙指針 | **HashSet** 交集 | 結果要去重 |
| LC 350 | Intersection II (allow dup) | HashSet | **HashMap** 計數取 min | 結果保留重複次數 |
| -- | Union (unique) | HashMap | **HashSet** 聯集 | 兩個 set 合併 |

> 一句話鑑別法：**交集去重用 Set；交集保留重複用 Map 計數；聯集用 Set.union。**

---

# Part B：子陣列/子字串類

---

### 鑑別組 11：Maximum Subarray vs Maximum Product Subarray

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 53 | Maximum Subarray (sum) | DP 二維 | **Kadane's Algorithm** (追蹤 curMax) | 加法：負數拖累，直接重開 |
| LC 152 | Maximum Product Subarray | 同 Kadane | **追蹤 curMax 和 curMin** | 乘法：負負得正，需同時記 min |

> 一句話鑑別法：**加法只追蹤 max；乘法必須同時追蹤 max 和 min（負負得正翻轉）。**

---

### 鑑別組 12：Subarray Sum = K vs Minimum Size Subarray Sum >= K

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 560 | Subarray Sum Equals K | Sliding Window | **Prefix Sum + HashMap** | 有負數！視窗不能縮 |
| LC 209 | Min Size Subarray Sum >= target | Prefix Sum | **Sliding Window** (expand/shrink) | 全正數！視窗可以安全縮 |

> 一句話鑑別法：**有負數不能 Sliding Window（因為縮視窗不一定減少 sum）→用 Prefix Sum HashMap。**

---

### 鑑別組 13：Longest Substring Without Repeating vs At Most K Distinct

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 3 | Longest Substring Without Repeating | 暴力枚舉 | **Sliding Window + HashSet** | 視窗內不允許任何重複 |
| LC 340 | Longest Substr with At Most K Distinct | 同上 | **Sliding Window + HashMap (size<=k)** | 視窗內最多 k 種不同字元 |

> 一句話鑑別法：**「無重複」= 每個字元最多出現 1 次 (Set)；「K distinct」= 最多 K 種字元 (Map.size <= K)。**

---

### 鑑別組 14：Minimum Window Substring vs Find All Anagrams

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 76 | Minimum Window Substring | 固定視窗 | **可變長度 Sliding Window** | 視窗大小不固定，找最小包含 |
| LC 438 | Find All Anagrams in a String | 可變視窗 | **固定長度 Sliding Window** (len = p.length) | 視窗大小 = pattern 長度，滑動即可 |

> 一句話鑑別法：**「包含所有字元」→ 可變視窗找最小；「是 anagram」→ 固定視窗（長度 = pattern）。**

---

### 鑑別組 15：Subarray Sum = K vs Continuous Subarray Sum (multiple of K)

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 560 | Subarray Sum Equals K | 同餘 | **Prefix Sum HashMap** 存 `{prefix: count}` | 找 prefix[j] - prefix[i] == K |
| LC 523 | Continuous Subarray Sum (nK) | Prefix Sum | **Prefix Sum mod K + HashMap** | 找 prefix[j] % K == prefix[i] % K |

> 一句話鑑別法：**精確等於 K → HashMap 存 prefix sum；整除 K → HashMap 存 prefix sum % K。**

---

### 鑑別組 16：Maximum Sum of Size K vs Maximum Average of Size K

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| -- | Max Sum Subarray of Size K | -- | **Fixed Sliding Window** (維護 sum) | 直接比較 sum |
| LC 643 | Maximum Average Subarray I | 同上 | **Fixed Sliding Window** (sum/k) | 最後除以 k，完全同結構 |

> 一句話鑑別法：**完全相同的 Sliding Window 模板，Average 只是最後多除一個 K。**

---

### 鑑別組 17：Longest Palindromic Substring vs Subsequence

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 5 | Longest Palindromic **Substring** | DP 二維 | **Expand Around Center** O(n^2) 或 DP | 必須連續 → 從每個中心擴展 |
| LC 516 | Longest Palindromic **Subsequence** | 同上 | **2D DP** `dp[i][j]` on subproblem | 可以不連續 → 經典區間 DP |

> 一句話鑑別法：**Substring（連續）用中心擴展；Subsequence（不連續）用 2D 區間 DP。**

---

### 鑑別組 18：Longest Common Substring vs Subsequence

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| -- | Longest Common **Substring** | 2D DP | **2D DP**：不匹配時 `dp[i][j]=0` | 連續 → 斷了就歸零 |
| LC 1143 | Longest Common **Subsequence** | 同上 | **2D DP**：不匹配時 `max(dp[i-1][j], dp[i][j-1])` | 不連續 → 保留前面的最優 |

> 一句話鑑別法：**Substring 不匹配歸零重來；Subsequence 不匹配取左/上的 max 繼承。**

---

### 鑑別組 19：Word Break vs Word Break II

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 139 | Word Break (can break?) | Backtracking | **1D DP** `dp[i] = can reach i?` | 只要判斷 boolean |
| LC 140 | Word Break II (all ways) | 同 DP | **Backtracking + Memoization** | 要列出所有組合 → 必須回溯 |

> 一句話鑑別法：**「能不能」用 DP boolean；「列出所有」用 Backtracking（DP 只存 true/false 不夠）。**

---

### 鑑別組 20：Decode Ways vs Climbing Stairs

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 70 | Climbing Stairs | DP | **DP: dp[i] = dp[i-1] + dp[i-2]** | 每步選 1 或 2，無條件限制 |
| LC 91 | Decode Ways | 同上 | **同結構 DP + 條件判斷** | 1-26 合法才能選 2 位，'0' 開頭非法 |

> 一句話鑑別法：**結構相同（fibonacci 變體），但 Decode Ways 多了「合法性判斷」（0 開頭非法、超過 26 不行）。**

---

# Part C：Tree 類

---

### 鑑別組 21：Max Depth vs Min Depth

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 104 | Maximum Depth | DFS | `max(left, right) + 1` | 取大的，直覺正確 |
| LC 111 | Minimum Depth | 同上 | `min(left, right) + 1` **但要排除空子樹** | 單邊為空時不能算 0！要走另一邊 |

> 一句話鑑別法：**Max Depth 無腦取 max；Min Depth 必須判斷「如果一邊是 null，走另一邊」避免算到非葉節點。**

---

### 鑑別組 22：Path Sum vs Path Sum II vs Binary Tree Maximum Path Sum

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 112 | Path Sum (exists?) | DFS 列舉 | **DFS root-to-leaf**，到葉子判斷 | 只要 boolean |
| LC 113 | Path Sum II (all paths) | 同上 | **DFS + Backtracking** 收集路徑 | 要所有路徑 → 回溯記錄 |
| LC 124 | Max Path Sum (any path) | root-to-leaf | **DFS 後序**，每個節點回傳單邊最大 | 路徑可彎折（不限 root-to-leaf） |

> 一句話鑑別法：**root-to-leaf 判斷用 DFS；列舉用 Backtracking；任意路徑最大用後序 + 全域變數追蹤彎折值。**

---

### 鑑別組 23：Diameter of Binary Tree vs Maximum Path Sum

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 543 | Diameter of Binary Tree | 同 Max Path Sum | **DFS 後序**，每節點回傳最大深度 | 計算「邊數」= left_depth + right_depth |
| LC 124 | Binary Tree Max Path Sum | 同 Diameter | **DFS 後序**，每節點回傳最大 gain | 計算「節點值總和」，且負數 gain 要捨棄 |

> 一句話鑑別法：**同模板！Diameter 算邊數（永遠 >= 0）；Max Path Sum 算值（負值要丟棄設 0）。**

---

### 鑑別組 24：Validate BST vs Balanced Binary Tree

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 98 | Validate BST | DFS 檢查 | **DFS 帶上下界 (low, high)** | 驗證值的大小關係 |
| LC 110 | Balanced Binary Tree | DFS 檢查 | **DFS 回傳高度**，檢查左右差 <= 1 | 驗證結構的高度平衡 |

> 一句話鑑別法：**BST 驗證「值域範圍」帶 bound；Balanced 驗證「高度差」回傳 height。**

---

### 鑑別組 25：LCA (Binary Tree) vs LCA (BST)

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 236 | LCA of Binary Tree | BST 做法 | **DFS 後序**：左右都找到 → 當前是 LCA | 一般樹 O(n) |
| LC 235 | LCA of BST | 同上 | **利用 BST 性質**：兩個都小走左，都大走右 | BST O(log n)，不用遍歷全樹 |

> 一句話鑑別法：**一般 Tree 用 DFS 左右找；BST 利用大小關係直接走，O(log n) 搞定。**

---

### 鑑別組 26：Level Order vs Zigzag vs Right Side View

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 102 | Level Order Traversal | BFS | **BFS** 逐層收集 | 每層全部加入結果 |
| LC 103 | Zigzag Level Order | BFS | **BFS + 奇數層 reverse** | 偶數層正序，奇數層反序 |
| LC 199 | Binary Tree Right Side View | BFS 全層 | **BFS 每層只取最後一個** | 每層只要最右邊的節點 |

> 一句話鑑別法：**同 BFS 模板：Level Order 全收；Zigzag 交替反轉；Right View 只取每層最後。**

---

### 鑑別組 27：Invert Binary Tree vs Symmetric Tree

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 226 | Invert Binary Tree | 對稱檢查 | **DFS 前序/後序**，每個節點交換左右 | 修改結構（swap children） |
| LC 101 | Symmetric Tree | 反轉 | **DFS 比較 (left.left, right.right) 和 (left.right, right.left)** | 驗證結構（不修改） |

> 一句話鑑別法：**Invert 是「做事」(swap)；Symmetric 是「驗證」(compare mirror positions)。**

---

### 鑑別組 28：Flatten Binary Tree vs Serialize/Deserialize

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 114 | Flatten BT to Linked List | 序列化 | **DFS + 原地改指標** (right = preorder next) | 單向壓平，不可逆 |
| LC 297 | Serialize and Deserialize BT | 壓平 | **Preorder + null 標記 → 字串 → 重建** | 可逆！必須保留結構資訊 |

> 一句話鑑別法：**Flatten 不可逆（丟失結構）；Serialize 可逆（用 null 標記保留結構）。**

---

### 鑑別組 29：Construct from Preorder+Inorder vs Preorder+Postorder

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 105 | Build from Preorder + Inorder | 遞迴建樹 | **Preorder[0] 是 root，Inorder 切左右** | Inorder 可精確定位左右子樹邊界 |
| LC 889 | Build from Preorder + Postorder | 同上 | **Preorder[1] 是左子樹 root，Postorder 找分割點** | 無 Inorder 時解不唯一 |

> 一句話鑑別法：**有 Inorder 可唯一確定；沒有 Inorder（Pre+Post）解可能不唯一。**

---

### 鑑別組 30：BST Iterator vs Kth Smallest in BST

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 173 | BST Iterator | 完整 Inorder | **Controlled Inorder (Stack)** | 按需取下一個，不一次跑完 |
| LC 230 | Kth Smallest in BST | 同上 | **Inorder DFS 數到第 k 個停** | 只要第 k 個，不需要 iterator 介面 |

> 一句話鑑別法：**Iterator 需要「暫停/繼續」→ 用 Stack 控制流程；Kth 只跑一次到 k 停。**

---

# Part D：Graph 類

---

### 鑑別組 31：Number of Islands -- DFS vs BFS vs Union-Find

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 200 | Number of Islands | -- | **DFS Flood Fill** (最直覺) | 遇到 '1' 就 DFS 標記整個島 |
| LC 200 | 同題 BFS 解法 | DFS | **BFS Flood Fill** | 效果相同，用 queue 代替 recursion |
| LC 200 | 同題 Union-Find | DFS/BFS | **Union-Find** | 適合動態加入（LC 305 變體） |

> 一句話鑑別法：**靜態 grid 用 DFS/BFS 都行；動態加入島嶼（305 變體）才需要 Union-Find。**

---

### 鑑別組 32：Course Schedule vs Course Schedule II

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 207 | Course Schedule (can finish?) | TopSort | **TopSort (Kahn's BFS) 看能否排完** | 只要 boolean：processed == numCourses? |
| LC 210 | Course Schedule II (find order) | 同上 | **TopSort 記錄順序** | 要回傳實際排序結果 |

> 一句話鑑別法：**I 只判斷有無環（count == n?）；II 要輸出完整拓撲排序（記錄 order）。**

---

### 鑑別組 33：Clone Graph vs Copy List with Random Pointer

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 133 | Clone Graph | DFS 複製 | **DFS + HashMap {old: new}** | 圖結構，需防重複訪問 |
| LC 138 | Copy List with Random Pointer | 同上 | **HashMap {old: new}** 或 interleave trick | 鏈表結構，random 指向任意節點 |

> 一句話鑑別法：**同核心思想（HashMap 映射 old→new），Graph 用 DFS 驅動，List 可線性遍歷。**

---

### 鑑別組 34：Surrounded Regions vs Pacific Atlantic Water Flow

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 130 | Surrounded Regions | 內部 DFS | **從邊界 DFS 向內標記「安全」** | 反向思維：邊界連通的不被包圍 |
| LC 417 | Pacific Atlantic Water Flow | 同上 | **從兩個邊界各自 DFS，取交集** | 兩組邊界各自可達，找交集 |

> 一句話鑑別法：**都是「從邊界往內走」的反向 DFS；Surrounded 標記安全區；Pacific Atlantic 找兩組邊界交集。**

---

### 鑑別組 35：Network Delay Time vs Cheapest Flights within K Stops

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 743 | Network Delay Time | BFS | **Dijkstra** (weighted, no negative) | 無限制的單源最短路 |
| LC 787 | Cheapest Flights K Stops | Dijkstra | **Bellman-Ford (K iterations)** 或 Modified BFS | 有步數限制 K → Dijkstra 不適用 |

> 一句話鑑別法：**無步數限制用 Dijkstra；有步數限制 K 用 Bellman-Ford 跑 K+1 輪。**

---

### 鑑別組 36：Connected Components vs Redundant Connection

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 323 | Number of Connected Components | Union-Find | **DFS/BFS 或 Union-Find** 數連通分量 | 計算有幾個獨立群組 |
| LC 684 | Redundant Connection | DFS | **Union-Find**：加邊時發現已連通 → 就是多餘邊 | 找多餘的那條邊 |

> 一句話鑑別法：**數連通分量用 DFS/UF 都行；找多餘邊首選 Union-Find（加邊時偵測環）。**

---

### 鑑別組 37：Word Ladder vs Word Ladder II

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 127 | Word Ladder (shortest length) | DFS 窮舉 | **BFS** 找最短路 | 只要最短距離 |
| LC 126 | Word Ladder II (all shortest) | 同 BFS | **BFS 記層數 + DFS/Backtrack 找所有路徑** | 要所有最短路徑 → BFS + 回溯 |

> 一句話鑑別法：**最短距離用 BFS；所有最短路徑用 BFS（建圖）+ DFS（回溯枚舉）。**

---

### 鑑別組 38：Topological Sort -- Kahn's BFS vs DFS

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| -- | TopSort (Kahn's) | DFS 後序 | **BFS + indegree[]** | 自然產生拓撲序列，易偵測環 |
| -- | TopSort (DFS) | BFS | **DFS + 後序加入 stack** | 適合已有 DFS 框架的場景 |

> 一句話鑑別法：**需要拓撲序列/偵測環 → Kahn's BFS（直覺）；嵌入現有 DFS 框架 → DFS 後序反轉。**

---

### 鑑別組 39：Bipartite Graph vs Graph Coloring (K colors)

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 785 | Is Graph Bipartite? | 圖著色 | **BFS/DFS 交替染 2 色** | 2-coloring → polynomial O(V+E) |
| -- | Graph Coloring (K colors) | 同上 | **Backtracking** (NP-Complete for K>=3) | K>=3 → NP-Complete，無多項式解 |

> 一句話鑑別法：**2 色 (Bipartite) 用 BFS 線性解；K>=3 色是 NP-Complete 用回溯。**

---

### 鑑別組 40：Minimum Spanning Tree vs Shortest Path

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 1584 | Min Cost to Connect All Points (MST) | 最短路 | **Kruskal / Prim** | 連接所有點，總權重最小 |
| LC 743 | Network Delay Time (Shortest Path) | MST | **Dijkstra** | 單源到所有點的最短路 |

> 一句話鑑別法：**「連接所有人」用 MST（Kruskal/Prim）；「從 A 到 B 最短」用 Dijkstra/Bellman-Ford。**

---

# Part E：DP 類

---

### 鑑別組 41：Climbing Stairs vs House Robber

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 70 | Climbing Stairs | House Robber | `dp[i] = dp[i-1] + dp[i-2]` | 計數：有幾種方式 |
| LC 198 | House Robber | Climbing Stairs | `dp[i] = max(dp[i-1], dp[i-2] + nums[i])` | 最大化：選或不選取 max |

> 一句話鑑別法：**同樣依賴 i-1、i-2，但 Climbing Stairs 是「加法計數」，House Robber 是「max 取最大收益」。**

---

### 鑑別組 42：House Robber vs House Robber II (Circular)

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 198 | House Robber (linear) | 環形 | **標準 DP** `dp[i] = max(skip, rob)` | 首尾不相連 |
| LC 213 | House Robber II (circular) | 同上 | **跑兩次 DP**：[0..n-2] 和 [1..n-1] 取 max | 首尾相連 → 拆成兩個線性問題 |

> 一句話鑑別法：**環形 = 「包含第一間不含最後」和「不含第一間包含最後」取 max。**

---

### 鑑別組 43：Coin Change (min coins) vs Coin Change 2 (count ways)

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 322 | Coin Change (minimum coins) | 計數 | **DP min**：`dp[i] = min(dp[i], dp[i-c] + 1)` | 求最少硬幣數 |
| LC 518 | Coin Change 2 (count combinations) | 最小化 | **DP sum**：`dp[i] += dp[i-c]` | 求組合數 |

> 一句話鑑別法：**同樣是完全背包：「最少幾個」用 min；「有幾種組合」用 +=。**

---

### 鑑別組 44：0/1 Knapsack vs Unbounded Knapsack

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| -- | 0/1 Knapsack | 完全背包 | 1D DP，**容量從大到小遍歷** | 每物品只能用一次 |
| -- | Unbounded Knapsack | 0/1 背包 | 1D DP，**容量從小到大遍歷** | 每物品可重複用 |

> 一句話鑑別法：**迴圈方向決定一切：0/1 背包內層倒序（防重複使用）；完全背包內層正序（允許重複）。**

---

### 鑑別組 45：LIS vs LCS vs Edit Distance

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 300 | Longest Increasing Subsequence | 2D DP | **1D DP** `dp[i] = max(dp[j]+1)` 或 Binary Search O(nlogn) | 單序列，遞增 |
| LC 1143 | Longest Common Subsequence | 1D DP | **2D DP** `dp[i][j]` 兩序列比較 | 雙序列，匹配 |
| LC 72 | Edit Distance | LCS | **2D DP** `dp[i][j]` + 三種操作 | 雙序列，增刪改 |

> 一句話鑑別法：**單序列用 1D；雙序列匹配用 2D；雙序列+操作用 2D+三路轉移。**

---

### 鑑別組 46：Unique Paths vs Minimum Path Sum

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 62 | Unique Paths | 最小化 | **2D DP 計數**：`dp[i][j] = dp[i-1][j] + dp[i][j-1]` | 計數有幾條路 |
| LC 64 | Minimum Path Sum | 計數 | **2D DP 最值**：`dp[i][j] = grid[i][j] + min(up, left)` | 求最小花費 |

> 一句話鑑別法：**同 grid 結構：計數用加法；最優用 min + 格子權重。**

---

### 鑑別組 47：Jump Game vs Jump Game II

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 55 | Jump Game (can reach end?) | Greedy 計數 | **Greedy**：追蹤 maxReach | boolean 判斷 |
| LC 45 | Jump Game II (min jumps) | 同上 | **BFS-like Greedy**：每「層」更新 farthest | 計算最少跳幾次 |

> 一句話鑑別法：**「能不能到」只追蹤 maxReach；「最少幾步」用 BFS 分層思維計數。**

---

### 鑑別組 48：Best Time to Buy Stock I vs II vs Cooldown vs Fee

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 121 | Stock I (one transaction) | DP | **追蹤 minPrice**，每天更新 maxProfit | 只能買賣一次 |
| LC 122 | Stock II (unlimited) | 同上 | **Greedy**：所有上漲段都吃 | 無限次，但不能同時持有 |
| LC 309 | Stock with Cooldown | Greedy | **State Machine DP** (hold/sold/rest) | 賣出後冷卻一天 |
| LC 714 | Stock with Fee | Greedy | **State Machine DP** (hold/cash) - fee | 每次交易扣手續費 |

> 一句話鑑別法：**一次買賣用 minPrice；無限次用 Greedy；有額外限制（冷卻/手續費）用狀態機 DP。**

---

### 鑑別組 49：Palindrome Partitioning vs Palindrome Partitioning II

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 131 | Palindrome Partitioning (all ways) | DP | **Backtracking** + 預處理 isPalin[][] | 列出所有分割方式 |
| LC 132 | Palindrome Partitioning II (min cuts) | Backtracking | **DP** `dp[i] = min cuts for s[0..i]` | 只要最少切幾刀 |

> 一句話鑑別法：**列出所有 → Backtracking；最少幾刀 → DP。**

---

### 鑑別組 50：Word Break vs Coin Change -- 同構問題

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 139 | Word Break | 字串專屬 | **DP**：`dp[i] = any(dp[j] and s[j:i] in dict)` | 字典中的單字 = 硬幣面額 |
| LC 322 | Coin Change | 數學專屬 | **DP**：`dp[i] = min(dp[i-c] + 1)` | amount = 字串長度 |

> 一句話鑑別法：**同為完全背包變形：Word Break 問「能不能湊齊」(boolean)；Coin Change 問「最少幾個」(min)。**

---

### 鑑別組 51：Target Sum vs Partition Equal Subset Sum

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 494 | Target Sum | Backtracking | **轉換為 0/1 背包**：找子集 sum = (total+target)/2 | +/- 指派 → 子集和問題 |
| LC 416 | Partition Equal Subset Sum | 同上 | **0/1 背包**：`dp[j] = dp[j] or dp[j-num]` | 找子集 sum = total/2 |

> 一句話鑑別法：**本質都是「子集和」0/1 背包：Partition 目標 = total/2；Target Sum 目標 = (total+target)/2。**

---

### 鑑別組 52：Maximum Subarray vs Best Time to Buy Stock I

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 53 | Maximum Subarray | 和股票無關 | **Kadane's**：`cur = max(num, cur + num)` | 直接在原陣列上做 |
| LC 121 | Best Time to Buy Stock I | 和子陣列無關 | **等價於 diff 陣列的 Kadane's** | prices 的 diff array 就是 Kadane 問題 |

> 一句話鑑別法：**Stock I 的 profit = price 差分陣列的 Maximum Subarray -- 本質是同一題！**

---

### 鑑別組 53：Decode Ways vs Fibonacci

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| -- | Fibonacci | Decode Ways | `dp[i] = dp[i-1] + dp[i-2]` | 永遠可以選 1 步或 2 步 |
| LC 91 | Decode Ways | Fibonacci | 同結構 + **條件分支** | 1-9 才能單獨解碼，10-26 才能兩位解碼 |

> 一句話鑑別法：**Fibonacci 無條件跳；Decode Ways 有「合法性 if-else」（0 開頭、>26 都不行）。**

---

### 鑑別組 54：Longest Palindromic Substring -- DP vs Expand Around Center

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 5 | DP 解法 | 唯一解法 | **2D DP** `dp[i][j] = (s[i]==s[j]) and dp[i+1][j-1]` | O(n^2) time + O(n^2) space |
| LC 5 | Expand Around Center | DP | **每個位置向兩邊擴展** | O(n^2) time + O(1) space |

> 一句話鑑別法：**兩種方法同題：DP 用 O(n^2) 空間但好擴展；Expand 只用 O(1) 空間更實用。**

---

### 鑑別組 55：Regular Expression vs Wildcard Matching

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 10 | Regular Expression Matching | Wildcard | **2D DP**，`*` 修飾前一個字元（0 or more of prev） | `*` = 前一個字元的 0 到多次 |
| LC 44 | Wildcard Matching | RegExp | **2D DP**，`*` 獨立匹配任意序列 | `*` = 任意字串（自身獨立） |

> 一句話鑑別法：**RegExp 的 `*` 是「前一個字元重複 0+次」；Wildcard 的 `*` 是「匹配任意字串」-- 轉移式不同！**

---

# Part F：Stack/Queue 類

---

### 鑑別組 56：Valid Parentheses vs Longest Valid Parentheses

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 20 | Valid Parentheses | 計數長度 | **Stack 配對**：遇 `)` 彈出檢查 | 只判斷整體是否合法 |
| LC 32 | Longest Valid Parentheses | 同上 | **Stack 存 index** 或 DP | 找最長合法子串的長度 |

> 一句話鑑別法：**Valid 用 Stack 配對 boolean；Longest Valid 用 Stack 存 index 算距離（或 DP）。**

---

### 鑑別組 57：Daily Temperatures vs Next Greater Element

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 739 | Daily Temperatures | Next Greater | **Monotonic Stack (decreasing)**：回傳天數差 | 結果是「等幾天」(index diff) |
| LC 496 | Next Greater Element I | Daily Temp | **Monotonic Stack + HashMap** | 結果是「下個更大的值」(value) |

> 一句話鑑別法：**同 Monotonic Stack 模板：Daily Temp 回傳 index 距離；Next Greater 回傳 value。**

---

### 鑑別組 58：Largest Rectangle in Histogram vs Maximal Rectangle

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 84 | Largest Rectangle in Histogram | 暴力 | **Monotonic Stack** 找每根柱子的左右邊界 | 1D 問題 |
| LC 85 | Maximal Rectangle (2D matrix) | 同上 | **逐行轉成 Histogram → 調用 LC 84** | 2D 拆成多個 1D |

> 一句話鑑別法：**1D Histogram 直接用 Monotonic Stack；2D Matrix 逐行累加高度後轉成 1D Histogram 解。**

---

### 鑑別組 59：Min Stack vs Max Stack

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 155 | Min Stack | Max Stack | **主 Stack + 輔助 Stack 追蹤 min** | 每次 push 時更新 min |
| LC 716 | Max Stack (with popMax) | 同上 | **Two Stacks + Lazy Delete** 或 TreeMap+DLL | popMax 需要中間刪除 → 更複雜 |

> 一句話鑑別法：**Min Stack 只需 O(1) getMin（輔助棧）；Max Stack 還要 popMax（中間刪除）→ 需 TreeMap/DLL。**

---

### 鑑別組 60：Basic Calculator vs Basic Calculator II

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 224 | Basic Calculator (`+`, `-`, `()`) | 只算數 | **Stack 處理括號遞迴** | 有括號 → Stack 存外層狀態 |
| LC 227 | Basic Calculator II (`+`,`-`,`*`,`/`) | 有括號 | **Stack 處理優先級** | 無括號但有乘除 → 遇乘除立即算 |

> 一句話鑑別法：**有括號 → Stack 存「括號外的狀態」；無括號有乘除 → Stack 遇乘除立即彈出計算。**

---

# Part G：Backtracking 類

---

### 鑑別組 61：Subsets vs Combinations

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 78 | Subsets | Combinations | **Backtracking**：每個元素選或不選 | 所有大小的子集 (2^n 個) |
| LC 77 | Combinations (C(n,k)) | Subsets | **Backtracking + 剪枝** `len(path)==k` 就收集 | 只要恰好 k 個元素的子集 |

> 一句話鑑別法：**Subsets 收集所有；Combinations 只收集 size == k 的。**

---

### 鑑別組 62：Subsets vs Subsets II (with duplicates)

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 78 | Subsets (unique elements) | Subsets II | **標準 Backtracking** | 元素不重複，直接選 |
| LC 90 | Subsets II (has duplicates) | 同上 | **排序 + 同層去重** `if i>start and nums[i]==nums[i-1]: skip` | 排序後跳過同層重複 |

> 一句話鑑別法：**有重複元素就「先排序，同層相鄰相同則跳過」。**

---

### 鑑別組 63：Permutations vs Permutations II

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 46 | Permutations (unique) | Perm II | **Backtracking + used[] 標記** | 每個元素用一次 |
| LC 47 | Permutations II (duplicates) | 同上 | **排序 + used[] + 去重條件** | `if i>0 and nums[i]==nums[i-1] and not used[i-1]: skip` |

> 一句話鑑別法：**有重複 = 排序 + 多一個去重條件：「前一個相同且沒被用 → 跳過」。**

---

### 鑑別組 64：Combination Sum vs Combination Sum II

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 39 | Combination Sum (reuse allowed) | Comb Sum II | **Backtracking，下一層從 i 開始**（可重複取） | 同元素可重複使用 |
| LC 40 | Combination Sum II (no reuse) | 同上 | **Backtracking，下一層從 i+1 + 排序去重** | 每元素只用一次 + 去重 |

> 一句話鑑別法：**可重複 → 遞迴 start=i；不可重複 → 遞迴 start=i+1 + 排序去重。**

---

### 鑑別組 65：N-Queens vs Sudoku Solver

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 51 | N-Queens | Sudoku | **Backtracking 逐行放置**，3 個 Set 追蹤 col/diag | 每行放一個，約束：列+兩對角線 |
| LC 37 | Sudoku Solver | N-Queens | **Backtracking 逐格填入**，row/col/box 三重約束 | 每格填 1-9，約束：行+列+3x3 宮 |

> 一句話鑑別法：**N-Queens 約束 = 列+對角線；Sudoku 約束 = 行+列+宮，維度更多但結構類似。**

---

# Part H：Greedy vs DP 類

---

### 鑑別組 66：Jump Game (Greedy) vs Jump Game II (BFS-like Greedy)

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 55 | Jump Game | DP | **Greedy**：只追蹤 maxReach | 問「能不能到」 |
| LC 45 | Jump Game II | 同 Greedy | **BFS-like Greedy**：分層擴展 | 問「最少幾步」→ 需要層的概念 |

> 一句話鑑別法：**能不能到 = 一個 maxReach 變數；最少幾步 = BFS 分層計數。**

---

### 鑑別組 67：Coin Change (DP) vs Greedy Coin Change

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 322 | Coin Change (arbitrary denominations) | Greedy 先取大的 | **DP** (完全背包) | 任意面額 → Greedy 不保證最優 |
| -- | Coin Change (standard: 1,5,10,25) | DP | **Greedy** 從大到小取 | 特殊面額系統 → Greedy 恰好正確 |

> 一句話鑑別法：**面額系統有「貪心性質」(canonical) → Greedy 可行；任意面額 → 必須 DP。**

---

### 鑑別組 68：Activity Selection vs Weighted Job Scheduling

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| -- | Activity Selection (unweighted) | DP | **Greedy**：按結束時間排序，能選就選 | 所有活動等權重 |
| LC 1235 | Weighted Job Scheduling | Greedy | **DP + Binary Search** | 活動有不同權重 → Greedy 失敗 |

> 一句話鑑別法：**等權重用 Greedy（按結束排序）；有權重用 DP（需考慮跳過高權重的代價）。**

---

### 鑑別組 69：Merge Intervals vs Interval Scheduling

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 56 | Merge Intervals | 選最多 | **Sort by start + 合併重疊** | 目標是合併，輸出合併後的區間 |
| LC 435 | Non-overlapping Intervals | 合併 | **Sort by end + Greedy 計數衝突** | 目標是刪最少使不重疊 |

> 一句話鑑別法：**Merge 按 start 排序合併；Scheduling 按 end 排序貪心選不衝突的。**

---

### 鑑別組 70：Task Scheduler vs Course Schedule

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 621 | Task Scheduler | TopSort | **Greedy + Math** (最多的任務決定框架) | 冷卻時間約束，無依賴關係 |
| LC 207 | Course Schedule | Greedy | **Topological Sort** (DAG) | 先修課約束 = 依賴關係 |

> 一句話鑑別法：**Task Scheduler 是「冷卻間隔」→ Greedy/Math；Course Schedule 是「依賴順序」→ TopSort。**

---

### 鑑別組 71：Gas Station vs Candy

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 134 | Gas Station | 多次掃描 | **Greedy**：一次掃描追蹤 tank，歸零就重設起點 | 環形路線，找唯一起點 |
| LC 135 | Candy | 類似 | **Greedy Two-Pass**：左到右 + 右到左 | 線性，兩邊鄰居約束 |

> 一句話鑑別法：**Gas Station 單次掃描找起點；Candy 兩次掃描（左右各一次）滿足雙向約束。**

---

### 鑑別組 72：Stock II (Greedy) vs Stock with Cooldown (DP)

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 122 | Best Time Stock II | DP | **Greedy**：吃所有上漲段 | 無限制交易，無額外成本 |
| LC 309 | Stock with Cooldown | Greedy | **State Machine DP** (3 states) | 賣完要冷卻一天 → Greedy 失敗 |

> 一句話鑑別法：**無約束 → Greedy 吃所有漲幅；有冷卻/手續費 → 必須 State Machine DP。**

---

### 鑑別組 73：Assign Cookies vs Partition Equal Subset Sum

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 455 | Assign Cookies | DP 背包 | **Greedy Sort + 雙指針** | 每個餅乾給一個孩子，最小滿足 |
| LC 416 | Partition Equal Subset Sum | Greedy | **0/1 Knapsack DP** | 子集和問題，Greedy 無法解 |

> 一句話鑑別法：**一對一配對用 Greedy 排序；子集合計問題必須 DP（Greedy 無法窮舉子集）。**

---

### 鑑別組 74：Remove K Digits vs Remove Duplicate Letters

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 402 | Remove K Digits (smallest number) | 暴力枚舉 | **Greedy Monotonic Stack**：遇到比棧頂小的就彈出 | 移除 k 個，剩下最小 |
| LC 316 | Remove Duplicate Letters (smallest) | 同上 | **Greedy Stack + 剩餘計數 + visited** | 每個字母恰好留一個 |

> 一句話鑑別法：**Remove K Digits 只限制「刪幾個」；Remove Dup Letters 多了「每字母恰留一個」的約束。**

---

### 鑑別組 75：Partition Labels vs Palindrome Partitioning

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 763 | Partition Labels | Backtracking | **Greedy**：記錄每個字母最後出現位置 | 每字母只在一個 partition 中 |
| LC 131 | Palindrome Partitioning | Greedy | **Backtracking + isPalindrome 預處理** | 列出所有迴文分割方式 |

> 一句話鑑別法：**Partition Labels 用 Greedy（最後出現位置決定切割點）；Palindrome Partitioning 用 Backtracking（枚舉所有迴文切法）。**

---

# Part I：混合/進階類

---

### 鑑別組 76：Median from Stream vs Sliding Window Median

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 295 | Find Median from Data Stream | Sliding Window | **Two Heaps** (maxHeap + minHeap) | 只加不刪，兩堆維護即可 |
| LC 480 | Sliding Window Median | 同上 | **Two Heaps + Lazy Deletion** (或 SortedList) | 視窗滑動 → 需要刪除離開的元素 |

> 一句話鑑別法：**Stream 只 add → 標準 Two Heaps；Sliding Window 需 delete → Two Heaps + Lazy Delete。**

---

### 鑑別組 77：LRU Cache vs LFU Cache

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 146 | LRU Cache | LFU | **HashMap + Doubly Linked List** | 淘汰最久沒用的 (Least Recently Used) |
| LC 460 | LFU Cache | LRU | **HashMap + freq→DLL mapping** | 淘汰使用次數最少的 (Least Frequently Used) |

> 一句話鑑別法：**LRU 按「時間」淘汰（一條 DLL）；LFU 按「頻率」淘汰（多條 DLL，每個頻率一條）。**

---

### 鑑別組 78：Merge K Sorted Lists vs Sort Nearly Sorted Array

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 23 | Merge K Sorted Lists | Sort | **Min Heap (size K)** + 逐個彈出 | K 條已排序鏈表合併 |
| -- | Sort K-Sorted Array (每元素偏移 <= K) | Merge K | **Min Heap (size K+1)** 滑動視窗 | 單一陣列，每元素離正確位最多 K |

> 一句話鑑別法：**K 條 List 合併 → Heap 存 K 個頭節點；K-sorted 單陣列 → Heap 存 K+1 個元素滑動。**

---

### 鑑別組 79：Trapping Rain Water vs Container With Most Water

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 42 | Trapping Rain Water | 雙指針 | **Two Pointers** (追蹤 leftMax/rightMax) 或 **Monotonic Stack** | 每格積水 = min(leftMax,rightMax) - height |
| LC 11 | Container With Most Water | 同上 | **Two Pointers**：矮的那邊往內移 | 面積 = min(h[l],h[r]) * (r-l)，只看兩條線 |

> 一句話鑑別法：**Trapping Rain 計算「每格頭頂上方」的水（逐格累加）；Container 計算「兩條線之間」的面積（一次算一對）。**

---

### 鑑別組 80：Word Search vs Word Search II

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 79 | Word Search (single word) | Trie | **DFS Backtracking** on grid | 只搜一個字 → 直接 DFS |
| LC 212 | Word Search II (multiple words) | 多次 DFS | **Trie + DFS** | 多個字 → 先建 Trie，一次 DFS 搜所有 |

> 一句話鑑別法：**一個字 → 直接 DFS；多個字 → 建 Trie 再 DFS（避免重複搜尋）。**

---

### 鑑別組 81：Rotate Array vs Rotate Image vs Rotate List

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 189 | Rotate Array | 同名混淆 | **三次 Reverse** (全翻→前k翻→後翻) | 1D 陣列右移 K 步 |
| LC 48 | Rotate Image (90 degrees) | 同上 | **Transpose + Reverse each row** | 2D 矩陣順時針 90 度 |
| LC 61 | Rotate List | 同上 | **找新頭 (len-k%len) 斷開重連** | 鏈表右移 K 步 |

> 一句話鑑別法：**Array 用三次反轉；Image 用轉置+行反轉；List 找新頭斷開接環。三個「Rotate」完全不同做法！**

---

### 鑑別組 82：Reverse Linked List vs Reverse Nodes in K-Group vs Swap Pairs

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 206 | Reverse Linked List | 複雜翻轉 | **Iterative**：prev/curr/next 三指針 | 翻轉整條鏈表 |
| LC 24 | Swap Nodes in Pairs | Reverse K | **兩兩交換** (K=2 的特例) | 每次只交換兩個 |
| LC 25 | Reverse Nodes in K-Group | Swap Pairs | **分段翻轉**：每 K 個一組，逐組翻轉 | K 個一組翻轉，不足 K 保持 |

> 一句話鑑別法：**全部翻轉 = 基礎三指針；K-Group = 分段調用基礎翻轉；Swap Pairs = K=2 特例。**

---

### 鑑別組 83：Meeting Rooms vs Meeting Rooms II

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 252 | Meeting Rooms (can attend all?) | Meeting II | **Sort by start + 檢查重疊** | boolean：有無衝突 |
| LC 253 | Meeting Rooms II (min rooms) | 同上 | **Sort + Min Heap** 追蹤結束時間 | 計算最多同時進行的會議數 |

> 一句話鑑別法：**能不能全參加 = 排序後檢查有無重疊；最少幾間房 = Min Heap 追蹤同時進行數。**

---

### 鑑別組 84：Merge Sorted Array vs Merge Two Sorted Lists

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 88 | Merge Sorted Array (in-place) | 鏈表合併 | **Three Pointers 從尾部填入** | Array 從後面填避免覆蓋 |
| LC 21 | Merge Two Sorted Lists | 陣列合併 | **Dummy head + 逐一比較接上** | 鏈表改指標即可，不需從尾 |

> 一句話鑑別法：**Array 從尾部填（避免覆蓋未處理的元素）；Linked List 從頭接（改指標無覆蓋問題）。**

---

### 鑑別組 85：Group Anagrams vs Valid Anagram vs Find All Anagrams

| # | 題目 | 看起來像 | 實際用 | 關鍵差異 |
|---|------|---------|--------|---------|
| LC 49 | Group Anagrams | 排序比較 | **HashMap: sorted(word) → list** | 分組：把同類放一起 |
| LC 242 | Valid Anagram | HashMap | **Counter 比較** 或排序比較 | 判斷兩字串是否互為 anagram |
| LC 438 | Find All Anagrams in String | 分組 | **Fixed Sliding Window + Counter** | 在字串中找所有 anagram 起始位 |

> 一句話鑑別法：**分組用 HashMap(sorted key)；判斷兩個用 Counter 比較；在長字串中找用 Sliding Window。**

---

# 總鑑別速查表

> 以下是所有 85 組的一句話鑑別法索引，面試前 10 分鐘快速掃一遍。

| 組 | 主題 | 一句話鑑別法 |
|---|------|-------------|
| 1 | Two Sum sorted/unsorted | sorted 雙指針，unsorted HashMap |
| 2 | KSum 系列 | 固定 K-2 個 + 雙指針 |
| 3 | Contains Dup I/II/III | 無限制 Set；限 index 用 Window Set；限 index+value 用 Bucket |
| 4 | Find Dup vs Missing | 多一個 → Floyd Cycle；少一個 → XOR/Sum |
| 5 | Sorted/Rotated/Dup | 無旋轉標準二分；有旋轉判斷哪半有序；有重複多 lo++ |
| 6 | 2D Matrix I vs II | 全局有序攤平二分；行列各自有序從右上走 |
| 7 | First Bad vs Insert | 都是找左邊界，模板相同 |
| 8 | Kth Largest vs BST Kth | 無序 Heap/QuickSelect；BST 用 Inorder |
| 9 | Peak vs Min Rotated | Peak 往大鄰居走；Min 往斷崖走 |
| 10 | Intersection vs Union | 交集去重 Set；交集留重複 Map；聯集 Set.union |
| 11 | Max Subarray vs Product | 加法追蹤 max；乘法同時追蹤 max 和 min |
| 12 | Subarray Sum=K vs Min Size | 有負數 Prefix+Map；全正數 Sliding Window |
| 13 | No Repeat vs K Distinct | Set (每字元 <=1 次) vs Map (種類 <=K) |
| 14 | Min Window vs Anagram | 可變視窗找最小 vs 固定視窗(len=pattern) |
| 15 | Sum=K vs Sum%K==0 | 存 prefix sum vs 存 prefix sum % K |
| 16 | Max Sum K vs Max Avg K | 完全相同，Average 最後除以 K |
| 17 | Palindrome Sub-string vs -sequence | 連續→中心擴展；不連續→區間 DP |
| 18 | Common Sub-string vs -sequence | 不匹配歸零 vs 取 max 繼承 |
| 19 | Word Break vs Word Break II | 判斷 boolean 用 DP；列出所有用 Backtrack |
| 20 | Decode Ways vs Climbing | 同結構，Decode 多了合法性判斷 |
| 21 | Max vs Min Depth | Max 無腦取 max；Min 要排除空子樹 |
| 22 | Path Sum I/II/Max | 判斷 DFS；列舉 Backtrack；任意路徑後序+全域變數 |
| 23 | Diameter vs Max Path Sum | 同模板，Diameter 算邊數，Max Path Sum 算值 |
| 24 | Validate BST vs Balanced | BST 帶 bound 驗值；Balanced 回傳 height 驗結構 |
| 25 | LCA Tree vs BST | 一般 DFS O(n)；BST 利用大小 O(log n) |
| 26 | Level/Zigzag/Right View | 同 BFS：全收/交替反轉/只取每層最後 |
| 27 | Invert vs Symmetric | Invert 做事 swap；Symmetric 驗證 compare |
| 28 | Flatten vs Serialize | Flatten 不可逆；Serialize 可逆(保留 null 標記) |
| 29 | Pre+In vs Pre+Post | 有 Inorder 唯一確定；無 Inorder 不唯一 |
| 30 | BST Iterator vs Kth | Iterator 用 Stack 暫停/繼續；Kth 跑到 k 停 |
| 31 | Islands DFS/BFS/UF | 靜態 DFS/BFS；動態加入用 Union-Find |
| 32 | Course I vs II | I 判斷有無環；II 輸出完整拓撲序 |
| 33 | Clone Graph vs Copy List | 同 HashMap 映射，Graph 用 DFS，List 線性 |
| 34 | Surrounded vs Pacific | 都從邊界內走：Surrounded 標記安全；Pacific 找交集 |
| 35 | Network Delay vs Cheapest K | 無步數限制 Dijkstra；有步數限制 Bellman-Ford |
| 36 | Components vs Redundant | 數連通分量 DFS/UF；找多餘邊首選 UF |
| 37 | Word Ladder I vs II | 最短距離 BFS；所有最短路 BFS+DFS 回溯 |
| 38 | TopSort Kahn vs DFS | Kahn 直覺產序列；DFS 嵌入現有框架 |
| 39 | Bipartite vs K-Color | 2 色 BFS 線性解；K>=3 色 NP-Complete |
| 40 | MST vs Shortest Path | 連接所有人 MST；A到B最短 Dijkstra |
| 41 | Stairs vs Robber | Stairs 加法計數；Robber max 取最大收益 |
| 42 | Robber I vs II | 線性直接 DP；環形拆兩次取 max |
| 43 | Coin Change vs Coin 2 | 最少幾個 min；幾種組合 += |
| 44 | 0/1 vs Unbounded | 內層倒序(用一次)；內層正序(重複用) |
| 45 | LIS vs LCS vs Edit | 單序列 1D；雙序列 2D；雙序列+操作 2D+三路 |
| 46 | Unique Path vs Min Path | 計數加法；最值 min+權重 |
| 47 | Jump I vs II | 能不能 maxReach；最少幾步 BFS 分層 |
| 48 | Stock I/II/Cool/Fee | 一次 minPrice；無限 Greedy；有限制 State DP |
| 49 | Palindrome Part I vs II | 列出所有 Backtrack；最少幾刀 DP |
| 50 | Word Break vs Coin Change | 同完全背包：能不能 boolean vs 最少幾個 min |
| 51 | Target Sum vs Partition | 都是子集和 0/1 背包，目標公式不同 |
| 52 | Max Subarray vs Stock I | Stock I = diff 陣列的 Kadane，本質同題 |
| 53 | Decode vs Fibonacci | 同結構，Decode 多合法性 if-else |
| 54 | Palindrome DP vs Expand | 同題兩解：DP O(n^2) 空間；Expand O(1) 空間 |
| 55 | RegExp vs Wildcard | RegExp `*`=前字元重複；Wildcard `*`=任意字串 |
| 56 | Valid Paren vs Longest | Valid 配對 boolean；Longest 存 index 算距離 |
| 57 | Daily Temp vs Next Greater | 同模板：回傳 index diff vs 回傳 value |
| 58 | Histogram vs Maximal Rect | 1D Stack；2D 逐行累加轉 1D |
| 59 | Min Stack vs Max Stack | Min 只需輔助棧；Max 需 popMax→TreeMap/DLL |
| 60 | Calculator I vs II | 有括號 Stack 存狀態；無括號有乘除立即算 |
| 61 | Subsets vs Combinations | 全收 vs 只收 size==k |
| 62 | Subsets vs Subsets II | 無重複直接選；有重複排序+同層跳過 |
| 63 | Perm vs Perm II | 多一個去重條件：前一個相同且未用→跳 |
| 64 | Comb Sum vs Comb Sum II | 可重複 start=i；不可重複 start=i+1+去重 |
| 65 | N-Queens vs Sudoku | 列+對角線 vs 行+列+宮 |
| 66 | Jump I vs II (Greedy) | maxReach 一變數 vs BFS 分層計數 |
| 67 | Coin DP vs Greedy | 任意面額 DP；標準面額 Greedy |
| 68 | Activity vs Weighted Job | 等權重 Greedy；有權重 DP+Binary Search |
| 69 | Merge vs Scheduling | Merge 按 start 合併；Scheduling 按 end 選 |
| 70 | Task Scheduler vs Course | 冷卻間隔 Greedy/Math；依賴順序 TopSort |
| 71 | Gas Station vs Candy | 單次掃描找起點 vs 兩次掃描雙向約束 |
| 72 | Stock II vs Cooldown | 無約束 Greedy；有冷卻 State DP |
| 73 | Cookies vs Partition | 配對 Greedy Sort；子集合計 DP 背包 |
| 74 | Remove K vs Remove Dup | Remove K 限刪幾個；Remove Dup 每字母恰留一個 |
| 75 | Partition Labels vs Palindrome | Labels Greedy 最後位置；Palindrome Backtrack |
| 76 | Stream Median vs Window | Stream 只 add Two Heaps；Window 需 Lazy Delete |
| 77 | LRU vs LFU | LRU 按時間一條 DLL；LFU 按頻率多條 DLL |
| 78 | Merge K vs K-Sorted | K 條合併 Heap 存頭；K-sorted Heap 存 K+1 滑動 |
| 79 | Trapping Rain vs Container | Rain 逐格累加；Container 一次算一對線 |
| 80 | Word Search vs II | 一個字 DFS；多個字 Trie+DFS |
| 81 | Rotate Array/Image/List | 三次反轉 / 轉置+行反轉 / 找新頭斷接 |
| 82 | Reverse List/K-Group/Pairs | 全翻三指針 / 分段翻轉 / K=2 特例 |
| 83 | Meeting Rooms I vs II | 有無衝突排序檢查；最少幾間 Heap 追蹤 |
| 84 | Merge Array vs List | Array 從尾填避免覆蓋；List 從頭接改指標 |
| 85 | Group/Valid/Find Anagram | 分組 HashMap；判斷 Counter；找位置 Sliding Window |

---

## 使用建議

1. **做題前**：先判斷這題「像哪一組」，用一句話鑑別法選算法
2. **做錯後**：找到對應組，讀 KEY DIFFERENTIATOR 理解為什麼選錯
3. **面試前 10 分鐘**：只掃「總鑑別速查表」，把 85 條一句話過一遍
4. **長期**：每次新遇到混淆題，自己補充新的鑑別組

> 核心思維：**不是你不會算法，是你選錯了算法。鑑別能力 = 面試通過率的隱藏加分項。**
