# 演算法偵探筆記（上）— 被打亂的伺服器

> *「在混亂中找到秩序，本身就是一種演算法。」—— 蘇雨晴*

---

## 登場人物

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  林凱（我）  資工系大三。平時靠直覺活著，偶爾靠邏輯。      │
│              擅長在 deadline 前三小時產生超人般的生產力。    │
│                                                             │
│  蘇雨晴      大四學姊。ICPC 亞洲區金牌。說話像寫程式，     │
│  （學姊）    零冗餘。據說曾用一行 Python 讓教授沉默十秒。   │
│                                                             │
│  張翔        我室友。信奉「迴圈能解決一切」的暴力美學家。   │
│  （阿翔）    debug 的方式是加 print，而且從不刪掉。         │
│                                                             │
│  吳教授      系上的資安課教授。半夜打電話叫學生來的那種人。 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 序章　凌晨三點的來電

凌晨三點十七分。

手機在枕頭底下震動的時候，我正夢見自己在期末考寫出了 O(1) 的排序演算法，
台下的教授們集體起立鼓掌，諾貝爾委員會打電話來說要破例頒獎給資工系——

然後我就被吵醒了。

螢幕亮得刺眼。來電顯示：**蘇雨晴學姊**。

蘇雨晴。大四。ICPC 亞洲區金牌。長得像可以去拍日劇但偏偏選了寫 code
這條不歸路的那種人。平常說話惜字如金到我有時候懷疑她是不是被 token 計費的。

我接起來。

「系計中被入侵了。吳教授要我們過去。」

就這樣。一句話。沒有前因後果，沒有「不好意思這麼晚打給你」，
什麼都沒有。學姊從來不浪費頻寬。

我嘆了口氣，伸手拍了拍上鋪。

「欸，阿翔。起來。」

上鋪傳來一聲含糊的呻吟：「嗯......什麼......」

「系上伺服器被入侵了，教授叫我們去看。」

沉默了三秒。然後阿翔猛地坐起來，腦袋直接撞上天花板。

「——靠！」他摀著頭，「是不是有人想把我們的成績刪掉！」

「......你的第一反應居然是這個。」

「你不懂，我這學期全靠加分過的。」

我已經在穿外套了。十一月的新竹，凌晨三點，風切過來的時候
你會真心覺得自己為什麼不讀中南部的大學。

---

## 第一幕　伺服器室

系館地下一樓。平常上課都不太想來的地方。

推開門的瞬間，吳教授那張「我已經三小時沒睡但我可以再撐三天」的臉
出現在螢幕的藍光裡。學姊已經到了，坐在主控台前面，
手指在鍵盤上的速度讓我想起我媽打麻將。

「來了？看這個。」

吳教授轉過一台螢幕。上面是系上的選課資料庫。

——或者說，曾經是選課資料庫的東西。

```
╔══════════════════════════════════════════════════════════════════╗
║  [TERMINAL]  ntu-csie-db01  |  STATUS: ██ ANOMALY DETECTED     ║
╠══════════════════════════════════════════════════════════════════╣
║                                                                  ║
║  ORIGINAL (backup from 23:00)          CURRENT (03:00)           ║
║  ┌────────┬──────┬────────┐   ┌────────┬──────┬────────┐       ║
║  │ ID     │ Name │ Course │   │ ID     │ Name │ Course │       ║
║  ├────────┼──────┼────────┤   ├────────┼──────┼────────┤       ║
║  │ 10001  │ 陳一 │ CS101  │   │ 50742  │ 李五 │ CS301  │       ║
║  │ 10002  │ 林二 │ CS101  │   │ 10001  │ 陳一 │ CS101  │       ║
║  │ 10003  │ 張三 │ CS102  │   │ 88234  │ 周八 │ CS201  │       ║
║  │ 10004  │ 李四 │ CS201  │   │ 10003  │ 張三 │ CS102  │       ║
║  │ ...    │ ...  │ ...    │   │ 10001  │ 陳一 │ CS101  │ ← !!  ║
║  │ (依學號排序)            │   │ 30917  │ 王六 │ CS102  │       ║
║  │                         │   │ ...    │ ...  │ ...    │       ║
║  │ 共 1,048,576 筆         │   │ (完全亂序 + 出現重複)  │       ║
║  └────────┴──────┴────────┘   └────────┴──────┴────────┘       ║
║                                                                  ║
║  ⚠ 資料筆數異常：原始 1,048,576 → 現存 1,051,203 (+2,627)     ║
║  ⚠ 排序狀態：原始 SORTED → 現存 UNSORTED                       ║
║  ⚠ 偵測到重複記錄                                               ║
╚══════════════════════════════════════════════════════════════════╝
```

「一百萬筆選課資料，」吳教授說，「全部被打亂了。順序不見了。
而且多出了將近三千筆重複的資料。」

阿翔瞪大眼睛：「一百萬筆？誰這麼無聊？」

「這就是我們要查的。」學姊頭也不回地說。

我盯著螢幕。腦袋還沒完全清醒，但有什麼東西在直覺的邊緣搔著我。

一百萬筆資料被打亂。多了近三千筆重複。原本是排好序的，現在完全亂了。

「我們需要弄清楚三件事，」學姊終於轉過來看我們，
螢幕的藍光在她臉上畫出銳利的輪廓。

「**第一**，入侵是什麼時候發生的。」
「**第二**，哪些資料被複製了。」
「**第三**，被打亂的方式有沒有規律。」

她頓了一下。

「回答了這三個問題，我們就能知道犯人是誰。」

阿翔舉手：「那我們開始一筆一筆看吧！」

學姊看了他一眼。就一眼。那個眼神的溫度大概跟新竹的風差不多。

「一百萬筆，」她說，「一筆一秒，不吃不喝不睡，要十一天半。」

「......」

「所以，」她轉回螢幕，「我們得聰明一點。」

---

## 第二幕　在時間的海裡撈一根針

### 2.1　一百萬行的日誌

第一個問題：入侵是什麼時候發生的？

吳教授調出了伺服器的系統日誌。二十四小時份量，每秒都有紀錄。

```
╔════════════════════════════════════════════════════════╗
║  [SERVER LOG]  ntu-csie-db01  |  Last 24 hours        ║
╠════════════════════════════════════════════════════════╣
║                                                        ║
║  Timestamp          Status        Checksum             ║
║  ─────────────────────────────────────────────         ║
║  2024-11-07 03:17   ??? ← 我們在這裡                  ║
║  2024-11-07 03:16   ???                                ║
║  ...                                                   ║
║  ...             （共 86,400 行，每秒一筆）            ║
║  ...                                                   ║
║  2024-11-06 03:18   ???                                ║
║  2024-11-06 03:17   ???                                ║
║                                                        ║
║  每行日誌包含一個 checksum（校驗碼）                   ║
║  正常 = OK    被竄改 = CORRUPTED                       ║
║                                                        ║
║  在某個時間點之前：全部 OK                             ║
║  在某個時間點之後：全部 CORRUPTED                      ║
║                                                        ║
║  問題：那個時間點在哪裡？                              ║
╚════════════════════════════════════════════════════════╝
```

八萬六千四百行日誌。在某一行之前全部正常，在那之後全部異常。
我們要找的就是那條分界線。

阿翔已經開始從第一行往下讀了。

「03:17......OK。03:16......OK。03:15......OK......」

我看著他，腦子裡默默算了一下。

> *如果從頭開始一行行讀，最慘的情況要讀完全部 86,400 行。*
> *就算入侵發生在正中間，也要讀 43,200 行。*
> *一定有更快的方法。*

「阿翔，先停一下。」

「嗯？」

「如果我們不從第一行開始，而是——直接看中間那行呢？」

阿翔眨眨眼：「看中間？為什麼？」

---

### 2.2　切一半的直覺

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 暫停推理                                                │
│                                                             │
│  八萬六千多行日誌，排成一條時間線。                         │
│  前面一段全部 OK，後面一段全部 CORRUPTED。                  │
│  分界點在某處。                                             │
│                                                             │
│  如果你是偵探，你會怎麼找？                                 │
│                                                             │
│  提示：你不需要讀每一行。你只需要問對問題。                 │
│                                                             │
│  想三十秒再往下看。                                         │
└─────────────────────────────────────────────────────────────┘
```

我走到白板前面，畫了一條線。

「想像日誌是一本書。前半本是白色的頁面，後半本是黑色的。
我們要找到白變黑的那一頁。」

我在線的中間點了一個點。

「我們翻開正中間的那頁。如果是白色的——」

「那表示分界點在後半段！」阿翔接話。

「對。如果是黑色的——」

「分界點在前半段。」

「然後呢？」

阿翔想了想：「......再看剩下那半的中間？」

我笑了。「沒錯。」

```
  86,400 行日誌。分界點在某處。

  ┌─────────────────────────────────────────────────┐
  │ OK OK OK OK OK OK OK OK|CRPT CRPT CRPT CRPT   │
  └─────────────────────────────────────────────────┘
                            ↑ 在這裡，但我們不知道

  【第 1 步】看正中間：第 43,200 行
  ┌────────────────────┬─┬──────────────────────────┐
  │                    │?│                          │
  └────────────────────┴─┴──────────────────────────┘
  結果：OK → 分界點一定在右半邊
  一刀砍掉左邊 43,200 行，不用看了。

  【第 2 步】看右半邊的中間：第 64,800 行
  剩餘範圍：43,200 ~ 86,400
                       ┌──────────┬─┬──────────────┐
                       │          │?│              │
                       └──────────┴─┴──────────────┘
  結果：CORRUPTED → 分界點在左半邊
  再砍掉一半。

  【第 3 步】第 54,000 行
  剩餘範圍：43,200 ~ 64,800
                       ┌────┬─┬────┐
                       │    │?│    │
                       └────┴─┴────┘
  結果：CORRUPTED → 繼續往左

  ......

  【第 17 步】
  剩餘範圍：就剩一行 → 找到了！
```

學姊在旁邊聽著，嘴角微微上揚。
那是她覺得「這個人可以教」時才會出現的表情。

「算一下，」她說，「總共需要幾步？」

我在白板上寫：

```
  86,400  →  43,200  →  21,600  →  10,800  →  5,400
     →  2,700  →  1,350  →  675  →  338  →  169
     →  85  →  43  →  22  →  11  →  6  →  3  →  1

  每次除以 2，直到剩 1。
  86,400 ÷ 2 ÷ 2 ÷ 2 ... = 1

  需要幾次？ log₂(86,400) ≈ 17 次
```

阿翔呆住了。

「十七次？八萬多行，只要看十七行就找到了？」

「十七次。」我點頭。

---

### 2.3　但是，為什麼？

這裡才是重點。

不是「背下來 Binary Search 要 O(log n)」，
而是——**為什麼切一半就夠了？**

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 偵探手札 #1 —— Binary Search 的本質                     │
│                                                             │
│  你有 86,400 行日誌。你需要的資訊量是：                     │
│                                                             │
│    「分界點在第幾行？」                                     │
│                                                             │
│  用二進位表示 86,400 個可能的位置，需要 17 個位元。         │
│  也就是說，你需要 17 個 bit 的資訊。                        │
│                                                             │
│  每次你查看一行日誌，得到 OK 或 CORRUPTED。                 │
│  這是一個 yes/no 的答案 —— 恰好 1 個 bit。                 │
│                                                             │
│  如果你每一次提問都剛好砍掉一半的可能性，                   │
│  那你就在用最高效率獲取資訊。                               │
│                                                             │
│  17 個問題 × 1 bit = 17 bits → 恰好足夠定位。              │
│                                                             │
│  Binary Search 之所以是 O(log n)，                          │
│  不是因為「它很快」這種空洞的理由。                         │
│  是因為它每一步都 完美地利用了一個 bit 的資訊。             │
│  它是理論上的最佳搜尋——前提是資料有序。                     │
│                                                             │
│  如果資料無序呢？                                           │
│  那你每次查看一行，只能排除「那一行」。                     │
│  1 行 → 1 行的資訊。86,400 行 → 最慘看 86,400 次。         │
│  因為無序時，每次查看提供的不是「哪半邊」的資訊，           │
│  而只是「這一行是不是」的資訊。                             │
│                                                             │
│  所以，排序並不只是「把東西排整齊」。                       │
│  排序 = 賦予資料結構，讓每次比較都能淘汰一半。             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

學姊已經在跑程式了。十七次查詢之後，她抬起頭。

「入侵時間：2024 年 11 月 7 日，凌晨 01:23:47。」

吳教授皺著眉頭在筆記本上記下。

我看了一眼時鐘。凌晨三點四十二分。距離入侵不到兩個半小時。

「第一個問題解決了，」學姊說，「接下來——哪些資料被複製了。」

---

## 第三幕　偵探的筆記本

### 3.1　大海撈針 ×2

多出來的 2,627 筆重複資料混在一百萬筆裡面。
我們需要找出「哪些」被複製了。

阿翔又舉手了：「那就一筆一筆比對啊？拿第一筆去跟其他所有的比，
然後拿第二筆去跟——」

「一百萬筆，兩兩比對，」學姊打斷他，
「需要多少次比較？」

我替她算：

```
  比較次數 = C(1,000,000, 2) = 1,000,000 × 999,999 / 2
           ≈ 500,000,000,000（五千億次）

  假設每秒一億次比較 → 需要 5,000 秒 ≈ 83 分鐘

  但如果資料更大呢？一千萬筆？
  → 50,000,000,000,000（五十兆次）→ 不可能了
```

「O(n²)，」學姊說，「不可接受。」

阿翔縮了縮脖子。

我又開始想了。一百萬筆資料裡找重複。
不能兩兩比，那怎麼辦？

然後我想到一個東西。

---

### 3.2　如果你有一本神奇的筆記本

「學姊，借我一張紙。」

我在紙上畫了一個表格。

「想像你是一個偵探，手上有一本筆記本。
你走過一排嫌疑犯，每個人報上名字。」

「你把每個名字記在筆記本裡。如果有人報了一個你已經記過的名字——」

「就是重複的。」阿翔秒懂。

「對。但重點是：**查筆記本要多快？**」

普通的筆記本，你寫了一百頁，要翻一百頁才能確認「有沒有見過這個名字」。
那跟一筆一筆比沒兩樣。

但如果——你的筆記本有個特殊的索引系統呢？

```
┌──────────────────────────────────────────────────────────┐
│                                                          │
│           普通筆記本 vs 偵探的特殊筆記本                 │
│                                                          │
│  【普通筆記本】                                          │
│                                                          │
│   第 1 頁：陳一                                          │
│   第 2 頁：林二                                          │
│   第 3 頁：張三         ← 要找「李四」？                 │
│   第 4 頁：李四            得從頭翻到這裡。              │
│   ...                      翻了 4 頁才找到。             │
│   第 n 頁：???              最慘翻 n 頁 → O(n)          │
│                                                          │
│                                                          │
│  【偵探的特殊筆記本】                                    │
│                                                          │
│   規則：每個名字都有一個專屬頁碼。                       │
│         名字 → 計算 → 頁碼（直接翻到那頁）              │
│                                                          │
│   "陳一" → hash("陳一") → 頁碼 42                       │
│   "林二" → hash("林二") → 頁碼 7                        │
│   "張三" → hash("張三") → 頁碼 91                       │
│   "李四" → hash("李四") → 頁碼 23                       │
│                                                          │
│   要找「李四」？                                         │
│   → hash("李四") = 23                                    │
│   → 直接翻到第 23 頁。                                   │
│   → 有寫東西？見過了。沒寫？第一次見。                   │
│   → 只翻了 1 頁 → O(1)                                  │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

阿翔眼睛亮了：「所以你不是在『找』，你是直接『算出位置』然後翻過去！」

「沒錯。」

這就是 Hash Map。

你不是在大海裡撈針。你是把每根針在丟進海裡之前，
先在它的 GPS 座標上做了記號。下次要找它，直接輸入座標就到了。

---

### 3.3　但為什麼是 O(1)？

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 暫停推理                                                │
│                                                             │
│  等一下。這也太神了吧。                                     │
│  不管有一百筆還是一百萬筆資料，查一筆都只要 O(1)？         │
│  這裡面一定有什麼 tradeoff。天下沒有白吃的午餐。           │
│                                                             │
│  想想看：代價是什麼？                                       │
│                                                             │
│  想三十秒再往下看。                                         │
└─────────────────────────────────────────────────────────────┘
```

代價有兩個。

**第一：空間。**

你需要一本夠大的筆記本。如果你的 hash function 算出的頁碼範圍是 0~999，
你就需要一本 1000 頁的筆記本。就算大部分頁面是空的。
用空間換時間。

**第二：碰撞。**

如果兩個不同的名字被 hash 到同一頁呢？

```
  hash("陳一") = 42
  hash("王五") = 42    ← 撞了！

  第 42 頁上寫了兩個人。
  這時候你翻到第 42 頁，發現有兩個名字，
  還是得一一比對。

  如果很多人都撞到同一頁 → 退化成 O(n)
  如果 hash function 夠好，分佈均勻 → 每頁平均只有 1-2 人 → O(1)
```

「所以 O(1) 是平均的，不是保證的？」阿翔問。

「嚴格來說是 amortized O(1)，」學姊接話，
手指沒離開鍵盤，「但在實務上，一個好的 hash function 幾乎不會讓你失望。」

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 偵探手札 #2 —— HashMap 為什麼是 O(1)                   │
│                                                             │
│  本質：你把「搜尋」這個動作，替換成了「計算」。             │
│                                                             │
│  搜尋 = 在一堆東西裡面翻 → 跟資料量有關 → O(n)            │
│  計算 = 用公式直接得到位置 → 跟資料量無關 → O(1)           │
│                                                             │
│  這就是為什麼 HashMap 快：                                  │
│  它根本不搜尋。它計算。                                     │
│                                                             │
│  你不是拿著照片在人群中一個一個認臉。                       │
│  你是打電話給對方，問他：「你在哪？」他直接告訴你地址。     │
│                                                             │
│  代價：                                                     │
│  1. 空間：需要預留位置（但記憶體在現代很便宜）              │
│  2. 碰撞：不同的 key 可能算出相同的位置                     │
│     → 解法：chaining（同一格放一個小串列）                  │
│     → 或 open addressing（往旁邊找空位）                    │
│  3. hash function 要夠好（分佈均勻）                        │
│                                                             │
│  真實世界的直覺：                                           │
│  • 圖書館的書按索書號放 → hash 就是索書號的計算方式        │
│  • 字典的注音排列 → 你不會從第一頁開始找「ㄓ」             │
│  • 手機通訊錄按姓氏分組 → 直接跳到「林」                   │
│                                                             │
│  這些全都是 hash 的概念：                                   │
│  把 key 轉成 address，跳過搜尋。                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### 3.4　找出重複

現在回到案件。

學姊已經寫好了程式。邏輯異常簡單：

```
  遍歷 1,048,576 + 2,627 筆資料：

  對每一筆紀錄：
      計算它的 hash → 翻到筆記本的那一頁
      如果那頁已經有東西了 → 重複！記下來
      如果那頁是空的 → 寫上去

  走完一遍就結束了。
```

```
  ┌─ 走訪每筆資料 ─────────────────────────────────────┐
  │                                                     │
  │  #10001 陳一 → hash=42  → 頁42空  → 寫入          │
  │  #10002 林二 → hash=7   → 頁7空   → 寫入          │
  │  #50742 李五 → hash=156 → 頁156空 → 寫入          │
  │  #10001 陳一 → hash=42  → 頁42有了 → 🚨 重複！    │
  │  #88234 周八 → hash=301 → 頁301空 → 寫入          │
  │  ...                                                │
  │                                                     │
  │  時間複雜度：O(n)  只走一遍                         │
  │  空間複雜度：O(n)  需要一本筆記本                   │
  └─────────────────────────────────────────────────────┘
```

「跑完了，」學姊說，「2,627 筆重複。全部在這。」

整個過程不到兩秒。

阿翔張大嘴：「兩秒？五千億次比較的那個方法要八十三分鐘欸！」

「那就是 O(n) 和 O(n²) 的差距，」我說。
「n 是一百萬的時候，n² 是一兆。差了一百萬倍。」

但我注意到一件事。

我湊過去看學姊的螢幕。那 2,627 筆重複的學號......

「學姊，這些重複的學號，有什麼規律嗎？」

她停頓了一秒。然後把學號列表排了個序。

螢幕上出現了一串數字。

我盯著看了十秒。

然後背脊發涼。

「......這些學號，不是隨機的。」

「嗯，」學姊說。

「它們是連續的。每隔一段距離就出現一組重複。間距......是遞減的？」

學姊沒回答。但她看我的眼神變了。
從「這個人可以教」升級成「這個人能推理」。

先記下這件事。等等回來。

---

## 第四幕　兩人一書

### 4.1　比對

第三個問題：被打亂的方式有沒有規律？

吳教授給了我們原始備份和被竄改的版本。兩份資料。
原始版是按學號排序的，竄改版完全亂序。

「把竄改版也排序一下，」學姊說，「然後跟原始版逐行比對。」

合理。兩份都排好序之後，就可以同步對照了。

但比對一百萬行 × 一百萬行......

「不用那樣。」學姊看穿了我的擔憂。

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 暫停推理                                                │
│                                                             │
│  你有兩份排好序的資料 A 和 B。                              │
│  A 有 1,048,576 筆（原始）                                  │
│  B 有 1,051,203 筆（竄改後，排序過）                        │
│                                                             │
│  你想找出：                                                 │
│  - B 裡有但 A 裡沒有的                                      │
│  - A 裡有但 B 裡沒有的                                      │
│  - 兩邊都有但內容不同的                                     │
│                                                             │
│  兩邊都已排好序。                                           │
│  你能想到一個 O(n) 的方法嗎？                               │
│                                                             │
│  提示：想像兩個人同時在讀同一本書的兩個版本。               │
│                                                             │
│  想三十秒。                                                 │
└─────────────────────────────────────────────────────────────┘
```

---

### 4.2　兩根手指的舞蹈

我在白板上畫了兩列。

```
  原始資料 A（已排序）          竄改資料 B（已排序）
  ┌──────┐                     ┌──────┐
  │10001 │ ← 指標 i            │10001 │ ← 指標 j
  │10002 │                     │10001 │
  │10003 │                     │10002 │
  │10004 │                     │10003 │
  │10005 │                     │10003 │
  │...   │                     │10004 │
  └──────┘                     │10005 │
                               │...   │
                               └──────┘
```

「我們放兩根手指，」我說，「一根指著 A 的開頭，一根指著 B 的開頭。」

「然後呢？」阿翔問。

「比較兩根手指指著的值。三種情況：」

```
  情況 1：A[i] == B[j] → 一致，兩根手指同時往下移
  情況 2：A[i] < B[j]  → A 有但 B 沒有（被刪了？），i 往下移
  情況 3：A[i] > B[j]  → B 有但 A 沒有（被加了？），j 往下移
```

我在白板上模擬：

```
  ╔═══════════════════════════════════════════════════════════╗
  ║  Step 1:  A[i]=10001, B[j]=10001  → 相同！ i++, j++     ║
  ║                                                          ║
  ║  Step 2:  A[i]=10002, B[j]=10001  → A > B？不對         ║
  ║           10002 > 10001 → B 多了一個 10001！             ║
  ║           → B 的 10001 是重複的！j++                     ║
  ║                                                          ║
  ║  Step 3:  A[i]=10002, B[j]=10002  → 相同！ i++, j++     ║
  ║                                                          ║
  ║  Step 4:  A[i]=10003, B[j]=10003  → 相同！ i++, j++     ║
  ║                                                          ║
  ║  Step 5:  A[i]=10004, B[j]=10003  → B 又多了一個！j++   ║
  ║                                                          ║
  ║  Step 6:  A[i]=10004, B[j]=10004  → 相同！ i++, j++     ║
  ║                                                          ║
  ║  ......                                                  ║
  ║                                                          ║
  ║  兩根手指都只往前走，從不回頭。                          ║
  ║  A 走了 n 步，B 走了 m 步。                              ║
  ║  總共：O(n + m) ≈ O(n)                                   ║
  ╚═══════════════════════════════════════════════════════════╝
```

阿翔盯著白板看了好一會兒，然後——

「等等。這也太優雅了吧。」

他難得說出這種話。但我懂他的意思。

---

### 4.3　為什麼指標只往前走就夠了？

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 偵探手札 #3 —— Two Pointers 的核心直覺                  │
│                                                             │
│  為什麼兩根指標都只往前走、從不回頭，就能找出所有差異？     │
│                                                             │
│  因為資料是排好序的。                                       │
│                                                             │
│  排好序 = 單調性。                                          │
│  A[i] 只會越來越大。B[j] 也只會越來越大。                   │
│                                                             │
│  如果現在 A[i] < B[j]，                                     │
│  那 A[i] 也一定 < B[j+1]、B[j+2]、B[j+3]......            │
│  （因為 B 是遞增的）                                        │
│  所以 A[i] 不可能在 B 的後面找到匹配。                      │
│  → A[i] 一定是「A 有但 B 沒有」→ 安心移動 i。              │
│                                                             │
│  你注意到了嗎？                                             │
│  這跟 Binary Search 的道理是一樣的。                        │
│                                                             │
│  Binary Search 利用排序的單調性，一次砍掉一半。             │
│  Two Pointers 利用排序的單調性，一次排除一個方向。          │
│                                                             │
│  排序是一切的根基。                                         │
│  沒有排序，就沒有單調性。                                   │
│  沒有單調性，就不能安全地跳過任何東西。                     │
│  你只能一個一個看 → O(n²)。                                 │
│                                                             │
│  排序的代價是 O(n log n)。                                   │
│  排序的回報是：之後的每個操作都從 O(n) 變成 O(log n) 或更好。│
│  這筆投資，幾乎永遠值得。                                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

程式跑完了。學姊把比對結果投到大螢幕上。

「沒有資料被刪除。只有新增了 2,627 筆重複。
原始的 1,048,576 筆全部都在，只是被打亂了順序。」

吳教授鬆了口氣：「至少資料沒遺失。」

「但這更奇怪了，」我說。

所有人看著我。

「如果是惡意攻擊，為什麼不刪資料？刪資料才是最大的傷害。
只是打亂順序然後塞幾筆重複......這像是——」

我頓住了。

「像是有人在測試什麼，」學姊替我說完。

---

## 第五幕　混亂中的秩序

### 5.1　不是隨機的

凌晨四點半。我們已經在伺服器室待了將近一個小時。

吳教授去泡咖啡了。阿翔趴在桌上打瞌睡。
只剩我和學姊還在盯著螢幕。

學姊調出了被打亂的資料的完整順序。
一百萬筆學號，按照它們在「竄改版」中出現的順序排列。

我一開始什麼都看不出來。就是一堆亂七八糟的數字。

然後學姊做了一件事。

她把學號正規化——把每個學號映射到 0~999999 的範圍——
然後用 ASCII 畫出了前兩百筆的分佈圖。

```
╔══════════════════════════════════════════════════════════════╗
║  竄改版的前 200 筆資料的學號分佈                            ║
║  （x 軸 = 在竄改版中的位置，y 軸 = 正規化學號大小）        ║
╠══════════════════════════════════════════════════════════════╣
║                                                              ║
║  999k ┤                                                      ║
║       │              ·                                       ║
║       │          ·   ·                                       ║
║  750k ┤      ·   · ·  ·                                     ║
║       │     · · ·      ·                                     ║
║       │    ·  ·         ·                                    ║
║  500k ┤  ·               ·                                   ║
║       │ ·                 ·                                  ║
║       │·                   ·                                 ║
║  250k ┤                     ·                                ║
║       │                      ·  ·                            ║
║       │                       ··  ·                          ║
║    0k ┤                            ·  ·  · · ·  · · · ·     ║
║       └──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──     ║
║          0  20 40 60 80 100 120 140 160 180 200              ║
║                                                              ║
║  ......這不是隨機的。                                        ║
║  這看起來像......                                            ║
╚══════════════════════════════════════════════════════════════╝
```

我盯著那個圖形。

先升後降。升的速度先快後慢，降的速度先慢後快。
像一座山。或者——

「這是 heap 的 sift down 軌跡，」學姊平靜地說。

我回頭看她：「什麼？」

「有人對原始資料做了 heapify，然後反覆 extract-max。」

她開始在白板上畫。

「Heap sort。這不是隨機打亂，是有人用 **heap sort 排了一半**。」

```
┌──────────────────────────────────────────────────────────────┐
│                                                              │
│  原始資料（sorted ascending by student ID）                  │
│      ↓                                                       │
│  有人執行了 max-heapify                                      │
│      ↓                                                       │
│  然後 extract-max 了若干次                                   │
│      ↓                                                       │
│  但沒有做完就中斷了                                          │
│      ↓                                                       │
│  留下一個「半完成的 heap sort」                               │
│                                                              │
│  證據：                                                      │
│  • 前半段的數字呈現 heap 的 sift-down 軌跡                  │
│  • 後半段趨近原始排序（還沒被處理到的部分）                  │
│  • 整體呈現「大的先出來，然後越來越亂」的特徵               │
│                                                              │
│  結論：犯人在執行 heap sort 的過程中被中斷了。               │
│        他不是在「打亂」資料——他是在用自己的方式「重新排序」。│
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

### 5.2　排序不只是排序

```
┌─────────────────────────────────────────────────────────────┐
│  🔍 偵探手札 #4 —— 排序的哲學                               │
│                                                             │
│  今晚我們碰到了一個矛盾：                                   │
│                                                             │
│  原始資料是用 B-tree index 排序的（資料庫的標準做法）。      │
│  犯人卻用 heap sort 重新排序。                               │
│                                                             │
│  為什麼？                                                   │
│                                                             │
│  不同的排序方式，代表不同的「世界觀」：                      │
│                                                             │
│  • Merge Sort：「把問題分成兩半，各自解決，再合併。」       │
│    → 分治法。穩定。O(n log n) 保證。                        │
│    → 像是一個有條不紊的人，永遠先拆解再組合。              │
│                                                             │
│  • Quick Sort：「找一個基準，比它小的往左，大的往右。」     │
│    → 賭博型。平均 O(n log n)，最差 O(n²)。                  │
│    → 像是一個直覺型的人，通常很快但偶爾翻車。              │
│                                                             │
│  • Heap Sort：「維護一個優先順序，每次取出最大的。」        │
│    → 結構型。O(n log n) 保證。原地排序。                    │
│    → 像是一個注重階級的人，永遠讓最重要的先走。            │
│                                                             │
│  • Counting Sort：「數每個值出現幾次，直接擺放。」          │
│    → 跳脫比較框架。O(n+k)。                                 │
│    → 像是一個完全不比較的人，用統計代替判斷。               │
│                                                             │
│  犯人選了 Heap Sort。                                        │
│  這不是隨機的選擇。                                          │
│  Heap Sort 有一個特性：它是 in-place 的。                    │
│  不需要額外的大量記憶體。                                    │
│                                                             │
│  這意味著——犯人的記憶體受限。                                │
│  也許他是遠端入侵，只能使用有限的資源。                      │
│                                                             │
│  排序演算法的選擇，本身就是一條線索。                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

我看著白板上學姊畫的圖，思緒開始連接起來。

入侵時間：01:23:47。用 binary search 在十七步之內找到。
重複資料：2,627 筆。用 hash map 在兩秒之內全部揪出。
打亂方式：半完成的 heap sort。用 two pointers 比對出來的。

三條線索。三個演算法。

然後我突然想到一件事。

---

## 第六幕　線索浮現

### 6.1　那些重複的學號

我衝到學姊旁邊，調出剛才找到的 2,627 筆重複學號。

「學姊，幫我把這些重複的學號，按照它們在原始資料中的位置標出來。」

學姊打了幾行指令。螢幕上出現了一張圖：

```
╔══════════════════════════════════════════════════════════════╗
║  重複學號在原始資料中的位置分佈                              ║
║  （一百萬筆資料，x 軸 = 原始位置，• = 有重複）             ║
╠══════════════════════════════════════════════════════════════╣
║                                                              ║
║  位置 0          250k         500k         750k       1000k  ║
║  ├──────────┼──────────┼──────────┼──────────┤              ║
║  │                                           │              ║
║  │  •                                        │              ║
║  │  •••                                      │              ║
║  │     •                                     │              ║
║  │       ••                                  │              ║
║  │          •                                │              ║
║  │            •••                            │              ║
║  │               •                           │              ║
║  │                 ••                        │              ║
║  │                    •••                    │              ║
║  │                       •                   │              ║
║  │                         ••                │              ║
║  │                            •••            │              ║
║  │                                •          │              ║
║  │                                  ••       │              ║
║  │                                     •••   │              ║
║  │                                        •  │              ║
║  │                                           │              ║
║  ├──────────┼──────────┼──────────┼──────────┤              ║
║                                                              ║
║  間距：512, 256, 128, 64, 32, ...                            ║
║                                                              ║
║  ⚠  這不是隨機分佈。這是等比數列。公比 = 1/2。              ║
╚══════════════════════════════════════════════════════════════╝
```

阿翔被我們的聲音吵醒了，揉著眼睛湊過來。

「......什麼東西？看不懂。」

「重複的學號不是隨機複製的，」我說，聲音有點發抖，
「它們被複製的位置間距是 512、256、128、64......每次減半。」

「每次減半......」阿翔重複了一次，然後眼睛突然睜大，
「這不是 binary search 的步伐嗎？」

房間裡沉默了三秒。

學姊轉過椅子面對我們。

她的表情不再是冷靜的分析，而是——我第一次在她臉上看到的——
真正的好奇。

「有人在這個資料庫裡，用重複的資料，畫了一棵 binary search tree。」

我的腦袋嗡了一下。

「什麼意思？」

「那些重複的學號不是 bug，」學姊說，
「是有人故意放進去的節點。它們的位置間距形成了一棵樹的結構。
512、256、128——這是一棵完美平衡二元樹的層級間距。」

```
                        根（距起點 512 的位置）
                       ╱                      ╲
              距 256 的位置              距 768 的位置
              ╱        ╲                ╱        ╲
          距 128      距 384        距 640      距 896
          ╱    ╲      ╱    ╲        ╱    ╲      ╱    ╲
        64    192   320    448    576    704   832    960
        ...                                          ...
```

「這棵樹——指向什麼？」我問。

學姊敲了幾下鍵盤。

「每個重複學號的 course 欄位，原本應該是課程代碼。
但被改過了。改成了......」

她停頓了一下。

「改成了其他學號。」

我瞬間理解了。

「它們不是課程代碼。它們是**指標**。每個節點都指向另一個學號。
這些重複的紀錄......形成了一張**圖**。」

學姊點頭。

「有人在我們的資料庫裡，用被篡改的欄位，偷偷建立了一個隱藏的網路。
資料庫的破壞只是障眼法。」

「真正的目的，」她站起來，「是這張藏在資料裡面的**圖**。」

我看了一眼時鐘。凌晨五點十二分。

窗外，天空剛開始泛出魚肚白。

「那我們......」阿翔吞了口口水，「要怎麼讀這張圖？」

學姊走到門口，拿起外套。

「先回去睡三個小時，」她說，「等天亮了，我們來拆這張網。」

她在門口停了一下，回頭看了我一眼。

「林凱。」

「嗯？」

「今天你的推理——不錯。」

門關上了。

我站在原地，感覺心跳有點快。

可能是因為這個案件太刺激了。

可能。

---

## 偵探手札　第一夜總結

```
╔══════════════════════════════════════════════════════════════╗
║                                                              ║
║   ┌─────────────────────────────────────────────────────┐   ║
║   │         📓 偵 探 手 札 — 第 一 夜                    │   ║
║   └─────────────────────────────────────────────────────┘   ║
║                                                              ║
║   案件：系計中伺服器遭入侵                                   ║
║   時間：2024/11/07  03:17 — 05:12                            ║
║                                                              ║
║   ─── 已查明 ───                                             ║
║                                                              ║
║   1. 入侵時間：01:23:47                                     ║
║      方法：日誌 Binary Search（17 步 / 86,400 行）           ║
║      洞見：排好序的資料讓每次比較都能淘汰一半               ║
║                                                              ║
║   2. 重複資料：2,627 筆                                     ║
║      方法：HashMap 一次遍歷（O(n)）                          ║
║      洞見：HashMap 把「搜尋」替換成「計算」                  ║
║                                                              ║
║   3. 原始資料完整，無刪除，僅亂序 + 插入重複                ║
║      方法：排序 + Two Pointers 比對（O(n)）                  ║
║      洞見：排序賦予單調性，讓指標永不回頭                   ║
║                                                              ║
║   4. 打亂方式 = 半完成的 Heap Sort                           ║
║      推論：犯人在記憶體受限環境下操作                        ║
║                                                              ║
║   ─── 新發現 ───                                             ║
║                                                              ║
║   5. 重複資料的位置形成 Binary Search Tree 結構              ║
║   6. 被竄改的 course 欄位存的是其他學號 → 指標              ║
║   7. 資料庫裡藏了一張隱藏的「圖」                           ║
║                                                              ║
║   ─── 待查 ───                                               ║
║                                                              ║
║   • 這張圖連接了哪些人？                                     ║
║   • 圖的結構代表什麼？                                       ║
║   • 犯人想用這張隱藏網路做什麼？                             ║
║                                                              ║
║   ─── 今夜學到的事 ───                                       ║
║                                                              ║
║   「排序不只是把東西排整齊。                                 ║
║     排序是賦予資料結構。                                     ║
║     有了結構，才能跳過、砍半、一步到位。                     ║
║     沒有結構，就只能一個一個看。                             ║
║     這就是 O(log n) 和 O(n) 的分水嶺。」                    ║
║                                                              ║
║                               —— 林凱，05:20 寫於宿舍       ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
```

---

> **下集預告**
>
> *那張藏在資料庫裡的圖，連接的不只是學號。*
> *當我們把它展開的時候，看到的是一張人際關係網——*
> *教授、助教、學生，某些不該有交集的人之間，被畫上了線。*
>
> *而這張網裡，有一個環。*
>
> *在圖論裡，環代表一種不該存在的循環。*
> *在現實裡，環代表——有人在說謊。*
>
> *《演算法偵探筆記（中）— 社群網路的裂痕》，待續。*
