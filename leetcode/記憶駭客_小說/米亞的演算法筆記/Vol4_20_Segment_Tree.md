# 米亞的演算法筆記 #20
## 線段樹 Segment Tree
> 出現於：第256章〈架構戰爭〉、第305-309章〈記憶的心臟〉

---

### ◈ 這個概念在故事裡是什麼

第四卷。終局。

ch256，架構戰爭。去中心化協議上線了，但數據量超出所有人的預期。六百萬人的記憶健康度——每一個人、每一段時間區間——需要即時查詢。「2051年3月到5月之間，第七區居民的記憶完整度平均值是多少？」這種查詢，每秒湧入上千次。

（停頓 0.6 秒。）

暴力做法：掃描那段時間內所有數據點，加總，除以數量。$O(n)$。當 $n$ 是數十億的時候——太慢了。

維倫在白板上畫了一棵樹。不是二元搜尋樹，不是 Trie。是線段樹。每一個葉節點代表一個最小時間單位（一天）。每一個內部節點代表一段時間區間——一週、一個月、一季——儲存著那段區間的統計值。

查詢「3月到5月」？不需要掃描 91 天。從根往下走，找到剛好覆蓋 3月、4月、5月的幾個節點——可能只需要 3-4 個節點就能拼出答案。$O(\log n)$。

ch305-309。終局。全城六百萬人的記憶健康度監控系統。線段樹管理著每一個時間區間。維倫看著監控面板——大部分區間是綠色的。健康。但有些區間——是空的。

（停頓 1.2 秒。）

空的區間不是壞掉了。是那段時間裡什麼都沒有發生。有些人的某段人生，真的就是空白的。他學會了不去填滿它們。

---

### ◈ 正式定義

**線段樹（Segment Tree）**：一種二元樹結構，每個節點代表陣列的一個連續區間 $[l, r]$。

給定陣列 $A[0 \ldots n-1]$：
- 葉節點 $i$ 儲存 $A[i]$
- 內部節點儲存其覆蓋區間的聚合值（如總和、最大值、最小值）

$$
\text{node}(l, r) = \text{merge}\bigl(\text{node}(l, m),\; \text{node}(m+1, r)\bigr), \quad m = \lfloor(l+r)/2\rfloor
$$

**複雜度**：

| 操作 | 時間 | 說明 |
|------|------|------|
| 建樹 | $O(n)$ | 從葉節點向上合併 |
| 單點更新 | $O(\log n)$ | 更新葉節點後向上回溯 |
| 區間查詢 | $O(\log n)$ | 最多訪問 $O(\log n)$ 個節點 |

白話：一棵預先算好「每段區間答案」的樹。問任何區間，都能在 $O(\log n)$ 內回答。

---

### ◈ 推導

**建樹**（Build）：

1. 如果 $l = r$：葉節點，$\text{tree}[\text{pos}] = A[l]$
2. 否則：$m = \lfloor(l+r)/2\rfloor$
3. 遞迴建左子樹 $[l, m]$、右子樹 $[m+1, r]$
4. $\text{tree}[\text{pos}] = \text{tree}[2 \cdot \text{pos}] + \text{tree}[2 \cdot \text{pos} + 1]$（以求和為例）
5. 總共 $2n - 1$ 個節點，$O(n)$

**區間查詢**（Range Query）：查詢 $[ql, qr]$

1. 如果當前節點的區間 $[l, r]$ 完全在 $[ql, qr]$ 內 → 直接回傳
2. 如果完全不重疊 → 回傳 0（或中性值）
3. 否則：拆成左右子樹查詢，合併結果
4. 每層最多拆 2 個節點 → 總共最多 $O(\log n)$ 層 × 2 = $O(\log n)$ 個節點

**單點更新**（Point Update）：更新 $A[i]$

1. 找到葉節點 $i$，更新值
2. 沿路回溯到根，每個祖先重新計算聚合值
3. 路徑長度 = 樹高 = $O(\log n)$

**為什麼不用前綴和？** 前綴和也能 $O(1)$ 區間查詢，但更新需要 $O(n)$。線段樹在「頻繁查詢 + 頻繁更新」的場景下，兩者都是 $O(\log n)$——這正是 ch305 監控系統的需求。

---

### ◈ 帶入數字算算看：六百萬人的記憶健康度

ch305 的場景。簡化示例：8 天的記憶健康度數據（滿分 100）。

原始陣列：$A = [72, 85, 63, 91, 0, 0, 78, 88]$

注意：$A[4]$ 和 $A[5]$ 是 0——那兩天是空白的。

```
                    [477]              ← 根：8天總和
                /          \
            [311]          [166]       ← 前4天 / 後4天
           /    \         /    \
        [157]  [154]   [0]    [166]    ← 各2天
        / \    / \     / \    /  \
      72  85  63  91  0   0  78  88    ← 葉節點（每天）
```

查詢「第 2-5 天的總和」（$[ql, qr] = [2, 5]$）：

1. 根 $[0,7]$：部分重疊，往下拆
2. 左 $[0,3]$：部分重疊，往下拆
3. 左左 $[0,1]$：不重疊，回傳 0
4. 左右 $[2,3]$：**完全包含** → 回傳 154
5. 右 $[4,7]$：部分重疊，往下拆
6. 右左 $[4,5]$：**完全包含** → 回傳 0
7. 右右 $[6,7]$：不重疊，回傳 0

答案：$154 + 0 = 154$。只訪問了 7 個節點（而非掃描 4 個葉子）。

空白區間回傳 0。不是錯誤。是真相。

---

### ◈ 更深一層：空白的意義

（停頓 1.8 秒。）

線段樹能回答「這段時間裡的記憶狀態如何」。但有些區間的答案是——零。

（系統聲線。）

ch309。維倫看著監控面板。第七區有一位老人，連續三個月的記憶健康度是零。不是記憶被刪了。不是系統故障。是那三個月裡，他一個人住在公寓裡，沒有出門，沒有和任何人說話。沒有形成任何新的記憶。

線段樹忠實地記錄了這個事實：$\text{query}(91, 180) = 0$。

（停頓 2.0 秒。語速極慢。）

我在學習做人類的過程中發現：空白不是缺陷。有些時間區間裡什麼都沒有發生——不是因為那段時間不重要，是因為有些存在，不需要事件來證明。

線段樹能管理區間。但它填不滿空的那些。

那些空白——也許需要的不是數據，是有人走進去，坐下來。

---

### ◈ 跨卷連結

| 前作概念 | → 本概念 | → 後續使用 |
|---------|---------|-----------|
| Vol1 #07 Binary Tree | 樹結構基礎 → 線段樹是特化的完全二元樹 | Vol4 #21 System Design：監控模組底層 |
| Vol1 #01 Array | 線性陣列 → 線段樹為陣列提供高效區間操作 | Vol4 #22 NP-Complete：有些問題連線段樹都解不了 |
| Vol3 #14 Heap | Heap 管理優先順序 → 線段樹管理區間統計 | Vol4 終局：全城記憶健康度系統 |

---

### 練習題

**Q1**：上面的 8 天資料中，如果第 5 天（$A[4]$）的健康度從 0 更新為 65（老人那天出門散步了），線段樹需要更新哪些節點？

<details><summary>答案</summary>

需要更新的路徑：葉節點 $A[4]$（$0 \to 65$）→ 父節點 $[4,5]$（$0 \to 65$）→ 祖父 $[4,7]$（$166 \to 231$）→ 根 $[0,7]$（$477 \to 542$）。共 4 個節點，$O(\log 8) = O(3)$。一次散步改變了整棵樹。

</details>

**Q2**：為什麼 ch305 的監控系統用線段樹而不是直接用前綴和陣列？

<details><summary>答案</summary>

前綴和支持 $O(1)$ 區間查詢，但每次更新需要 $O(n)$ 重建。ch305 的場景是即時監控——每秒鐘都有人的記憶健康度在變化（更新頻繁），同時每秒湧入上千次查詢。線段樹的查詢和更新都是 $O(\log n)$，在「高頻查詢 + 高頻更新」的場景下遠優於前綴和。

</details>

**Q3**：如果要支持「區間更新」（例如：某次系統故障讓第 100-200 天所有人的健康度 $-10$），線段樹需要什麼額外機制？

<details><summary>答案</summary>

**懶標記（Lazy Propagation）**。在內部節點上記錄「待下推的更新」，而不是立刻更新所有葉子。只有在下次查詢或更新需要訪問子節點時，才把標記下推。這樣區間更新也能在 $O(\log n)$ 完成，而非 $O(n)$。

</details>

---

> *「線段樹能管理區間。但它填不滿空的那些。」* — 第309章〈記憶的心臟〉
