# EP07 — 跨語言對照：同一問題，五種解法

> **對象**：已讀完 EP01-EP06，想建立跨語言直覺的開發者
> **核心觀念**：同一個問題在 Python / C++ / JavaScript(TypeScript) / Go / Rust 各怎麼寫？
> **學習方法**：每題先讀你最熟的語言，再橫向對照其他語言，找出「同」與「異」

---

## 目錄

| 題 | 主題 | 核心概念 |
|----|------|----------|
| 1 | Hello World 與基本 I/O | 進入點、印出、讀取輸入 |
| 2 | 變數、型別、條件判斷 | 型別系統、if/else、switch/match |
| 3 | 迴圈與陣列操作 | for、filter、map、reduce |
| 4 | 函式定義 | 參數、多回傳值、高階函式、閉包 |
| 5 | 字串處理 | 串接、分割、取代、格式化 |
| 6 | 資料結構 — Struct/Class | 定義、建構、方法 |
| 7 | 繼承/組合/介面 | 多型、interface、trait |
| 8 | 錯誤處理 | try/catch、Result、error |
| 9 | 集合操作 (Map/Dict) | 詞頻統計、排序 |
| 10 | 檔案讀寫 | 寫入、逐行讀取、解析 CSV |
| 11 | 並發/非同步 | thread、goroutine、async |
| 12 | JSON 處理 | 序列化、反序列化 |
| 附錄 | 語法速查對照表 | 全面比較表 |

---

## Problem 1：Hello World 與基本 I/O

### 1.1 印出 Hello, World!

**Python**
```python
print("Hello, World!")
```

**C++**
```cpp
#include <iostream>

int main() {
    std::cout << "Hello, World!" << std::endl;
    return 0;
}
```

**JavaScript / TypeScript**
```javascript
console.log("Hello, World!");
```

**Go**
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```

**Rust**
```rust
fn main() {
    println!("Hello, World!");
}
```

### 1.2 讀取使用者輸入並打招呼

**Python**
```python
name = input("請輸入你的名字: ")
print(f"你好, {name}!")
```

**C++**
```cpp
#include <iostream>
#include <string>

int main() {
    std::string name;
    std::cout << "請輸入你的名字: ";
    std::getline(std::cin, name);
    std::cout << "你好, " << name << "!" << std::endl;
    return 0;
}
```

**JavaScript (Node.js)**
```javascript
const readline = require("readline");

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
});

rl.question("請輸入你的名字: ", (name) => {
    console.log(`你好, ${name}!`);
    rl.close();
});
```

**Go**
```go
package main

import (
    "bufio"
    "fmt"
    "os"
    "strings"
)

func main() {
    reader := bufio.NewReader(os.Stdin)
    fmt.Print("請輸入你的名字: ")
    name, _ := reader.ReadString('\n')
    name = strings.TrimSpace(name)
    fmt.Printf("你好, %s!\n", name)
}
```

**Rust**
```rust
use std::io;

fn main() {
    println!("請輸入你的名字: ");
    let mut name = String::new();
    io::stdin()
        .read_line(&mut name)
        .expect("讀取失敗");
    let name = name.trim();
    println!("你好, {}!", name);
}
```

### 1.3 五語言 I/O 對照表

| 項目 | Python | C++ | JS/TS | Go | Rust |
|------|--------|-----|-------|-----|------|
| 印出 | `print()` | `std::cout <<` | `console.log()` | `fmt.Println()` | `println!()` |
| 讀取 | `input()` | `std::getline()` | `readline` 模組 | `bufio.NewReader` | `io::stdin().read_line()` |
| 進入點 | 檔案頂層 | `int main()` | 檔案頂層 | `func main()` | `fn main()` |
| 分號 | 不需要 | 必須 | 可選(建議加) | 不需要 | 必須 |

---

## Problem 2：變數、型別、條件判斷

### 2.1 定義不同型別的變數

**Python**
```python
age: int = 25
height: float = 175.5
name: str = "小明"
is_student: bool = True
scores: list[int] = [90, 85, 92]
```

**C++**
```cpp
#include <iostream>
#include <string>
#include <vector>

int main() {
    int age = 25;
    double height = 175.5;
    std::string name = "小明";
    bool is_student = true;
    std::vector<int> scores = {90, 85, 92};

    // C++17 auto 推導
    auto pi = 3.14;  // double
    return 0;
}
```

**JavaScript / TypeScript**
```typescript
// TypeScript（JS 不需型別標注）
const age: number = 25;
const height: number = 175.5;
const name: string = "小明";
const isStudent: boolean = true;
const scores: number[] = [90, 85, 92];

// JS 用 let/const，不加型別
let ageJS = 25;
const nameJS = "小明";
```

**Go**
```go
package main

import "fmt"

func main() {
    age := 25              // int（短變數宣告）
    height := 175.5        // float64
    name := "小明"          // string
    isStudent := true      // bool
    scores := []int{90, 85, 92} // slice

    // 明確宣告
    var count int = 10
    fmt.Println(age, height, name, isStudent, scores, count)
}
```

**Rust**
```rust
fn main() {
    let age: i32 = 25;
    let height: f64 = 175.5;
    let name: &str = "小明";
    let is_student: bool = true;
    let scores: Vec<i32> = vec![90, 85, 92];

    // 型別推導
    let pi = 3.14;  // f64
    println!("{} {} {} {} {:?} {}", age, height, name, is_student, scores, pi);
}
```

### 2.2 If/Else 多條件判斷

**Python**
```python
score = 85

if score >= 90:
    grade = "A"
elif score >= 80:
    grade = "B"
elif score >= 70:
    grade = "C"
elif score >= 60:
    grade = "D"
else:
    grade = "F"

print(f"成績: {score}, 等第: {grade}")
```

**C++**
```cpp
#include <iostream>
#include <string>

int main() {
    int score = 85;
    std::string grade;

    if (score >= 90) {
        grade = "A";
    } else if (score >= 80) {
        grade = "B";
    } else if (score >= 70) {
        grade = "C";
    } else if (score >= 60) {
        grade = "D";
    } else {
        grade = "F";
    }

    std::cout << "成績: " << score << ", 等第: " << grade << std::endl;
    return 0;
}
```

**JavaScript / TypeScript**
```javascript
const score = 85;
let grade;

if (score >= 90) {
    grade = "A";
} else if (score >= 80) {
    grade = "B";
} else if (score >= 70) {
    grade = "C";
} else if (score >= 60) {
    grade = "D";
} else {
    grade = "F";
}

console.log(`成績: ${score}, 等第: ${grade}`);
```

**Go**
```go
package main

import "fmt"

func main() {
    score := 85
    var grade string

    if score >= 90 {
        grade = "A"
    } else if score >= 80 {
        grade = "B"
    } else if score >= 70 {
        grade = "C"
    } else if score >= 60 {
        grade = "D"
    } else {
        grade = "F"
    }

    fmt.Printf("成績: %d, 等第: %s\n", score, grade)
}
```

**Rust**
```rust
fn main() {
    let score = 85;

    // Rust 的 if 是表達式，可以直接回傳值
    let grade = if score >= 90 {
        "A"
    } else if score >= 80 {
        "B"
    } else if score >= 70 {
        "C"
    } else if score >= 60 {
        "D"
    } else {
        "F"
    };

    println!("成績: {}, 等第: {}", score, grade);
}
```

### 2.3 Switch / Match 語句

**Python** (3.10+ match)
```python
command = "start"

match command:
    case "start":
        print("啟動系統")
    case "stop":
        print("停止系統")
    case "restart":
        print("重啟系統")
    case _:
        print(f"未知命令: {command}")
```

**C++**
```cpp
#include <iostream>
#include <string>

int main() {
    // C++ switch 僅支援整數/enum，字串需用 if-else
    int code = 1;
    switch (code) {
        case 1:
            std::cout << "啟動系統" << std::endl;
            break;
        case 2:
            std::cout << "停止系統" << std::endl;
            break;
        case 3:
            std::cout << "重啟系統" << std::endl;
            break;
        default:
            std::cout << "未知命令" << std::endl;
            break;
    }
    return 0;
}
```

**JavaScript / TypeScript**
```javascript
const command = "start";

switch (command) {
    case "start":
        console.log("啟動系統");
        break;
    case "stop":
        console.log("停止系統");
        break;
    case "restart":
        console.log("重啟系統");
        break;
    default:
        console.log(`未知命令: ${command}`);
}
```

**Go**
```go
package main

import "fmt"

func main() {
    command := "start"

    // Go 的 switch 不需要 break（自動 break）
    switch command {
    case "start":
        fmt.Println("啟動系統")
    case "stop":
        fmt.Println("停止系統")
    case "restart":
        fmt.Println("重啟系統")
    default:
        fmt.Printf("未知命令: %s\n", command)
    }
}
```

**Rust**
```rust
fn main() {
    let command = "start";

    // Rust 的 match 是表達式，且必須窮舉所有情況
    match command {
        "start"   => println!("啟動系統"),
        "stop"    => println!("停止系統"),
        "restart" => println!("重啟系統"),
        other     => println!("未知命令: {}", other),
    }
}
```

---

## Problem 3：迴圈與陣列操作

### 3.1 建立陣列 + For 迴圈印出每個元素

**Python**
```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for n in numbers:
    print(n, end=" ")
print()
# 輸出: 1 2 3 4 5 6 7 8 9 10
```

**C++**
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    for (int n : numbers) {
        std::cout << n << " ";
    }
    std::cout << std::endl;
    return 0;
}
```

**JavaScript / TypeScript**
```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

for (const n of numbers) {
    process.stdout.write(n + " ");
}
console.log();
// 或簡寫
numbers.forEach((n) => process.stdout.write(n + " "));
```

**Go**
```go
package main

import "fmt"

func main() {
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

    for _, n := range numbers {
        fmt.Printf("%d ", n)
    }
    fmt.Println()
}
```

**Rust**
```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    for n in &numbers {
        print!("{} ", n);
    }
    println!();
}
```

### 3.2 Filter：篩選偶數

**Python**
```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
evens = [n for n in numbers if n % 2 == 0]
# 或：evens = list(filter(lambda n: n % 2 == 0, numbers))
print(evens)  # [2, 4, 6, 8, 10]
```

**C++**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    std::vector<int> evens;

    std::copy_if(numbers.begin(), numbers.end(),
                 std::back_inserter(evens),
                 [](int n) { return n % 2 == 0; });

    for (int n : evens) {
        std::cout << n << " ";
    }
    std::cout << std::endl;  // 2 4 6 8 10
    return 0;
}
```

**JavaScript / TypeScript**
```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evens = numbers.filter((n) => n % 2 === 0);
console.log(evens);  // [2, 4, 6, 8, 10]
```

**Go**
```go
package main

import "fmt"

func main() {
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    var evens []int

    for _, n := range numbers {
        if n%2 == 0 {
            evens = append(evens, n)
        }
    }

    fmt.Println(evens)  // [2 4 6 8 10]
}
```

**Rust**
```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let evens: Vec<i32> = numbers.iter()
        .filter(|&&n| n % 2 == 0)
        .cloned()
        .collect();

    println!("{:?}", evens);  // [2, 4, 6, 8, 10]
}
```

### 3.3 Map：每個數字乘以二

**Python**
```python
numbers = [1, 2, 3, 4, 5]
doubled = [n * 2 for n in numbers]
# 或：doubled = list(map(lambda n: n * 2, numbers))
print(doubled)  # [2, 4, 6, 8, 10]
```

**C++**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    std::vector<int> doubled(numbers.size());

    std::transform(numbers.begin(), numbers.end(),
                   doubled.begin(),
                   [](int n) { return n * 2; });

    for (int n : doubled) {
        std::cout << n << " ";
    }
    std::cout << std::endl;  // 2 4 6 8 10
    return 0;
}
```

**JavaScript / TypeScript**
```javascript
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((n) => n * 2);
console.log(doubled);  // [2, 4, 6, 8, 10]
```

**Go**
```go
package main

import "fmt"

func main() {
    numbers := []int{1, 2, 3, 4, 5}
    doubled := make([]int, len(numbers))

    for i, n := range numbers {
        doubled[i] = n * 2
    }

    fmt.Println(doubled)  // [2 4 6 8 10]
}
```

**Rust**
```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    let doubled: Vec<i32> = numbers.iter()
        .map(|&n| n * 2)
        .collect();

    println!("{:?}", doubled);  // [2, 4, 6, 8, 10]
}
```

### 3.4 Reduce：加總所有數字

**Python**
```python
from functools import reduce

numbers = [1, 2, 3, 4, 5]
total = sum(numbers)                              # 內建
total2 = reduce(lambda acc, n: acc + n, numbers)  # reduce 寫法
print(total, total2)  # 15 15
```

**C++**
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    int total = std::accumulate(numbers.begin(), numbers.end(), 0);
    std::cout << total << std::endl;  // 15
    return 0;
}
```

**JavaScript / TypeScript**
```javascript
const numbers = [1, 2, 3, 4, 5];
const total = numbers.reduce((acc, n) => acc + n, 0);
console.log(total);  // 15
```

**Go**
```go
package main

import "fmt"

func main() {
    numbers := []int{1, 2, 3, 4, 5}
    total := 0

    for _, n := range numbers {
        total += n
    }

    fmt.Println(total)  // 15
}
```

**Rust**
```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    let total: i32 = numbers.iter().sum();
    // 或用 fold：
    let total2: i32 = numbers.iter().fold(0, |acc, &n| acc + n);

    println!("{} {}", total, total2);  // 15 15
}
```

---

## Problem 4：函式定義

### 4.1 基本函式：參數與回傳值

**Python**
```python
def add(a: int, b: int) -> int:
    return a + b

result = add(3, 5)
print(result)  # 8
```

**C++**
```cpp
#include <iostream>

int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(3, 5);
    std::cout << result << std::endl;  // 8
    return 0;
}
```

**JavaScript / TypeScript**
```typescript
// TypeScript
function add(a: number, b: number): number {
    return a + b;
}

// 箭頭函式
const addArrow = (a: number, b: number): number => a + b;

console.log(add(3, 5));       // 8
console.log(addArrow(3, 5));  // 8
```

**Go**
```go
package main

import "fmt"

func add(a int, b int) int {
    return a + b
}

func main() {
    result := add(3, 5)
    fmt.Println(result)  // 8
}
```

**Rust**
```rust
fn add(a: i32, b: i32) -> i32 {
    a + b  // 最後一行不加分號 = 回傳值
}

fn main() {
    let result = add(3, 5);
    println!("{}", result);  // 8
}
```

### 4.2 多回傳值

**Python**
```python
def divide(a: float, b: float) -> tuple[float, bool]:
    if b == 0:
        return 0.0, False
    return a / b, True

result, ok = divide(10, 3)
print(f"結果: {result:.2f}, 成功: {ok}")  # 結果: 3.33, 成功: True
```

**C++**
```cpp
#include <iostream>
#include <tuple>

std::tuple<double, bool> divide(double a, double b) {
    if (b == 0) {
        return {0.0, false};
    }
    return {a / b, true};
}

int main() {
    auto [result, ok] = divide(10, 3);  // C++17 結構化綁定
    std::cout << "結果: " << result << ", 成功: " << ok << std::endl;
    return 0;
}
```

**JavaScript / TypeScript**
```typescript
function divide(a: number, b: number): [number, boolean] {
    if (b === 0) {
        return [0, false];
    }
    return [a / b, true];
}

const [result, ok] = divide(10, 3);  // 解構
console.log(`結果: ${result.toFixed(2)}, 成功: ${ok}`);
```

**Go**
```go
package main

import "fmt"

// Go 原生支援多回傳值
func divide(a, b float64) (float64, bool) {
    if b == 0 {
        return 0, false
    }
    return a / b, true
}

func main() {
    result, ok := divide(10, 3)
    fmt.Printf("結果: %.2f, 成功: %v\n", result, ok)
}
```

**Rust**
```rust
fn divide(a: f64, b: f64) -> (f64, bool) {
    if b == 0.0 {
        return (0.0, false);
    }
    (a / b, true)
}

fn main() {
    let (result, ok) = divide(10.0, 3.0);
    println!("結果: {:.2}, 成功: {}", result, ok);
}
```

### 4.3 高階函式（函式作為參數）

**Python**
```python
def apply(func, x: int, y: int) -> int:
    return func(x, y)

def multiply(a: int, b: int) -> int:
    return a * b

result = apply(multiply, 4, 5)
print(result)  # 20
```

**C++**
```cpp
#include <iostream>
#include <functional>

int apply(std::function<int(int, int)> func, int x, int y) {
    return func(x, y);
}

int multiply(int a, int b) {
    return a * b;
}

int main() {
    int result = apply(multiply, 4, 5);
    std::cout << result << std::endl;  // 20

    // 也可以傳 lambda
    int result2 = apply([](int a, int b) { return a + b; }, 4, 5);
    std::cout << result2 << std::endl;  // 9
    return 0;
}
```

**JavaScript / TypeScript**
```typescript
function apply(func: (x: number, y: number) => number, x: number, y: number): number {
    return func(x, y);
}

const multiply = (a: number, b: number): number => a * b;

console.log(apply(multiply, 4, 5));                // 20
console.log(apply((a, b) => a + b, 4, 5));         // 9
```

**Go**
```go
package main

import "fmt"

func apply(fn func(int, int) int, x, y int) int {
    return fn(x, y)
}

func multiply(a, b int) int {
    return a * b
}

func main() {
    result := apply(multiply, 4, 5)
    fmt.Println(result)  // 20

    // 匿名函式
    result2 := apply(func(a, b int) int { return a + b }, 4, 5)
    fmt.Println(result2) // 9
}
```

**Rust**
```rust
fn apply<F: Fn(i32, i32) -> i32>(func: F, x: i32, y: i32) -> i32 {
    func(x, y)
}

fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

fn main() {
    let result = apply(multiply, 4, 5);
    println!("{}", result);  // 20

    // 閉包
    let result2 = apply(|a, b| a + b, 4, 5);
    println!("{}", result2); // 9
}
```

### 4.4 閉包（Closure）

**Python**
```python
def make_counter(start: int = 0):
    count = start
    def increment():
        nonlocal count
        count += 1
        return count
    return increment

counter = make_counter(10)
print(counter())  # 11
print(counter())  # 12
print(counter())  # 13
```

**C++**
```cpp
#include <iostream>
#include <functional>

std::function<int()> make_counter(int start = 0) {
    int count = start;
    return [count]() mutable -> int {
        count += 1;
        return count;
    };
}

int main() {
    auto counter = make_counter(10);
    std::cout << counter() << std::endl;  // 11
    std::cout << counter() << std::endl;  // 12
    std::cout << counter() << std::endl;  // 13
    return 0;
}
```

**JavaScript / TypeScript**
```javascript
function makeCounter(start = 0) {
    let count = start;
    return () => {
        count += 1;
        return count;
    };
}

const counter = makeCounter(10);
console.log(counter());  // 11
console.log(counter());  // 12
console.log(counter());  // 13
```

**Go**
```go
package main

import "fmt"

func makeCounter(start int) func() int {
    count := start
    return func() int {
        count++
        return count
    }
}

func main() {
    counter := makeCounter(10)
    fmt.Println(counter())  // 11
    fmt.Println(counter())  // 12
    fmt.Println(counter())  // 13
}
```

**Rust**
```rust
fn make_counter(start: i32) -> impl FnMut() -> i32 {
    let mut count = start;
    move || {
        count += 1;
        count
    }
}

fn main() {
    let mut counter = make_counter(10);
    println!("{}", counter());  // 11
    println!("{}", counter());  // 12
    println!("{}", counter());  // 13
}
```

---

## Problem 5：字串處理

### 5.1 字串串接

**Python**
```python
first = "Hello"
last = "World"
full = first + ", " + last + "!"
print(full)  # Hello, World!
# 推薦用 f-string
full2 = f"{first}, {last}!"
print(full2)  # Hello, World!
```

**C++**
```cpp
#include <iostream>
#include <string>

int main() {
    std::string first = "Hello";
    std::string last = "World";
    std::string full = first + ", " + last + "!";
    std::cout << full << std::endl;  // Hello, World!
    return 0;
}
```

**JavaScript / TypeScript**
```javascript
const first = "Hello";
const last = "World";
const full = first + ", " + last + "!";
const full2 = `${first}, ${last}!`;  // 模板字串（推薦）
console.log(full2);  // Hello, World!
```

**Go**
```go
package main

import "fmt"

func main() {
    first := "Hello"
    last := "World"
    full := first + ", " + last + "!"
    fmt.Println(full)  // Hello, World!
    // 或用 Sprintf
    full2 := fmt.Sprintf("%s, %s!", first, last)
    fmt.Println(full2)
}
```

**Rust**
```rust
fn main() {
    let first = "Hello";
    let last = "World";
    let full = format!("{}, {}!", first, last);
    println!("{}", full);  // Hello, World!

    // String 串接
    let mut s = String::from("Hello");
    s.push_str(", World!");
    println!("{}", s);
}
```

### 5.2 Split 和 Join

**Python**
```python
text = "apple,banana,cherry,date"
fruits = text.split(",")
print(fruits)  # ['apple', 'banana', 'cherry', 'date']

joined = " | ".join(fruits)
print(joined)  # apple | banana | cherry | date
```

**C++**
```cpp
#include <iostream>
#include <string>
#include <sstream>
#include <vector>

int main() {
    std::string text = "apple,banana,cherry,date";

    // Split
    std::vector<std::string> fruits;
    std::stringstream ss(text);
    std::string item;
    while (std::getline(ss, item, ',')) {
        fruits.push_back(item);
    }

    for (const auto& f : fruits) {
        std::cout << f << " ";
    }
    std::cout << std::endl;

    // Join
    std::string joined;
    for (size_t i = 0; i < fruits.size(); i++) {
        if (i > 0) joined += " | ";
        joined += fruits[i];
    }
    std::cout << joined << std::endl;  // apple | banana | cherry | date
    return 0;
}
```

**JavaScript / TypeScript**
```javascript
const text = "apple,banana,cherry,date";
const fruits = text.split(",");
console.log(fruits);  // ['apple', 'banana', 'cherry', 'date']

const joined = fruits.join(" | ");
console.log(joined);  // apple | banana | cherry | date
```

**Go**
```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    text := "apple,banana,cherry,date"
    fruits := strings.Split(text, ",")
    fmt.Println(fruits)  // [apple banana cherry date]

    joined := strings.Join(fruits, " | ")
    fmt.Println(joined)  // apple | banana | cherry | date
}
```

**Rust**
```rust
fn main() {
    let text = "apple,banana,cherry,date";
    let fruits: Vec<&str> = text.split(',').collect();
    println!("{:?}", fruits);  // ["apple", "banana", "cherry", "date"]

    let joined = fruits.join(" | ");
    println!("{}", joined);  // apple | banana | cherry | date
}
```

### 5.3 Find / Replace

**Python**
```python
text = "Hello World, Hello Rust"
new_text = text.replace("Hello", "你好")
print(new_text)  # 你好 World, 你好 Rust

index = text.find("World")
print(f"'World' 在位置: {index}")  # 'World' 在位置: 6
```

**C++**
```cpp
#include <iostream>
#include <string>

int main() {
    std::string text = "Hello World, Hello Rust";

    // Find
    size_t pos = text.find("World");
    if (pos != std::string::npos) {
        std::cout << "'World' 在位置: " << pos << std::endl;  // 6
    }

    // Replace（手動實作全部取代）
    std::string newText = text;
    std::string from = "Hello";
    std::string to = "你好";
    size_t start = 0;
    while ((start = newText.find(from, start)) != std::string::npos) {
        newText.replace(start, from.length(), to);
        start += to.length();
    }
    std::cout << newText << std::endl;  // 你好 World, 你好 Rust
    return 0;
}
```

**JavaScript / TypeScript**
```javascript
const text = "Hello World, Hello Rust";
const newText = text.replaceAll("Hello", "你好");
console.log(newText);  // 你好 World, 你好 Rust

const index = text.indexOf("World");
console.log(`'World' 在位置: ${index}`);  // 'World' 在位置: 6
```

**Go**
```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    text := "Hello World, Hello Rust"
    newText := strings.ReplaceAll(text, "Hello", "你好")
    fmt.Println(newText)  // 你好 World, 你好 Rust

    index := strings.Index(text, "World")
    fmt.Printf("'World' 在位置: %d\n", index)  // 6
}
```

**Rust**
```rust
fn main() {
    let text = "Hello World, Hello Rust";
    let new_text = text.replace("Hello", "你好");
    println!("{}", new_text);  // 你好 World, 你好 Rust

    match text.find("World") {
        Some(index) => println!("'World' 在位置: {}", index),  // 6
        None => println!("找不到"),
    }
}
```

### 5.4 格式化字串

**Python**
```python
name = "小明"
age = 25
pi = 3.14159
print(f"姓名: {name}, 年齡: {age}, 圓周率: {pi:.2f}")
# 姓名: 小明, 年齡: 25, 圓周率: 3.14
```

**C++**
```cpp
#include <iostream>
#include <format>  // C++20
// 若無 C++20，用 printf
int main() {
    const char* name = "小明";
    int age = 25;
    double pi = 3.14159;
    // C 風格
    printf("姓名: %s, 年齡: %d, 圓周率: %.2f\n", name, age, pi);
    // C++20 std::format
    // std::cout << std::format("姓名: {}, 年齡: {}, 圓周率: {:.2f}", name, age, pi);
    return 0;
}
```

**JavaScript / TypeScript**
```javascript
const name = "小明";
const age = 25;
const pi = 3.14159;
console.log(`姓名: ${name}, 年齡: ${age}, 圓周率: ${pi.toFixed(2)}`);
// 姓名: 小明, 年齡: 25, 圓周率: 3.14
```

**Go**
```go
package main

import "fmt"

func main() {
    name := "小明"
    age := 25
    pi := 3.14159
    fmt.Printf("姓名: %s, 年齡: %d, 圓周率: %.2f\n", name, age, pi)
    // 姓名: 小明, 年齡: 25, 圓周率: 3.14
}
```

**Rust**
```rust
fn main() {
    let name = "小明";
    let age = 25;
    let pi = 3.14159_f64;
    println!("姓名: {}, 年齡: {}, 圓周率: {:.2}", name, age, pi);
    // 姓名: 小明, 年齡: 25, 圓周率: 3.14
}
```

---

## Problem 6：資料結構 — Struct / Class / Object

> 定義一個「學生」，包含姓名、年齡、成績陣列，以及計算平均成績、顯示資訊的方法。

### Python

```python
class Student:
    def __init__(self, name: str, age: int, grades: list[float]):
        self.name = name
        self.age = age
        self.grades = grades

    def average(self) -> float:
        if not self.grades:
            return 0.0
        return sum(self.grades) / len(self.grades)

    def display(self):
        print(f"姓名: {self.name}, 年齡: {self.age}, "
              f"成績: {self.grades}, 平均: {self.average():.1f}")

# 使用
s = Student("小明", 20, [90.0, 85.0, 92.0, 78.0])
s.display()
# 姓名: 小明, 年齡: 20, 成績: [90.0, 85.0, 92.0, 78.0], 平均: 86.2
```

### C++

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <numeric>
#include <iomanip>

class Student {
public:
    std::string name;
    int age;
    std::vector<double> grades;

    Student(std::string name, int age, std::vector<double> grades)
        : name(std::move(name)), age(age), grades(std::move(grades)) {}

    double average() const {
        if (grades.empty()) return 0.0;
        double sum = std::accumulate(grades.begin(), grades.end(), 0.0);
        return sum / grades.size();
    }

    void display() const {
        std::cout << "姓名: " << name
                  << ", 年齡: " << age
                  << ", 成績: [";
        for (size_t i = 0; i < grades.size(); i++) {
            if (i > 0) std::cout << ", ";
            std::cout << grades[i];
        }
        std::cout << "], 平均: " << std::fixed << std::setprecision(1)
                  << average() << std::endl;
    }
};

int main() {
    Student s("小明", 20, {90.0, 85.0, 92.0, 78.0});
    s.display();
    return 0;
}
```

### JavaScript / TypeScript

```typescript
class Student {
    name: string;
    age: number;
    grades: number[];

    constructor(name: string, age: number, grades: number[]) {
        this.name = name;
        this.age = age;
        this.grades = grades;
    }

    average(): number {
        if (this.grades.length === 0) return 0;
        const sum = this.grades.reduce((acc, g) => acc + g, 0);
        return sum / this.grades.length;
    }

    display(): void {
        console.log(
            `姓名: ${this.name}, 年齡: ${this.age}, ` +
            `成績: [${this.grades.join(", ")}], 平均: ${this.average().toFixed(1)}`
        );
    }
}

const s = new Student("小明", 20, [90, 85, 92, 78]);
s.display();
```

### Go

```go
package main

import "fmt"

type Student struct {
    Name   string
    Age    int
    Grades []float64
}

func NewStudent(name string, age int, grades []float64) Student {
    return Student{Name: name, Age: age, Grades: grades}
}

func (s Student) Average() float64 {
    if len(s.Grades) == 0 {
        return 0.0
    }
    sum := 0.0
    for _, g := range s.Grades {
        sum += g
    }
    return sum / float64(len(s.Grades))
}

func (s Student) Display() {
    fmt.Printf("姓名: %s, 年齡: %d, 成績: %v, 平均: %.1f\n",
        s.Name, s.Age, s.Grades, s.Average())
}

func main() {
    s := NewStudent("小明", 20, []float64{90, 85, 92, 78})
    s.Display()
}
```

### Rust

```rust
struct Student {
    name: String,
    age: u32,
    grades: Vec<f64>,
}

impl Student {
    fn new(name: &str, age: u32, grades: Vec<f64>) -> Self {
        Student {
            name: name.to_string(),
            age,
            grades,
        }
    }

    fn average(&self) -> f64 {
        if self.grades.is_empty() {
            return 0.0;
        }
        let sum: f64 = self.grades.iter().sum();
        sum / self.grades.len() as f64
    }

    fn display(&self) {
        println!(
            "姓名: {}, 年齡: {}, 成績: {:?}, 平均: {:.1}",
            self.name, self.age, self.grades, self.average()
        );
    }
}

fn main() {
    let s = Student::new("小明", 20, vec![90.0, 85.0, 92.0, 78.0]);
    s.display();
}
```

---

## Problem 7：繼承 / 組合 / 介面

> 定義形狀 (Shape) 的抽象介面，Circle 和 Rectangle 實作 `area()` 方法，展示多型。

### Python（class 繼承）

```python
from abc import ABC, abstractmethod
import math

class Shape(ABC):
    @abstractmethod
    def area(self) -> float:
        pass

    @abstractmethod
    def describe(self) -> str:
        pass

class Circle(Shape):
    def __init__(self, radius: float):
        self.radius = radius

    def area(self) -> float:
        return math.pi * self.radius ** 2

    def describe(self) -> str:
        return f"圓形(半徑={self.radius})"

class Rectangle(Shape):
    def __init__(self, width: float, height: float):
        self.width = width
        self.height = height

    def area(self) -> float:
        return self.width * self.height

    def describe(self) -> str:
        return f"矩形({self.width}x{self.height})"

# 多型：處理不同形狀
def print_shape_info(shapes: list[Shape]):
    for shape in shapes:
        print(f"{shape.describe()} => 面積: {shape.area():.2f}")

shapes = [Circle(5), Rectangle(4, 6), Circle(3)]
print_shape_info(shapes)
# 圓形(半徑=5) => 面積: 78.54
# 矩形(4x6) => 面積: 24.00
# 圓形(半徑=3) => 面積: 28.27
```

### C++（虛擬函式）

```cpp
#include <iostream>
#include <vector>
#include <memory>
#include <cmath>
#include <iomanip>
#include <sstream>

class Shape {
public:
    virtual ~Shape() = default;
    virtual double area() const = 0;
    virtual std::string describe() const = 0;
};

class Circle : public Shape {
    double radius;
public:
    Circle(double r) : radius(r) {}

    double area() const override {
        return M_PI * radius * radius;
    }

    std::string describe() const override {
        std::ostringstream oss;
        oss << "圓形(半徑=" << radius << ")";
        return oss.str();
    }
};

class Rectangle : public Shape {
    double width, height;
public:
    Rectangle(double w, double h) : width(w), height(h) {}

    double area() const override {
        return width * height;
    }

    std::string describe() const override {
        std::ostringstream oss;
        oss << "矩形(" << width << "x" << height << ")";
        return oss.str();
    }
};

void printShapeInfo(const std::vector<std::unique_ptr<Shape>>& shapes) {
    for (const auto& shape : shapes) {
        std::cout << shape->describe() << " => 面積: "
                  << std::fixed << std::setprecision(2)
                  << shape->area() << std::endl;
    }
}

int main() {
    std::vector<std::unique_ptr<Shape>> shapes;
    shapes.push_back(std::make_unique<Circle>(5));
    shapes.push_back(std::make_unique<Rectangle>(4, 6));
    shapes.push_back(std::make_unique<Circle>(3));

    printShapeInfo(shapes);
    return 0;
}
```

### JavaScript / TypeScript（interface + class）

```typescript
interface Shape {
    area(): number;
    describe(): string;
}

class Circle implements Shape {
    constructor(private radius: number) {}

    area(): number {
        return Math.PI * this.radius ** 2;
    }

    describe(): string {
        return `圓形(半徑=${this.radius})`;
    }
}

class Rectangle implements Shape {
    constructor(private width: number, private height: number) {}

    area(): number {
        return this.width * this.height;
    }

    describe(): string {
        return `矩形(${this.width}x${this.height})`;
    }
}

function printShapeInfo(shapes: Shape[]): void {
    for (const shape of shapes) {
        console.log(`${shape.describe()} => 面積: ${shape.area().toFixed(2)}`);
    }
}

const shapes: Shape[] = [new Circle(5), new Rectangle(4, 6), new Circle(3)];
printShapeInfo(shapes);
```

### Go（隱式介面）

```go
package main

import (
    "fmt"
    "math"
)

// Go 的 interface 是隱式實作 — 不需要 implements 關鍵字
type Shape interface {
    Area() float64
    Describe() string
}

type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

func (c Circle) Describe() string {
    return fmt.Sprintf("圓形(半徑=%.0f)", c.Radius)
}

type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Describe() string {
    return fmt.Sprintf("矩形(%.0fx%.0f)", r.Width, r.Height)
}

func printShapeInfo(shapes []Shape) {
    for _, s := range shapes {
        fmt.Printf("%s => 面積: %.2f\n", s.Describe(), s.Area())
    }
}

func main() {
    shapes := []Shape{
        Circle{Radius: 5},
        Rectangle{Width: 4, Height: 6},
        Circle{Radius: 3},
    }
    printShapeInfo(shapes)
}
```

### Rust（trait）

```rust
use std::f64::consts::PI;

trait Shape {
    fn area(&self) -> f64;
    fn describe(&self) -> String;
}

struct Circle {
    radius: f64,
}

impl Shape for Circle {
    fn area(&self) -> f64 {
        PI * self.radius * self.radius
    }

    fn describe(&self) -> String {
        format!("圓形(半徑={})", self.radius)
    }
}

struct Rectangle {
    width: f64,
    height: f64,
}

impl Shape for Rectangle {
    fn area(&self) -> f64 {
        self.width * self.height
    }

    fn describe(&self) -> String {
        format!("矩形({}x{})", self.width, self.height)
    }
}

fn print_shape_info(shapes: &[Box<dyn Shape>]) {
    for shape in shapes {
        println!("{} => 面積: {:.2}", shape.describe(), shape.area());
    }
}

fn main() {
    let shapes: Vec<Box<dyn Shape>> = vec![
        Box::new(Circle { radius: 5.0 }),
        Box::new(Rectangle { width: 4.0, height: 6.0 }),
        Box::new(Circle { radius: 3.0 }),
    ];
    print_shape_info(&shapes);
}
```

### 多型機制對照表

| 項目 | Python | C++ | JS/TS | Go | Rust |
|------|--------|-----|-------|-----|------|
| 抽象定義 | `ABC` + `@abstractmethod` | 純虛擬函式 `= 0` | `interface` | `interface` | `trait` |
| 實作宣告 | 繼承 `class C(Base)` | `: public Base` | `implements` | 隱式（鴨子型別） | `impl Trait for T` |
| 多型容器 | `list[Shape]` | `vector<unique_ptr<Shape>>` | `Shape[]` | `[]Shape` | `Vec<Box<dyn Shape>>` |
| 動態派發 | 自動（所有呼叫都是動態） | `virtual` | 自動 | 自動（介面值） | `dyn Trait` |

---

## Problem 8：錯誤處理

> 實作除法函式，正確處理除以零的情況。

### Python（try / except）

```python
class DivisionError(Exception):
    pass

def safe_divide(a: float, b: float) -> float:
    if b == 0:
        raise DivisionError("除數不能為零")
    return a / b

# 使用
try:
    result = safe_divide(10, 3)
    print(f"10 / 3 = {result:.2f}")  # 10 / 3 = 3.33

    result = safe_divide(10, 0)
    print(f"不會執行到這裡")
except DivisionError as e:
    print(f"錯誤: {e}")  # 錯誤: 除數不能為零
finally:
    print("計算完畢")
```

### C++（try / catch + optional）

```cpp
#include <iostream>
#include <stdexcept>
#include <optional>

// 方式一：丟例外
double safeDivide(double a, double b) {
    if (b == 0) {
        throw std::invalid_argument("除數不能為零");
    }
    return a / b;
}

// 方式二：回傳 optional（更現代的風格）
std::optional<double> safeDivideOpt(double a, double b) {
    if (b == 0) {
        return std::nullopt;
    }
    return a / b;
}

int main() {
    // 方式一
    try {
        double result = safeDivide(10, 3);
        std::cout << "10 / 3 = " << result << std::endl;

        safeDivide(10, 0);  // 會丟例外
    } catch (const std::invalid_argument& e) {
        std::cout << "錯誤: " << e.what() << std::endl;
    }

    // 方式二
    auto result = safeDivideOpt(10, 0);
    if (result.has_value()) {
        std::cout << "結果: " << result.value() << std::endl;
    } else {
        std::cout << "除法失敗（除數為零）" << std::endl;
    }

    return 0;
}
```

### JavaScript / TypeScript（try / catch + Promise）

```typescript
// 同步版本
function safeDivide(a: number, b: number): number {
    if (b === 0) {
        throw new Error("除數不能為零");
    }
    return a / b;
}

try {
    console.log(`10 / 3 = ${safeDivide(10, 3).toFixed(2)}`);
    safeDivide(10, 0);
} catch (e) {
    if (e instanceof Error) {
        console.log(`錯誤: ${e.message}`);
    }
} finally {
    console.log("計算完畢");
}

// 非同步 Promise 版本
async function safeDivideAsync(a: number, b: number): Promise<number> {
    if (b === 0) {
        throw new Error("除數不能為零");
    }
    return a / b;
}

safeDivideAsync(10, 0)
    .then((result) => console.log(`結果: ${result}`))
    .catch((err) => console.log(`錯誤: ${err.message}`));
```

### Go（error 回傳值）

```go
package main

import (
    "errors"
    "fmt"
)

func safeDivide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("除數不能為零")
    }
    return a / b, nil
}

func main() {
    // 成功
    result, err := safeDivide(10, 3)
    if err != nil {
        fmt.Printf("錯誤: %v\n", err)
    } else {
        fmt.Printf("10 / 3 = %.2f\n", result)  // 10 / 3 = 3.33
    }

    // 失敗
    result, err = safeDivide(10, 0)
    if err != nil {
        fmt.Printf("錯誤: %v\n", err)  // 錯誤: 除數不能為零
    } else {
        fmt.Printf("結果: %.2f\n", result)
    }
}
```

### Rust（Result<T, E>）

```rust
use std::fmt;

#[derive(Debug)]
enum MathError {
    DivisionByZero,
}

impl fmt::Display for MathError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            MathError::DivisionByZero => write!(f, "除數不能為零"),
        }
    }
}

fn safe_divide(a: f64, b: f64) -> Result<f64, MathError> {
    if b == 0.0 {
        return Err(MathError::DivisionByZero);
    }
    Ok(a / b)
}

fn main() {
    // match 處理
    match safe_divide(10.0, 3.0) {
        Ok(result) => println!("10 / 3 = {:.2}", result),
        Err(e) => println!("錯誤: {}", e),
    }

    // if let 處理
    if let Err(e) = safe_divide(10.0, 0.0) {
        println!("錯誤: {}", e);  // 錯誤: 除數不能為零
    }

    // ? 運算子（在回傳 Result 的函式中使用）
    // let result = safe_divide(10.0, 3.0)?;
}
```

### 錯誤處理哲學對照

| 項目 | Python | C++ | JS/TS | Go | Rust |
|------|--------|-----|-------|-----|------|
| 主要機制 | `try/except` | `try/catch` | `try/catch` | 回傳 `error` | `Result<T,E>` |
| 哲學 | 例外驅動 | 例外或回傳值 | 例外 + Promise | 明確錯誤回傳 | 型別安全回傳 |
| 忽略錯誤 | 可以不 catch | 可以不 catch | 可以不 catch | 用 `_` 丟棄 | 必須處理（編譯器強制） |
| 傳播語法 | `raise` | `throw` | `throw` | `return err` | `?` 運算子 |

---

## Problem 9：集合操作 (Map / Dict / HashMap)

> 實作詞頻統計：輸入一段文字，統計每個單詞出現次數，按頻率排序輸出。

### Python

```python
def word_frequency(text: str) -> list[tuple[str, int]]:
    words = text.lower().split()
    freq: dict[str, int] = {}

    for word in words:
        freq[word] = freq.get(word, 0) + 1

    # 按頻率降序排列
    sorted_freq = sorted(freq.items(), key=lambda x: x[1], reverse=True)
    return sorted_freq

text = "the cat sat on the mat the cat ate the rat"
result = word_frequency(text)
for word, count in result:
    print(f"  {word}: {count}")
# the: 4
# cat: 2
# sat: 1
# on: 1
# mat: 1
# ate: 1
# rat: 1
```

### C++

```cpp
#include <iostream>
#include <string>
#include <sstream>
#include <map>
#include <vector>
#include <algorithm>

std::vector<std::pair<std::string, int>> wordFrequency(const std::string& text) {
    std::map<std::string, int> freq;
    std::istringstream iss(text);
    std::string word;

    while (iss >> word) {
        // 轉小寫
        std::transform(word.begin(), word.end(), word.begin(), ::tolower);
        freq[word]++;
    }

    // 轉為 vector 以便排序
    std::vector<std::pair<std::string, int>> sorted_freq(freq.begin(), freq.end());

    // 按頻率降序
    std::sort(sorted_freq.begin(), sorted_freq.end(),
              [](const auto& a, const auto& b) {
                  return a.second > b.second;
              });

    return sorted_freq;
}

int main() {
    std::string text = "the cat sat on the mat the cat ate the rat";
    auto result = wordFrequency(text);

    for (const auto& [word, count] : result) {
        std::cout << "  " << word << ": " << count << std::endl;
    }
    return 0;
}
```

### JavaScript / TypeScript

```typescript
function wordFrequency(text: string): [string, number][] {
    const words = text.toLowerCase().split(/\s+/);
    const freq: Map<string, number> = new Map();

    for (const word of words) {
        freq.set(word, (freq.get(word) || 0) + 1);
    }

    // 轉為陣列並排序
    const sorted = [...freq.entries()].sort((a, b) => b[1] - a[1]);
    return sorted;
}

const text = "the cat sat on the mat the cat ate the rat";
const result = wordFrequency(text);
for (const [word, count] of result) {
    console.log(`  ${word}: ${count}`);
}
```

### Go

```go
package main

import (
    "fmt"
    "sort"
    "strings"
)

type WordCount struct {
    Word  string
    Count int
}

func wordFrequency(text string) []WordCount {
    words := strings.Fields(strings.ToLower(text))
    freq := make(map[string]int)

    for _, word := range words {
        freq[word]++
    }

    // 轉為 slice 以便排序
    result := make([]WordCount, 0, len(freq))
    for word, count := range freq {
        result = append(result, WordCount{word, count})
    }

    // 按頻率降序
    sort.Slice(result, func(i, j int) bool {
        return result[i].Count > result[j].Count
    })

    return result
}

func main() {
    text := "the cat sat on the mat the cat ate the rat"
    result := wordFrequency(text)

    for _, wc := range result {
        fmt.Printf("  %s: %d\n", wc.Word, wc.Count)
    }
}
```

### Rust

```rust
use std::collections::HashMap;

fn word_frequency(text: &str) -> Vec<(String, usize)> {
    let mut freq: HashMap<String, usize> = HashMap::new();

    for word in text.to_lowercase().split_whitespace() {
        *freq.entry(word.to_string()).or_insert(0) += 1;
    }

    // 轉為 Vec 並按頻率降序排序
    let mut sorted: Vec<(String, usize)> = freq.into_iter().collect();
    sorted.sort_by(|a, b| b.1.cmp(&a.1));
    sorted
}

fn main() {
    let text = "the cat sat on the mat the cat ate the rat";
    let result = word_frequency(text);

    for (word, count) in &result {
        println!("  {}: {}", word, count);
    }
}
```

---

## Problem 10：檔案讀寫

### 10.1 寫入文字到檔案

**Python**
```python
lines = ["第一行\n", "第二行\n", "第三行\n"]

with open("output.txt", "w", encoding="utf-8") as f:
    f.writelines(lines)
print("寫入完成")
```

**C++**
```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>

int main() {
    std::vector<std::string> lines = {"第一行", "第二行", "第三行"};

    std::ofstream file("output.txt");
    if (!file.is_open()) {
        std::cerr << "無法開啟檔案" << std::endl;
        return 1;
    }

    for (const auto& line : lines) {
        file << line << "\n";
    }
    file.close();
    std::cout << "寫入完成" << std::endl;
    return 0;
}
```

**JavaScript (Node.js)**
```javascript
const fs = require("fs");

const lines = ["第一行", "第二行", "第三行"];
fs.writeFileSync("output.txt", lines.join("\n") + "\n", "utf-8");
console.log("寫入完成");

// 非同步版本
// const fsPromise = require("fs/promises");
// await fsPromise.writeFile("output.txt", lines.join("\n"), "utf-8");
```

**Go**
```go
package main

import (
    "fmt"
    "os"
    "strings"
)

func main() {
    lines := []string{"第一行", "第二行", "第三行"}
    content := strings.Join(lines, "\n") + "\n"

    err := os.WriteFile("output.txt", []byte(content), 0644)
    if err != nil {
        fmt.Printf("寫入失敗: %v\n", err)
        return
    }
    fmt.Println("寫入完成")
}
```

**Rust**
```rust
use std::fs;
use std::io::Write;

fn main() -> std::io::Result<()> {
    let lines = vec!["第一行", "第二行", "第三行"];

    let mut file = fs::File::create("output.txt")?;
    for line in &lines {
        writeln!(file, "{}", line)?;
    }

    println!("寫入完成");
    Ok(())
}
```

### 10.2 逐行讀取檔案

**Python**
```python
with open("output.txt", "r", encoding="utf-8") as f:
    for i, line in enumerate(f, 1):
        print(f"行 {i}: {line.rstrip()}")
```

**C++**
```cpp
#include <iostream>
#include <fstream>
#include <string>

int main() {
    std::ifstream file("output.txt");
    if (!file.is_open()) {
        std::cerr << "無法開啟檔案" << std::endl;
        return 1;
    }

    std::string line;
    int i = 1;
    while (std::getline(file, line)) {
        std::cout << "行 " << i++ << ": " << line << std::endl;
    }
    return 0;
}
```

**JavaScript (Node.js)**
```javascript
const fs = require("fs");

const content = fs.readFileSync("output.txt", "utf-8");
const lines = content.split("\n").filter((l) => l.length > 0);
lines.forEach((line, i) => {
    console.log(`行 ${i + 1}: ${line}`);
});
```

**Go**
```go
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    file, err := os.Open("output.txt")
    if err != nil {
        fmt.Printf("開啟失敗: %v\n", err)
        return
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)
    i := 1
    for scanner.Scan() {
        fmt.Printf("行 %d: %s\n", i, scanner.Text())
        i++
    }
}
```

**Rust**
```rust
use std::fs;
use std::io::{BufRead, BufReader};

fn main() -> std::io::Result<()> {
    let file = fs::File::open("output.txt")?;
    let reader = BufReader::new(file);

    for (i, line) in reader.lines().enumerate() {
        let line = line?;
        println!("行 {}: {}", i + 1, line);
    }
    Ok(())
}
```

### 10.3 解析 CSV 格式資料

> 假設 `data.csv` 內容為：
> ```
> name,age,score
> Alice,20,95
> Bob,22,87
> Charlie,21,92
> ```

**Python**
```python
import csv

with open("data.csv", "r", encoding="utf-8") as f:
    reader = csv.DictReader(f)
    for row in reader:
        print(f"姓名: {row['name']}, 年齡: {row['age']}, 分數: {row['score']}")
```

**C++**
```cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>

int main() {
    std::ifstream file("data.csv");
    std::string line;

    // 跳過表頭
    std::getline(file, line);

    while (std::getline(file, line)) {
        std::stringstream ss(line);
        std::string name, age_str, score_str;

        std::getline(ss, name, ',');
        std::getline(ss, age_str, ',');
        std::getline(ss, score_str, ',');

        std::cout << "姓名: " << name
                  << ", 年齡: " << age_str
                  << ", 分數: " << score_str << std::endl;
    }
    return 0;
}
```

**JavaScript (Node.js)**
```javascript
const fs = require("fs");

const content = fs.readFileSync("data.csv", "utf-8");
const lines = content.trim().split("\n");
const headers = lines[0].split(",");

for (let i = 1; i < lines.length; i++) {
    const values = lines[i].split(",");
    const row = {};
    headers.forEach((h, idx) => (row[h] = values[idx]));
    console.log(`姓名: ${row.name}, 年齡: ${row.age}, 分數: ${row.score}`);
}
```

**Go**
```go
package main

import (
    "encoding/csv"
    "fmt"
    "os"
)

func main() {
    file, err := os.Open("data.csv")
    if err != nil {
        fmt.Println(err)
        return
    }
    defer file.Close()

    reader := csv.NewReader(file)
    records, err := reader.ReadAll()
    if err != nil {
        fmt.Println(err)
        return
    }

    // records[0] 是表頭
    for _, row := range records[1:] {
        fmt.Printf("姓名: %s, 年齡: %s, 分數: %s\n", row[0], row[1], row[2])
    }
}
```

**Rust**
```rust
use std::fs;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let content = fs::read_to_string("data.csv")?;
    let mut lines = content.lines();

    // 跳過表頭
    lines.next();

    for line in lines {
        let fields: Vec<&str> = line.split(',').collect();
        if fields.len() >= 3 {
            println!("姓名: {}, 年齡: {}, 分數: {}", fields[0], fields[1], fields[2]);
        }
    }

    Ok(())
}
```

---

## Problem 11：並發 / 非同步

> 同時發起多個任務，等待全部完成，收集結果。

### Python（asyncio + threading）

```python
import asyncio
import time

# === asyncio 版本 ===
async def fetch_data(task_id: int) -> str:
    print(f"任務 {task_id} 開始")
    await asyncio.sleep(1)  # 模擬 I/O
    return f"任務 {task_id} 的結果"

async def main_async():
    tasks = [fetch_data(i) for i in range(1, 6)]
    results = await asyncio.gather(*tasks)
    for r in results:
        print(r)

print("=== asyncio ===")
start = time.time()
asyncio.run(main_async())
print(f"耗時: {time.time() - start:.2f}s")  # ~1s（並發）

# === threading 版本 ===
import threading

def fetch_data_thread(task_id: int, results: dict):
    time.sleep(1)
    results[task_id] = f"任務 {task_id} 的結果"

print("\n=== threading ===")
start = time.time()
results = {}
threads = []
for i in range(1, 6):
    t = threading.Thread(target=fetch_data_thread, args=(i, results))
    threads.append(t)
    t.start()

for t in threads:
    t.join()

for task_id in sorted(results.keys()):
    print(results[task_id])
print(f"耗時: {time.time() - start:.2f}s")  # ~1s（並行）
```

### C++（std::thread）

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <string>
#include <mutex>
#include <chrono>

std::mutex mtx;

void fetchData(int taskId, std::vector<std::string>& results) {
    std::this_thread::sleep_for(std::chrono::seconds(1));

    std::lock_guard<std::mutex> lock(mtx);
    results.push_back("任務 " + std::to_string(taskId) + " 的結果");
}

int main() {
    auto start = std::chrono::high_resolution_clock::now();

    std::vector<std::string> results;
    std::vector<std::thread> threads;

    for (int i = 1; i <= 5; i++) {
        threads.emplace_back(fetchData, i, std::ref(results));
    }

    for (auto& t : threads) {
        t.join();
    }

    for (const auto& r : results) {
        std::cout << r << std::endl;
    }

    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed = end - start;
    std::cout << "耗時: " << elapsed.count() << "s" << std::endl;
    return 0;
}
```

### JavaScript / TypeScript（Promise.all）

```typescript
async function fetchData(taskId: number): Promise<string> {
    console.log(`任務 ${taskId} 開始`);
    await new Promise((resolve) => setTimeout(resolve, 1000));
    return `任務 ${taskId} 的結果`;
}

async function main() {
    const start = Date.now();

    const promises = Array.from({ length: 5 }, (_, i) => fetchData(i + 1));
    const results = await Promise.all(promises);

    for (const r of results) {
        console.log(r);
    }

    console.log(`耗時: ${((Date.now() - start) / 1000).toFixed(2)}s`);
}

main();
```

### Go（goroutine + channel）

```go
package main

import (
    "fmt"
    "time"
)

func fetchData(taskId int, ch chan<- string) {
    time.Sleep(1 * time.Second)
    ch <- fmt.Sprintf("任務 %d 的結果", taskId)
}

func main() {
    start := time.Now()

    ch := make(chan string, 5)

    for i := 1; i <= 5; i++ {
        go fetchData(i, ch)
    }

    // 收集結果
    for i := 0; i < 5; i++ {
        result := <-ch
        fmt.Println(result)
    }

    elapsed := time.Since(start)
    fmt.Printf("耗時: %.2fs\n", elapsed.Seconds())
}
```

### Rust（std::thread）

```rust
use std::thread;
use std::time::{Duration, Instant};

fn fetch_data(task_id: i32) -> String {
    thread::sleep(Duration::from_secs(1));
    format!("任務 {} 的結果", task_id)
}

fn main() {
    let start = Instant::now();

    let handles: Vec<_> = (1..=5)
        .map(|i| {
            thread::spawn(move || fetch_data(i))
        })
        .collect();

    let results: Vec<String> = handles
        .into_iter()
        .map(|h| h.join().unwrap())
        .collect();

    for r in &results {
        println!("{}", r);
    }

    let elapsed = start.elapsed();
    println!("耗時: {:.2?}", elapsed);
}
```

### 並發模型對照表

| 項目 | Python | C++ | JS/TS | Go | Rust |
|------|--------|-----|-------|-----|------|
| 並發原語 | `asyncio` / `threading` | `std::thread` | `Promise` / `async` | goroutine | `std::thread` |
| 等待全部 | `gather()` / `join()` | `join()` | `Promise.all()` | channel 讀取 | `join()` |
| 共享狀態 | `Lock` | `std::mutex` | 單執行緒（無需） | channel / `sync.Mutex` | `Arc<Mutex<T>>` |
| 特色 | GIL 限制真並行 | 完整多執行緒 | 事件迴圈（非真並行） | 輕量級 goroutine | 編譯期安全保證 |

---

## Problem 12：JSON 處理

> 定義一個結構，序列化為 JSON 字串，再反序列化回來。

### Python

```python
import json
from dataclasses import dataclass, asdict

@dataclass
class User:
    name: str
    age: int
    email: str
    active: bool

# 建立物件
user = User(name="小明", age=25, email="ming@example.com", active=True)

# 序列化
json_str = json.dumps(asdict(user), ensure_ascii=False, indent=2)
print("JSON:")
print(json_str)

# 反序列化
data = json.loads(json_str)
user2 = User(**data)
print(f"\n還原: {user2}")
print(f"姓名: {user2.name}, 年齡: {user2.age}")
```

### C++（使用 nlohmann/json）

```cpp
#include <iostream>
#include <string>
#include <nlohmann/json.hpp>  // 需安裝: vcpkg install nlohmann-json

using json = nlohmann::json;

struct User {
    std::string name;
    int age;
    std::string email;
    bool active;
};

// 序列化/反序列化定義
void to_json(json& j, const User& u) {
    j = json{
        {"name", u.name},
        {"age", u.age},
        {"email", u.email},
        {"active", u.active}
    };
}

void from_json(const json& j, User& u) {
    j.at("name").get_to(u.name);
    j.at("age").get_to(u.age);
    j.at("email").get_to(u.email);
    j.at("active").get_to(u.active);
}

int main() {
    User user{"小明", 25, "ming@example.com", true};

    // 序列化
    json j = user;
    std::string json_str = j.dump(2);
    std::cout << "JSON:\n" << json_str << std::endl;

    // 反序列化
    auto user2 = json::parse(json_str).get<User>();
    std::cout << "\n還原 — 姓名: " << user2.name
              << ", 年齡: " << user2.age << std::endl;
    return 0;
}
```

### JavaScript / TypeScript

```typescript
interface User {
    name: string;
    age: number;
    email: string;
    active: boolean;
}

// 建立物件
const user: User = {
    name: "小明",
    age: 25,
    email: "ming@example.com",
    active: true,
};

// 序列化
const jsonStr = JSON.stringify(user, null, 2);
console.log("JSON:");
console.log(jsonStr);

// 反序列化
const user2: User = JSON.parse(jsonStr);
console.log(`\n還原 — 姓名: ${user2.name}, 年齡: ${user2.age}`);
```

### Go

```go
package main

import (
    "encoding/json"
    "fmt"
)

type User struct {
    Name   string `json:"name"`
    Age    int    `json:"age"`
    Email  string `json:"email"`
    Active bool   `json:"active"`
}

func main() {
    user := User{
        Name:   "小明",
        Age:    25,
        Email:  "ming@example.com",
        Active: true,
    }

    // 序列化
    jsonBytes, err := json.MarshalIndent(user, "", "  ")
    if err != nil {
        fmt.Println(err)
        return
    }
    jsonStr := string(jsonBytes)
    fmt.Println("JSON:")
    fmt.Println(jsonStr)

    // 反序列化
    var user2 User
    err = json.Unmarshal([]byte(jsonStr), &user2)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Printf("\n還原 — 姓名: %s, 年齡: %d\n", user2.Name, user2.Age)
}
```

### Rust（使用 serde）

```rust
// Cargo.toml 需加入:
// [dependencies]
// serde = { version = "1", features = ["derive"] }
// serde_json = "1"

use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct User {
    name: String,
    age: u32,
    email: String,
    active: bool,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let user = User {
        name: "小明".to_string(),
        age: 25,
        email: "ming@example.com".to_string(),
        active: true,
    };

    // 序列化
    let json_str = serde_json::to_string_pretty(&user)?;
    println!("JSON:\n{}", json_str);

    // 反序列化
    let user2: User = serde_json::from_str(&json_str)?;
    println!("\n還原 — 姓名: {}, 年齡: {}", user2.name, user2.age);

    Ok(())
}
```

### JSON 處理對照表

| 項目 | Python | C++ | JS/TS | Go | Rust |
|------|--------|-----|-------|-----|------|
| 內建支援 | `json` 標準庫 | 無（需第三方） | 原生 `JSON` | `encoding/json` | 無（用 serde） |
| 序列化 | `json.dumps()` | `j.dump()` | `JSON.stringify()` | `json.Marshal()` | `serde_json::to_string()` |
| 反序列化 | `json.loads()` | `json::parse()` | `JSON.parse()` | `json.Unmarshal()` | `serde_json::from_str()` |
| 欄位映射 | dict 鍵名 | 手動函式 | 自動 | struct tag | `#[derive(Serialize)]` |

---

## 附錄：語法速查對照表

> 這張表格涵蓋五種語言最常見的語法，可以當作日常快速參考。

### A.1 變數宣告

| 動作 | Python | C++ | JS/TS | Go | Rust |
|------|--------|-----|-------|-----|------|
| 不可變 | `x = 5` | `const int x = 5;` | `const x = 5;` | `x := 5`（預設） | `let x = 5;` |
| 可變 | `x = 5` (全可變) | `int x = 5;` | `let x = 5;` | `x := 5` | `let mut x = 5;` |
| 型別標注 | `x: int = 5` | `int x = 5;` | `x: number = 5` | `var x int = 5` | `let x: i32 = 5;` |
| 型別推導 | 自動 | `auto x = 5;` | 自動 | `:=` 簡寫 | 自動 |
| 常數 | `PI = 3.14`（慣例大寫） | `constexpr auto PI = 3.14;` | `const PI = 3.14;` | `const Pi = 3.14` | `const PI: f64 = 3.14;` |

### A.2 函式定義

| 動作 | Python | C++ | JS/TS | Go | Rust |
|------|--------|-----|-------|-----|------|
| 基本 | `def f(x):` | `int f(int x) {}` | `function f(x) {}` | `func f(x int) int {}` | `fn f(x: i32) -> i32 {}` |
| 無回傳 | `def f():` | `void f() {}` | `function f(): void {}` | `func f() {}` | `fn f() {}` |
| 預設參數 | `def f(x=5):` | `int f(int x=5) {}` | `function f(x=5) {}` | 無原生支援 | 無原生支援 |
| Lambda | `lambda x: x+1` | `[](int x){return x+1;}` | `(x) => x+1` | `func(x int) int {return x+1}` | `\|x\| x+1` |
| 多回傳 | `return a, b` | `tuple<A,B>` | `return [a, b]` | `return a, b` | `(a, b)` |

### A.3 Class / Struct 定義

| 動作 | Python | C++ | JS/TS | Go | Rust |
|------|--------|-----|-------|-----|------|
| 定義 | `class Foo:` | `class Foo {};` | `class Foo {}` | `type Foo struct {}` | `struct Foo {}` |
| 建構子 | `__init__(self)` | `Foo() {}` | `constructor()` | `NewFoo()` 函式 | `Foo::new()` |
| 方法 | `def m(self):` | `void m() {}` | `m() {}` | `func (f Foo) M()` | `impl Foo { fn m(&self) }` |
| 繼承 | `class B(A):` | `class B : public A` | `class B extends A` | 嵌入（組合） | 無（用 trait） |
| 介面 | `ABC` + `@abstractmethod` | 純虛擬函式 | `interface` | `interface` | `trait` |

### A.4 迴圈語法

| 動作 | Python | C++ | JS/TS | Go | Rust |
|------|--------|-----|-------|-----|------|
| for 範圍 | `for i in range(n):` | `for (int i=0;i<n;i++)` | `for (let i=0;i<n;i++)` | `for i:=0;i<n;i++` | `for i in 0..n` |
| for-each | `for x in list:` | `for (auto x : vec)` | `for (const x of arr)` | `for _, x := range sl` | `for x in &vec` |
| while | `while cond:` | `while (cond) {}` | `while (cond) {}` | `for cond {}` | `while cond {}` |
| 無限迴圈 | `while True:` | `while (true) {}` | `while (true) {}` | `for {}` | `loop {}` |
| break | `break` | `break;` | `break;` | `break` | `break` |
| continue | `continue` | `continue;` | `continue;` | `continue` | `continue` |

### A.5 錯誤處理

| 動作 | Python | C++ | JS/TS | Go | Rust |
|------|--------|-----|-------|-----|------|
| 捕獲 | `try/except` | `try/catch` | `try/catch` | `if err != nil` | `match / if let` |
| 丟出 | `raise Error()` | `throw Error()` | `throw new Error()` | `errors.New()` | `Err(e)` |
| 自訂錯誤 | `class MyErr(Exception)` | `class MyErr : public exception` | `class MyErr extends Error` | 實作 `Error()` 介面 | `impl std::error::Error` |
| 傳播 | `raise` | `throw;` | `throw` | `return err` | `?` 運算子 |
| 清理 | `finally` | RAII / 解構子 | `finally` | `defer` | `Drop` trait |

### A.6 Import / 模組系統

| 動作 | Python | C++ | JS/TS | Go | Rust |
|------|--------|-----|-------|-----|------|
| 引入模組 | `import os` | `#include <iostream>` | `import fs from 'fs'` | `import "fmt"` | `use std::fs;` |
| 部分引入 | `from os import path` | `using std::cout;` | `import { x } from 'm'` | 無（用 `.` 存取） | `use std::io::Read;` |
| 別名 | `import numpy as np` | `namespace fs = std::filesystem;` | `import * as fs from 'fs'` | `import f "fmt"` | `use std::io as sio;` |
| 套件管理 | `pip` / `poetry` | `vcpkg` / `conan` | `npm` / `yarn` | `go mod` | `cargo` |

### A.7 型別系統

| 項目 | Python | C++ | JS/TS | Go | Rust |
|------|--------|-----|-------|-----|------|
| 系統 | 動態強型別 | 靜態強型別 | 動態弱型別(JS) / 靜態(TS) | 靜態強型別 | 靜態強型別 |
| 整數 | `int` | `int/long/int32_t` | `number` | `int/int32/int64` | `i32/i64/usize` |
| 浮點 | `float` | `float/double` | `number` | `float32/float64` | `f32/f64` |
| 字串 | `str` | `std::string` | `string` | `string` | `String / &str` |
| 布林 | `bool` | `bool` | `boolean` | `bool` | `bool` |
| 陣列 | `list` | `vector<T>` | `T[]` | `[]T`（slice） | `Vec<T>` |
| 字典 | `dict` | `map<K,V>` | `Map<K,V>` / `{}` | `map[K]V` | `HashMap<K,V>` |
| 泛型 | 3.12+ `T` | `template<typename T>` | `<T>` | `[T any]` | `<T>` |

### A.8 Null / None / Nil 處理

| 項目 | Python | C++ | JS/TS | Go | Rust |
|------|--------|-----|-------|-----|------|
| 空值 | `None` | `nullptr` | `null / undefined` | `nil` | **沒有 null** |
| 檢查 | `if x is None:` | `if (x == nullptr)` | `if (x == null)` | `if x == nil` | `Option<T>` |
| 安全存取 | `x if x else default` | `std::optional<T>` | `x?.prop ?? default` | 手動檢查 | `x.unwrap_or(default)` |
| 哲學 | 允許 None | 指標可為空 | 允許 null | 零值 | 編譯期消除 null |

### A.9 字串格式化

| 方式 | Python | C++ | JS/TS | Go | Rust |
|------|--------|-----|-------|-----|------|
| 插值 | `f"x={x}"` | C++20 `std::format` | `` `x=${x}` `` | `fmt.Sprintf("x=%d",x)` | `format!("x={}",x)` |
| C 風格 | `"x=%d" % x` | `printf("x=%d",x)` | 無原生 | `fmt.Printf("x=%d",x)` | 無（用 format!） |
| 連接 | `a + b` | `a + b` | `a + b` | `a + b` | `format!("{}{}", a, b)` |

### A.10 陣列 / List 常見操作

| 操作 | Python | C++ | JS/TS | Go | Rust |
|------|--------|-----|-------|-----|------|
| 建立 | `[1,2,3]` | `{1,2,3}` | `[1,2,3]` | `[]int{1,2,3}` | `vec![1,2,3]` |
| 取值 | `a[0]` | `a[0]` | `a[0]` | `a[0]` | `a[0]` |
| 長度 | `len(a)` | `a.size()` | `a.length` | `len(a)` | `a.len()` |
| 新增 | `a.append(4)` | `a.push_back(4)` | `a.push(4)` | `a = append(a,4)` | `a.push(4)` |
| 切片 | `a[1:3]` | 迭代器 | `a.slice(1,3)` | `a[1:3]` | `&a[1..3]` |
| 排序 | `a.sort()` | `sort(begin,end)` | `a.sort()` | `sort.Ints(a)` | `a.sort()` |
| 反轉 | `a.reverse()` | `reverse(begin,end)` | `a.reverse()` | 手動交換 | `a.reverse()` |
| 是否包含 | `x in a` | `find(begin,end,x)` | `a.includes(x)` | 手動迴圈 | `a.contains(&x)` |

### A.11 Dict / Map 常見操作

| 操作 | Python | C++ | JS/TS | Go | Rust |
|------|--------|-----|-------|-----|------|
| 建立 | `{"a":1}` | `map<string,int>` | `new Map()` / `{}` | `map[string]int{}` | `HashMap::new()` |
| 取值 | `d["a"]` | `d["a"]` | `d.get("a")` / `d.a` | `d["a"]` | `d.get("a")` |
| 設值 | `d["b"]=2` | `d["b"]=2;` | `d.set("b",2)` | `d["b"]=2` | `d.insert("b",2);` |
| 刪除 | `del d["a"]` | `d.erase("a");` | `d.delete("a")` | `delete(d,"a")` | `d.remove("a");` |
| 是否存在 | `"a" in d` | `d.count("a")` | `d.has("a")` | `_, ok := d["a"]` | `d.contains_key("a")` |
| 遍歷 | `for k,v in d.items():` | `for (auto& [k,v]:d)` | `for (const [k,v] of d)` | `for k,v := range d` | `for (k,v) in &d` |

### A.12 印出 / 輸出

| 動作 | Python | C++ | JS/TS | Go | Rust |
|------|--------|-----|-------|-----|------|
| 換行印出 | `print(x)` | `cout << x << endl;` | `console.log(x)` | `fmt.Println(x)` | `println!("{}", x)` |
| 不換行 | `print(x, end="")` | `cout << x;` | `process.stdout.write(x)` | `fmt.Print(x)` | `print!("{}", x)` |
| 格式化 | `print(f"{x:.2f}")` | `printf("%.2f", x);` | `console.log(x.toFixed(2))` | `fmt.Printf("%.2f", x)` | `println!("{:.2}", x)` |
| 除錯印出 | `print(repr(x))` | 無內建 | `console.dir(x)` | `fmt.Printf("%+v", x)` | `println!("{:?}", x)` |

---

## 總結：如何選擇語言？

| 場景 | 推薦語言 | 原因 |
|------|----------|------|
| 快速原型 / 資料分析 | **Python** | 語法簡潔，生態豐富 |
| 高效能系統 / GPU 程式 | **C++** | 零成本抽象，CUDA 原生支援 |
| 網頁全端 / 前後端 | **JS/TS** | 瀏覽器唯一語言，Node.js 後端 |
| 高並發服務 / 微服務 | **Go** | goroutine 天生並發，編譯快 |
| 安全系統 / WebAssembly | **Rust** | 所有權模型消除記憶體錯誤 |

> **學習建議**：先精通一門語言，再用本篇對照表橫向擴展。
> 理解「概念」比「語法」更重要 — 所有語言都在解決相同的問題，只是表達方式不同。
