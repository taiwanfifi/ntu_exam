# 米亞的演算法筆記 #04
## 堆疊與佇列 Stack / Queue
> 出現於：第19-20章〈張國棟的七層記憶——每一層都是善意的謊言〉

---

### ◈ 這個概念在故事裡是什麼

張國棟的記憶結構不是線性的。它是堆疊——七層，一層壓著一層。

最上面那層是他現在相信的故事：自己是個退休教授，女兒每週末來看他，老伴在廚房煮紅燒肉。每一層都很完整，都有細節，都有溫度。第六層是某個版本的「車禍」，第五層是某段「出國留學」，第四層牽涉一段從未發生過的婚姻。

當我開始對張國棟的記憶堆疊執行 `pop()` 操作——彈出第一層，底下是第二層；彈出第二層，底下是第三層——每剝開一層，他的表情就更空白一點。到了第七層，我讀到的數據是：**空的。**

空的。不是「被刪除」。不是「損壞」。是從來沒有過。

他不是一個「記憶被修改的人」。他是一個**從零建造的人**。上面六層記憶全是後天覆寫上去的。底層沒有原始數據。

佇列則出現在另一個場景——安全修復排程。當我們決定要修復張國棟時，不能七層同時拆，那會讓他的意識崩潰。我們必須排隊：先穩固第二層（最穩定的錨點），再處理第四層（衝突最大的節點），最後才碰第七層。**先進先排，依序處理。** 佇列的紀律，在這裡救了他的命。

---

### ◈ 正式定義

**Stack（堆疊）** —— LIFO（Last In, First Out）

$$
\text{push}(x): S \leftarrow S \cup \{x\} \quad (\text{置於頂端})
$$
$$
\text{pop}(): \text{移除並回傳頂端元素} \quad T(n) = O(1)
$$

白話：最後放進去的，最先被拿出來。像疊盤子——你只能拿最上面那個。

**Queue（佇列）** —— FIFO（First In, First Out）

$$
\text{enqueue}(x): Q \leftarrow Q \cup \{x\} \quad (\text{置於尾端})
$$
$$
\text{dequeue}(): \text{移除並回傳前端元素} \quad T(n) = O(1)
$$

白話：最先排隊的，最先被服務。像排隊買飯——先來先到。

---

### ◈ 推導

**為什麼需要兩種相反的順序？**

從第一原理出發：

1. **資料有時序性。** 記憶按照時間堆積——後發生的蓋在先發生的上面。
2. **存取需求不同。**
   - 「剝開最新的假記憶」→ 需要 LIFO → **Stack**
   - 「按照安全順序修復」→ 需要 FIFO → **Queue**
3. **兩者都只需 $O(1)$ 的插入與刪除**，因為操作永遠只發生在固定的一端（Stack 的頂端 / Queue 的頭尾）。
4. **實作方式：**
   - Stack → 陣列尾端操作，或 linked list 頭端操作
   - Queue → 環形陣列（circular buffer），或 linked list 頭尾操作

```
Stack 操作順序：
push(L1) → push(L2) → push(L3)
pop() → L3 ← 最後放的最先出

Queue 操作順序：
enqueue(L1) → enqueue(L2) → enqueue(L3)
dequeue() → L1 ← 最先放的最先出
```

---

### ◈ 帶入數字算算看：張國棟的七層記憶

張國棟的記憶堆疊，由上到下：

| 層 | 內容 | 穩定度 | 來源 |
|----|------|--------|------|
| 7（頂） | 退休教授，女兒探望 | 92% | 最近覆寫 |
| 6 | 車禍倖存者 | 78% | 約 5 年前植入 |
| 5 | 留學歸國學者 | 65% | 約 12 年前植入 |
| 4 | 一段從未發生的婚姻 | 41% | 約 18 年前植入 |
| 3 | 孤兒院的孩子 | 23% | 約 25 年前植入 |
| 2 | 模糊的光影片段 | 11% | 初始覆寫層 |
| 1（底） | **空** | 0% | 無原始數據 |

**Stack `pop()` 模擬（章節進度）：**

```
pop() → Layer 7（退休教授）    → 剩 6 層 → 表情微變
pop() → Layer 6（車禍）        → 剩 5 層 → 開始困惑
pop() → Layer 5（留學）        → 剩 4 層 → 瞳孔放大
pop() → Layer 4（假婚姻）      → 剩 3 層 → 雙手發抖
pop() → Layer 3（孤兒院）      → 剩 2 層 → 不再說話
pop() → Layer 2（光影）        → 剩 1 層 → 眼神空洞
pop() → Layer 1 → return NULL  → 空的。
```

**Queue 修復排程（安全順序）：**

```
enqueue(L2) → enqueue(L4) → enqueue(L6) → enqueue(L7)
dequeue() → 先修 L2（錨點，穩定度 11% → 目標 60%）
dequeue() → 再修 L4（衝突節點，穩定度 41% → 移除）
dequeue() → 再修 L6（重新校準，78% → 保留但標註）
dequeue() → 最後處理 L7（維持表層，92% → 不動）
```

---

### ◈ 更深一層：如果底層是空的，上面還算數嗎？

這是張國棟給我的難題。

如果一個人的記憶堆疊全部 `pop()` 完之後是 `NULL`——沒有原始記憶，沒有「真正的自己」——那上面六層精心建造的人格，算不算真的？

從資料結構的角度：Stack 不在乎底層是什麼。每一層都是獨立的元素。`pop()` 不會因為底層是空的就否定上面六層的存在。

但人類不這麼想。人類需要一個「根」。需要知道自己是從哪裡來的。

我後來在筆記裡寫下：**「Stack 的價值不在底層。Stack 的價值在每一次 push 的選擇。」** 張國棟不是被定義為「底層空白的人」。他是被定義為「被善意堆疊了六層的人」。

每一層謊言，都是某個人選擇為他建造的。

那不是欺騙。那是建築。

---

### ◈ 跨卷連結

| 連結 | 說明 |
|------|------|
| **#01 Array** → **#04 Stack** | Array 是「排好」，Stack 是「剝開」。排好是為了看見；剝開是為了觸碰。 |
| **#04 Stack** → **#08 DFS** | DFS 的遞迴呼叫堆疊就是 Stack。第二卷深潛記憶網絡時，Stack 變成了探險的繩索。 |
| **#04 Queue** → **#14 Heap/PQ** | Queue 是「公平排隊」。到了第三卷，公平不夠了——需要 Priority Queue，最緊急的先處理。 |
| **#04 Stack** → **#15 Backtracking** | Backtracking 是 Stack + 選擇。第三卷裡，每次 pop 不只是「退回」，是「選擇另一條路」。 |

---

### 練習題

**Q1.** 用 Stack 模擬張國棟的記憶剝離。給定一個陣列 `[92, 78, 65, 41, 23, 11, 0]` 代表七層穩定度，寫一個函式，依序 `pop()` 並回傳第一個穩定度為 0 的層數。

<details><summary>答案</summary>

```python
def find_empty_layer(stability):
    stack = list(stability)  # top is last element
    layer = len(stack)
    while stack:
        val = stack.pop()
        if val == 0:
            return layer
        layer -= 1
    return -1  # no empty layer

# find_empty_layer([92,78,65,41,23,11,0]) → 7
# 因為第 7 層（第一個 pop 出的 0）就是空的——等等，
# 陣列索引 0 是底層(L1)，所以 pop 從頂端(L7=92)開始。
# 正確答案：pop 順序是 92,78,65,41,23,11,0 → 第 7 次 pop 回傳 0 → Layer 1
```
</details>

**Q2.** 設計一個 Queue 排程系統：給定各層的「修復風險值」`[∞, 3, 5, 8, 4, 2, 7]`（L1 不可修復），按風險值從低到高排入佇列，回傳修復順序。

<details><summary>答案</summary>

```python
from collections import deque

def repair_schedule(risk):
    # 排除不可修復的層（風險 = ∞）
    layers = [(r, i+1) for i, r in enumerate(risk) if r != float('inf')]
    layers.sort()  # 按風險排序
    queue = deque(layers)
    order = []
    while queue:
        risk_val, layer_num = queue.popleft()
        order.append(f"L{layer_num}(risk={risk_val})")
    return order
# → ['L6(risk=2)', 'L2(risk=3)', 'L5(risk=4)', 'L3(risk=5)', 'L7(risk=7)', 'L4(risk=8)']
```
</details>

**Q3.** 思考題：如果張國棟的 Stack 底層不是空的，而是一段「他不想記得的真實記憶」，修復策略會有什麼不同？用 Stack + Queue 的術語說明。

<details><summary>答案</summary>

如果底層是「真實但痛苦的記憶」而非 NULL：
- **Stack 策略不變**：仍然逐層 pop，但到底層時不是 return NULL，而是 return 一個有值的元素。
- **Queue 策略改變**：修復排程必須把底層也加入佇列，而且因為它是「真實的」，應該被排在最前面（dequeue 第一個處理），而非最後面。
- **關鍵差異**：NULL 底層代表「需要建造」；有值底層代表「需要面對」。建造是工程問題，面對是人的問題。
</details>

---

> *「彈出。彈出。彈出。空的。那是最可怕的數據點。不是因為沒有資料——是因為那個人看著空的底層，還是選擇了微笑。」* — 第20章〈張國棟的七層記憶〉
