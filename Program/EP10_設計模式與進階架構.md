# EP10 — 設計模式與進階架構（系列完結篇）

> **對象**：已完成 EP01–EP09 的開發者，準備進入 production-level 開發
> **核心觀念**：設計模式、架構思維、系統設計、程式碼品質
> **語言**：Python 為主，搭配 TypeScript / Go / Rust / JavaScript

---

## 目錄

| 章 | 主題 | 重點 |
|----|------|------|
| 1 | SOLID 原則 | 五大設計原則完整解析 |
| 2 | 創建型模式 | Singleton、Factory、Builder |
| 3 | 結構型模式 | Adapter、Decorator、Facade |
| 4 | 行為型模式 | Observer、Strategy、State Machine、Command |
| 5 | 架構模式 | MVC/MVP/MVVM、微服務、Event-Driven |
| 6 | 函式式程式設計 | 純函式、不可變性、Monad |
| 7 | 並發模式 | Producer-Consumer、Worker Pool、Async |
| 8 | 資料結構與演算法精要 | 複雜度、排序、搜尋、DP |
| 9 | 系統設計入門 | 負載均衡、快取、分散式 |
| 10 | 程式碼品質 | Clean Code、重構、技術債 |
| 11 | 開發者工具箱 | IDE、Terminal、測試、文件 |
| 12 | 學習路線圖 | 初級→專家，NVIDIA 特別路線 |

---

## 1. SOLID 原則

SOLID 是五個物件導向設計原則的首字母縮寫，由 Robert C. Martin 提出。
掌握 SOLID 是寫出可維護、可擴展程式碼的基石。

### 1.1 S — Single Responsibility（單一職責原則）

> 一個類別應該只有一個改變的理由。

**反面範例** — 一個類別做太多事：

```python
# 反面: User 類別同時負責資料管理、驗證、持久化
class User:
    def __init__(self, name: str, email: str):
        self.name = name
        self.email = email

    def validate(self) -> bool:
        return "@" in self.email and len(self.name) > 0

    def save_to_database(self):
        print(f"INSERT INTO users VALUES ('{self.name}', '{self.email}')")

    def send_welcome_email(self):
        print(f"寄送歡迎信到 {self.email}")
```

**正面範例** — 拆分職責：

```python
from dataclasses import dataclass

@dataclass
class User:
    """只負責存放使用者資料"""
    name: str
    email: str

class UserValidator:
    """只負責驗證"""
    @staticmethod
    def validate(user: User) -> bool:
        return "@" in user.email and len(user.name) > 0

class UserRepository:
    """只負責持久化"""
    def save(self, user: User) -> None:
        print(f"INSERT INTO users VALUES ('{user.name}', '{user.email}')")

class EmailService:
    """只負責寄信"""
    def send_welcome(self, user: User) -> None:
        print(f"寄送歡迎信到 {user.email}")

# 使用
user = User("Alice", "alice@example.com")
if UserValidator.validate(user):
    UserRepository().save(user)
    EmailService().send_welcome(user)
```

### 1.2 O — Open/Closed（開放封閉原則）

> 對擴展開放，對修改封閉。新增功能不應修改既有程式碼。

**反面範例** — 每新增一種形狀就得改 `area_calculator`：

```python
# 反面: 每加一種形狀都要修改這個函式
def area_calculator(shape_type: str, **kwargs) -> float:
    if shape_type == "circle":
        return 3.14159 * kwargs["radius"] ** 2
    elif shape_type == "rectangle":
        return kwargs["width"] * kwargs["height"]
    # 每次加新形狀都要改這裡...
    else:
        raise ValueError(f"不支援: {shape_type}")
```

**正面範例** — 用抽象類別，新增形狀只需新增子類別：

```python
from abc import ABC, abstractmethod
import math

class Shape(ABC):
    @abstractmethod
    def area(self) -> float:
        pass

class Circle(Shape):
    def __init__(self, radius: float):
        self.radius = radius

    def area(self) -> float:
        return math.pi * self.radius ** 2

class Rectangle(Shape):
    def __init__(self, width: float, height: float):
        self.width = width
        self.height = height

    def area(self) -> float:
        return self.width * self.height

# 新增三角形 — 不需修改任何既有程式碼
class Triangle(Shape):
    def __init__(self, base: float, height: float):
        self.base = base
        self.height = height

    def area(self) -> float:
        return 0.5 * self.base * self.height

def total_area(shapes: list[Shape]) -> float:
    return sum(s.area() for s in shapes)

shapes = [Circle(5), Rectangle(3, 4), Triangle(6, 8)]
print(f"總面積: {total_area(shapes):.2f}")  # 總面積: 102.54
```

### 1.3 L — Liskov Substitution（里氏替換原則）

> 子類別必須能替換父類別，且程式行為不變。

**反面範例** — 正方形繼承長方形，但行為不一致：

```python
# 反面: Square 繼承 Rectangle 但違反預期行為
class Rectangle:
    def __init__(self, width: float, height: float):
        self._width = width
        self._height = height

    def set_width(self, w: float):
        self._width = w

    def set_height(self, h: float):
        self._height = h

    def area(self) -> float:
        return self._width * self._height

class Square(Rectangle):
    def set_width(self, w: float):
        self._width = w
        self._height = w  # 正方形強制等寬等高

    def set_height(self, h: float):
        self._width = h
        self._height = h

# 使用者預期 Rectangle 的行為
def test_rectangle(rect: Rectangle):
    rect.set_width(5)
    rect.set_height(4)
    assert rect.area() == 20  # Square 會失敗！area = 16
```

**正面範例** — 用共同抽象避免繼承陷阱：

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self) -> float:
        pass

class Rectangle(Shape):
    def __init__(self, width: float, height: float):
        self.width = width
        self.height = height

    def area(self) -> float:
        return self.width * self.height

class Square(Shape):
    def __init__(self, side: float):
        self.side = side

    def area(self) -> float:
        return self.side ** 2

# 兩者都是 Shape，但不互相繼承，行為各自獨立
shapes: list[Shape] = [Rectangle(5, 4), Square(4)]
for s in shapes:
    print(f"{s.__class__.__name__}: area = {s.area()}")
```

### 1.4 I — Interface Segregation（介面隔離原則）

> 客戶端不應被迫依賴它不使用的方法。大介面拆成小介面。

**反面範例** — 一個巨大的介面：

```python
from abc import ABC, abstractmethod

# 反面: 印表機介面太肥，簡單印表機被迫實作不需要的方法
class Machine(ABC):
    @abstractmethod
    def print_doc(self, doc: str): pass

    @abstractmethod
    def scan_doc(self, doc: str): pass

    @abstractmethod
    def fax_doc(self, doc: str): pass

class SimplePrinter(Machine):
    def print_doc(self, doc: str):
        print(f"列印: {doc}")

    def scan_doc(self, doc: str):
        raise NotImplementedError("簡單印表機不支援掃描")  # 被迫實作

    def fax_doc(self, doc: str):
        raise NotImplementedError("簡單印表機不支援傳真")  # 被迫實作
```

**正面範例** — 拆成小介面：

```python
from abc import ABC, abstractmethod

class Printer(ABC):
    @abstractmethod
    def print_doc(self, doc: str): pass

class Scanner(ABC):
    @abstractmethod
    def scan_doc(self, doc: str): pass

class FaxMachine(ABC):
    @abstractmethod
    def fax_doc(self, doc: str): pass

# 簡單印表機只實作 Printer
class SimplePrinter(Printer):
    def print_doc(self, doc: str):
        print(f"列印: {doc}")

# 多功能事務機實作全部
class MultiFunctionDevice(Printer, Scanner, FaxMachine):
    def print_doc(self, doc: str):
        print(f"列印: {doc}")

    def scan_doc(self, doc: str):
        print(f"掃描: {doc}")

    def fax_doc(self, doc: str):
        print(f"傳真: {doc}")
```

### 1.5 D — Dependency Inversion（依賴反轉原則）

> 高層模組不應依賴低層模組，兩者都應依賴抽象。

**反面範例** — 直接依賴具體實作：

```python
# 反面: OrderService 直接依賴 MySQLDatabase
class MySQLDatabase:
    def save(self, data: dict):
        print(f"MySQL 儲存: {data}")

class OrderService:
    def __init__(self):
        self.db = MySQLDatabase()  # 硬綁定！換資料庫要改程式碼

    def create_order(self, order: dict):
        self.db.save(order)
```

**正面範例** — 依賴抽象介面：

```python
from abc import ABC, abstractmethod

class Database(ABC):
    @abstractmethod
    def save(self, data: dict) -> None:
        pass

class MySQLDatabase(Database):
    def save(self, data: dict) -> None:
        print(f"MySQL 儲存: {data}")

class PostgreSQLDatabase(Database):
    def save(self, data: dict) -> None:
        print(f"PostgreSQL 儲存: {data}")

class OrderService:
    def __init__(self, db: Database):  # 依賴抽象，不依賴具體
        self.db = db

    def create_order(self, order: dict) -> None:
        self.db.save(order)

# 使用 — 可以隨時切換資料庫
service_mysql = OrderService(MySQLDatabase())
service_pg = OrderService(PostgreSQLDatabase())
service_mysql.create_order({"item": "書", "price": 500})
service_pg.create_order({"item": "筆電", "price": 35000})
```

### 1.6 其他語言的 SOLID 實現

| 原則 | TypeScript | Go | Rust |
|------|-----------|-----|------|
| S | ES Module 分檔 | 小 package | 小 module |
| O | `interface` + 泛型 | `interface` | `trait` |
| L | `extends` + 多型 | 組合取代繼承 | `trait` 約束 |
| I | 多個小 `interface` | 隱式介面（天生隔離） | 多個小 `trait` |
| D | Constructor injection | 傳入 `interface` | 泛型 `<T: Trait>` |

---

## 2. 創建型模式 (Creational Patterns)

### 2.1 Singleton 單例模式

> 確保一個類別只有一個實例，並提供全域存取點。

**Python — Metaclass 版本：**

```python
class SingletonMeta(type):
    """Metaclass：控制類別的建立過程"""
    _instances: dict = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            instance = super().__call__(*args, **kwargs)
            cls._instances[cls] = instance
        return cls._instances[cls]

class AppConfig(metaclass=SingletonMeta):
    def __init__(self):
        self.settings: dict = {}

    def set(self, key: str, value: str) -> None:
        self.settings[key] = value

    def get(self, key: str) -> str:
        return self.settings.get(key, "")

# 測試
config1 = AppConfig()
config1.set("db_host", "localhost")

config2 = AppConfig()
print(config2.get("db_host"))  # localhost
print(config1 is config2)      # True — 同一個實例
```

**Python — Decorator 版本：**

```python
from functools import wraps

def singleton(cls):
    """裝飾器版 Singleton"""
    instances = {}

    @wraps(cls)
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return get_instance

@singleton
class Logger:
    def __init__(self):
        self.logs: list[str] = []

    def log(self, message: str) -> None:
        self.logs.append(message)
        print(f"[LOG] {message}")

# 測試
logger1 = Logger()
logger1.log("系統啟動")

logger2 = Logger()
logger2.log("使用者登入")

print(logger1 is logger2)        # True
print(f"共 {len(logger1.logs)} 筆")  # 共 2 筆
```

**TypeScript：**

```typescript
class DatabaseConnection {
    private static instance: DatabaseConnection;
    private connectionString: string;

    // private 建構子：外部無法 new
    private constructor(connectionString: string) {
        this.connectionString = connectionString;
        console.log(`連線到: ${connectionString}`);
    }

    static getInstance(connectionString: string = "localhost:5432"): DatabaseConnection {
        if (!DatabaseConnection.instance) {
            DatabaseConnection.instance = new DatabaseConnection(connectionString);
        }
        return DatabaseConnection.instance;
    }

    query(sql: string): void {
        console.log(`執行 SQL: ${sql}`);
    }
}

// 使用
const db1 = DatabaseConnection.getInstance("postgres://prod:5432");
const db2 = DatabaseConnection.getInstance();
console.log(db1 === db2); // true
```

**Go — sync.Once：**

```go
package main

import (
    "fmt"
    "sync"
)

type Config struct {
    DBHost string
    DBPort int
}

var (
    configInstance *Config
    configOnce     sync.Once
)

func GetConfig() *Config {
    configOnce.Do(func() {
        fmt.Println("初始化 Config（只執行一次）")
        configInstance = &Config{
            DBHost: "localhost",
            DBPort: 5432,
        }
    })
    return configInstance
}

func main() {
    c1 := GetConfig() // 印出「初始化 Config（只執行一次）」
    c2 := GetConfig() // 不會再印
    fmt.Println(c1 == c2)      // true
    fmt.Println(c1.DBHost)     // localhost
}
```

**使用場景與注意事項：**
- 適用：設定管理、日誌系統、資料庫連線池、快取管理
- 注意：Singleton 是「全域狀態」，濫用會讓測試困難；多執行緒環境要加鎖

### 2.2 Factory 工廠模式

#### Simple Factory — 簡單工廠

```python
from dataclasses import dataclass
from enum import Enum

class NotificationType(Enum):
    EMAIL = "email"
    SMS = "sms"
    PUSH = "push"

@dataclass
class Notification:
    recipient: str
    message: str

    def send(self) -> None:
        raise NotImplementedError

class EmailNotification(Notification):
    def send(self) -> None:
        print(f"寄 Email 到 {self.recipient}: {self.message}")

class SMSNotification(Notification):
    def send(self) -> None:
        print(f"發簡訊到 {self.recipient}: {self.message}")

class PushNotification(Notification):
    def send(self) -> None:
        print(f"推送通知到 {self.recipient}: {self.message}")

class NotificationFactory:
    """簡單工廠：根據類型建立對應通知物件"""
    @staticmethod
    def create(ntype: NotificationType, recipient: str, message: str) -> Notification:
        mapping = {
            NotificationType.EMAIL: EmailNotification,
            NotificationType.SMS: SMSNotification,
            NotificationType.PUSH: PushNotification,
        }
        cls = mapping.get(ntype)
        if cls is None:
            raise ValueError(f"不支援的通知類型: {ntype}")
        return cls(recipient=recipient, message=message)

# 使用
notif = NotificationFactory.create(NotificationType.EMAIL, "alice@mail.com", "你好！")
notif.send()  # 寄 Email 到 alice@mail.com: 你好！
```

#### Factory Method — 工廠方法

```python
from abc import ABC, abstractmethod

class Document(ABC):
    @abstractmethod
    def render(self) -> str:
        pass

class PDFDocument(Document):
    def render(self) -> str:
        return "渲染 PDF 文件"

class HTMLDocument(Document):
    def render(self) -> str:
        return "渲染 HTML 文件"

class DocumentCreator(ABC):
    """工廠方法：子類別決定建立什麼文件"""
    @abstractmethod
    def create_document(self) -> Document:
        pass

    def process(self) -> str:
        doc = self.create_document()
        return doc.render()

class PDFCreator(DocumentCreator):
    def create_document(self) -> Document:
        return PDFDocument()

class HTMLCreator(DocumentCreator):
    def create_document(self) -> Document:
        return HTMLDocument()

# 使用
for creator in [PDFCreator(), HTMLCreator()]:
    print(creator.process())
```

#### Abstract Factory — 抽象工廠

```python
from abc import ABC, abstractmethod

# --- 產品族：按鈕 + 對話框 ---
class Button(ABC):
    @abstractmethod
    def click(self) -> str: pass

class Dialog(ABC):
    @abstractmethod
    def show(self) -> str: pass

# --- 具體產品：Windows 風格 ---
class WindowsButton(Button):
    def click(self) -> str:
        return "Windows 按鈕被點擊"

class WindowsDialog(Dialog):
    def show(self) -> str:
        return "顯示 Windows 對話框"

# --- 具體產品：macOS 風格 ---
class MacButton(Button):
    def click(self) -> str:
        return "macOS 按鈕被點擊"

class MacDialog(Dialog):
    def show(self) -> str:
        return "顯示 macOS 對話框"

# --- 抽象工廠 ---
class UIFactory(ABC):
    @abstractmethod
    def create_button(self) -> Button: pass

    @abstractmethod
    def create_dialog(self) -> Dialog: pass

class WindowsFactory(UIFactory):
    def create_button(self) -> Button:
        return WindowsButton()

    def create_dialog(self) -> Dialog:
        return WindowsDialog()

class MacFactory(UIFactory):
    def create_button(self) -> Button:
        return MacButton()

    def create_dialog(self) -> Dialog:
        return MacDialog()

# --- 客戶端程式碼 ---
def build_ui(factory: UIFactory) -> None:
    button = factory.create_button()
    dialog = factory.create_dialog()
    print(button.click())
    print(dialog.show())

import platform
os_name = platform.system()
factory = MacFactory() if os_name == "Darwin" else WindowsFactory()
build_ui(factory)
```

**TypeScript — Factory Method：**

```typescript
interface Logger {
    log(message: string): void;
}

class ConsoleLogger implements Logger {
    log(message: string): void {
        console.log(`[CONSOLE] ${message}`);
    }
}

class FileLogger implements Logger {
    log(message: string): void {
        console.log(`[FILE] 寫入: ${message}`);
    }
}

function createLogger(type: "console" | "file"): Logger {
    const loggers: Record<string, () => Logger> = {
        console: () => new ConsoleLogger(),
        file: () => new FileLogger(),
    };
    return loggers[type]();
}

const logger = createLogger("console");
logger.log("系統啟動");
```

### 2.3 Builder 建造者模式

> 分步驟建立複雜物件，支援鏈式呼叫。

**Python：**

```python
from dataclasses import dataclass, field

@dataclass
class HttpRequest:
    method: str = "GET"
    url: str = ""
    headers: dict[str, str] = field(default_factory=dict)
    body: str = ""
    timeout: int = 30

class HttpRequestBuilder:
    """Builder 模式：分步驟建立 HttpRequest"""
    def __init__(self):
        self._request = HttpRequest()

    def method(self, method: str) -> "HttpRequestBuilder":
        self._request.method = method
        return self  # 回傳 self 實現鏈式呼叫

    def url(self, url: str) -> "HttpRequestBuilder":
        self._request.url = url
        return self

    def header(self, key: str, value: str) -> "HttpRequestBuilder":
        self._request.headers[key] = value
        return self

    def body(self, body: str) -> "HttpRequestBuilder":
        self._request.body = body
        return self

    def timeout(self, seconds: int) -> "HttpRequestBuilder":
        self._request.timeout = seconds
        return self

    def build(self) -> HttpRequest:
        if not self._request.url:
            raise ValueError("URL 是必填欄位")
        return self._request

# 鏈式呼叫
request = (
    HttpRequestBuilder()
    .method("POST")
    .url("https://api.example.com/users")
    .header("Content-Type", "application/json")
    .header("Authorization", "Bearer token123")
    .body('{"name": "Alice"}')
    .timeout(10)
    .build()
)
print(f"{request.method} {request.url}")
print(f"Headers: {request.headers}")
print(f"Body: {request.body}")
```

**Rust — Builder 模式（Rust 社群最常用的模式之一）：**

```rust
struct QueryBuilder {
    table: String,
    conditions: Vec<String>,
    limit: Option<u32>,
    order_by: Option<String>,
}

impl QueryBuilder {
    fn new(table: &str) -> Self {
        QueryBuilder {
            table: table.to_string(),
            conditions: Vec::new(),
            limit: None,
            order_by: None,
        }
    }

    fn where_clause(mut self, condition: &str) -> Self {
        self.conditions.push(condition.to_string());
        self
    }

    fn limit(mut self, n: u32) -> Self {
        self.limit = Some(n);
        self
    }

    fn order_by(mut self, column: &str) -> Self {
        self.order_by = Some(column.to_string());
        self
    }

    fn build(self) -> String {
        let mut sql = format!("SELECT * FROM {}", self.table);
        if !self.conditions.is_empty() {
            sql.push_str(&format!(" WHERE {}", self.conditions.join(" AND ")));
        }
        if let Some(col) = self.order_by {
            sql.push_str(&format!(" ORDER BY {}", col));
        }
        if let Some(n) = self.limit {
            sql.push_str(&format!(" LIMIT {}", n));
        }
        sql
    }
}

fn main() {
    let query = QueryBuilder::new("users")
        .where_clause("age > 18")
        .where_clause("active = true")
        .order_by("name")
        .limit(10)
        .build();
    println!("{}", query);
    // SELECT * FROM users WHERE age > 18 AND active = true ORDER BY name LIMIT 10
}
```

---

## 3. 結構型模式 (Structural Patterns)

### 3.1 Adapter 轉接器模式

> 將不相容的介面轉換為客戶端期望的介面。像電源轉接頭一樣。

```python
from dataclasses import dataclass

# --- 舊系統：回傳 XML ---
class LegacyPaymentGateway:
    def process_xml(self, xml_data: str) -> str:
        return f"<response><status>SUCCESS</status><data>{xml_data}</data></response>"

# --- 新系統期望的介面：吃 dict，回傳 dict ---
class PaymentProcessor:
    def process(self, data: dict) -> dict:
        raise NotImplementedError

# --- Adapter：把舊介面轉成新介面 ---
class PaymentAdapter(PaymentProcessor):
    def __init__(self):
        self._legacy = LegacyPaymentGateway()

    def _dict_to_xml(self, data: dict) -> str:
        items = [f"<{k}>{v}</{k}>" for k, v in data.items()]
        return f"<payment>{''.join(items)}</payment>"

    def _xml_to_dict(self, xml: str) -> dict:
        # 簡化解析
        import re
        status = re.search(r"<status>(.*?)</status>", xml)
        return {"status": status.group(1) if status else "UNKNOWN"}

    def process(self, data: dict) -> dict:
        xml_input = self._dict_to_xml(data)
        xml_output = self._legacy.process_xml(xml_input)
        return self._xml_to_dict(xml_output)

# 使用 — 客戶端只看到新介面
adapter = PaymentAdapter()
result = adapter.process({"amount": "1000", "currency": "TWD"})
print(result)  # {'status': 'SUCCESS'}
```

### 3.2 Decorator 裝飾器模式

> 動態地為物件添加額外功能。注意：這是 GoF 設計模式，跟 Python `@decorator` 語法相關但不完全相同。

**Python — GoF Decorator 模式：**

```python
from abc import ABC, abstractmethod

class Coffee(ABC):
    @abstractmethod
    def cost(self) -> float:
        pass

    @abstractmethod
    def description(self) -> str:
        pass

class BasicCoffee(Coffee):
    def cost(self) -> float:
        return 50.0

    def description(self) -> str:
        return "基本咖啡"

# --- Decorator 基底類別 ---
class CoffeeDecorator(Coffee, ABC):
    def __init__(self, coffee: Coffee):
        self._coffee = coffee

class MilkDecorator(CoffeeDecorator):
    def cost(self) -> float:
        return self._coffee.cost() + 20.0

    def description(self) -> str:
        return self._coffee.description() + " + 牛奶"

class SugarDecorator(CoffeeDecorator):
    def cost(self) -> float:
        return self._coffee.cost() + 10.0

    def description(self) -> str:
        return self._coffee.description() + " + 糖"

class WhipCreamDecorator(CoffeeDecorator):
    def cost(self) -> float:
        return self._coffee.cost() + 30.0

    def description(self) -> str:
        return self._coffee.description() + " + 鮮奶油"

# 動態堆疊裝飾
coffee = BasicCoffee()
coffee = MilkDecorator(coffee)
coffee = SugarDecorator(coffee)
coffee = WhipCreamDecorator(coffee)
print(f"{coffee.description()} = ${coffee.cost()}")
# 基本咖啡 + 牛奶 + 糖 + 鮮奶油 = $110.0
```

**TypeScript — Decorator 模式：**

```typescript
interface DataSource {
    read(): string;
    write(data: string): void;
}

class FileDataSource implements DataSource {
    private data: string = "";

    read(): string {
        return this.data;
    }

    write(data: string): void {
        this.data = data;
        console.log(`寫入原始資料: ${data}`);
    }
}

class EncryptionDecorator implements DataSource {
    constructor(private source: DataSource) {}

    read(): string {
        const data = this.source.read();
        return data.split("").reverse().join(""); // 簡易「解密」
    }

    write(data: string): void {
        const encrypted = data.split("").reverse().join(""); // 簡易「加密」
        console.log(`加密後寫入: ${encrypted}`);
        this.source.write(encrypted);
    }
}

class CompressionDecorator implements DataSource {
    constructor(private source: DataSource) {}

    read(): string {
        const data = this.source.read();
        console.log("解壓縮資料");
        return data;
    }

    write(data: string): void {
        console.log("壓縮資料");
        this.source.write(data);
    }
}

// 堆疊裝飾器
let source: DataSource = new FileDataSource();
source = new EncryptionDecorator(source);
source = new CompressionDecorator(source);
source.write("機密資料");
```

### 3.3 Facade 外觀模式

> 為複雜子系統提供一個簡單的統一介面。

```python
class VideoDecoder:
    def decode(self, filename: str) -> str:
        print(f"  解碼影片: {filename}")
        return f"decoded_{filename}"

class AudioDecoder:
    def decode(self, filename: str) -> str:
        print(f"  解碼音訊: {filename}")
        return f"audio_{filename}"

class SubtitleParser:
    def parse(self, filename: str) -> list[str]:
        print(f"  解析字幕: {filename}")
        return ["00:01 你好", "00:05 世界"]

class VideoRenderer:
    def render(self, video: str, audio: str, subtitles: list[str]) -> None:
        print(f"  合成渲染: video={video}, audio={audio}, 字幕數={len(subtitles)}")

# --- Facade：隱藏所有複雜性 ---
class MediaPlayerFacade:
    """使用者只需呼叫 play()，不需知道內部四個子系統"""
    def __init__(self):
        self._video_decoder = VideoDecoder()
        self._audio_decoder = AudioDecoder()
        self._subtitle_parser = SubtitleParser()
        self._renderer = VideoRenderer()

    def play(self, filename: str) -> None:
        print(f"播放 {filename}：")
        video = self._video_decoder.decode(filename)
        audio = self._audio_decoder.decode(filename)
        subs = self._subtitle_parser.parse(filename)
        self._renderer.render(video, audio, subs)
        print("播放中...\n")

# 使用 — 一行搞定
player = MediaPlayerFacade()
player.play("movie.mp4")
```

> 在 EP02 的 VisionDSL 專案中，`VisionPipeline` 就是典型的 Facade，
> 它把模型載入、前處理、推論、後處理全部封裝成一個 `run()` 方法。

---

## 4. 行為型模式 (Behavioral Patterns)

### 4.1 Observer 觀察者模式

> 定義一對多的依賴關係，當一個物件狀態改變時，所有依賴者都會被通知。

**Python：**

```python
from abc import ABC, abstractmethod
from typing import Any

class EventEmitter:
    """通用事件發射器"""
    def __init__(self):
        self._listeners: dict[str, list[callable]] = {}

    def on(self, event: str, callback: callable) -> None:
        """訂閱事件"""
        self._listeners.setdefault(event, []).append(callback)

    def off(self, event: str, callback: callable) -> None:
        """取消訂閱"""
        if event in self._listeners:
            self._listeners[event].remove(callback)

    def emit(self, event: str, data: Any = None) -> None:
        """發射事件，通知所有訂閱者"""
        for callback in self._listeners.get(event, []):
            callback(data)

# --- 使用範例：電商系統 ---
class OrderSystem(EventEmitter):
    def place_order(self, order_id: str, amount: float) -> None:
        print(f"訂單 {order_id} 已建立，金額 ${amount}")
        self.emit("order_placed", {"id": order_id, "amount": amount})

# 訂閱者（觀察者）
def send_confirmation_email(data: dict) -> None:
    print(f"  [Email] 訂單確認信已寄出: {data['id']}")

def update_inventory(data: dict) -> None:
    print(f"  [庫存] 已更新庫存: {data['id']}")

def notify_shipping(data: dict) -> None:
    print(f"  [物流] 通知出貨: {data['id']}")

# 組裝
order_system = OrderSystem()
order_system.on("order_placed", send_confirmation_email)
order_system.on("order_placed", update_inventory)
order_system.on("order_placed", notify_shipping)

order_system.place_order("ORD-001", 2500)
```

**JavaScript：**

```javascript
class EventBus {
    constructor() {
        this.listeners = new Map();
    }

    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
    }

    emit(event, data) {
        const callbacks = this.listeners.get(event) || [];
        callbacks.forEach(cb => cb(data));
    }
}

// 使用
const bus = new EventBus();
bus.on("user:login", (user) => console.log(`歡迎回來, ${user.name}`));
bus.on("user:login", (user) => console.log(`記錄登入: ${user.name}`));
bus.emit("user:login", { name: "Alice" });
// 歡迎回來, Alice
// 記錄登入: Alice
```

### 4.2 Strategy 策略模式

> 定義一系列演算法，讓它們可以互相替換。

**Python：**

```python
from abc import ABC, abstractmethod

class CompressionStrategy(ABC):
    @abstractmethod
    def compress(self, data: bytes) -> bytes:
        pass

    @abstractmethod
    def name(self) -> str:
        pass

class GzipStrategy(CompressionStrategy):
    def compress(self, data: bytes) -> bytes:
        import gzip
        return gzip.compress(data)

    def name(self) -> str:
        return "GZIP"

class NoCompressionStrategy(CompressionStrategy):
    def compress(self, data: bytes) -> bytes:
        return data

    def name(self) -> str:
        return "NONE"

class FileUploader:
    def __init__(self, strategy: CompressionStrategy):
        self._strategy = strategy

    def set_strategy(self, strategy: CompressionStrategy) -> None:
        """運行時切換策略"""
        self._strategy = strategy

    def upload(self, data: bytes) -> None:
        compressed = self._strategy.compress(data)
        ratio = len(compressed) / len(data) * 100 if data else 0
        print(f"策略: {self._strategy.name()}")
        print(f"原始: {len(data)} bytes → 壓縮後: {len(compressed)} bytes ({ratio:.1f}%)")

# 使用
data = b"Hello World! " * 1000
uploader = FileUploader(GzipStrategy())
uploader.upload(data)

uploader.set_strategy(NoCompressionStrategy())
uploader.upload(data)
```

**Go：**

```go
package main

import (
    "fmt"
    "sort"
)

// 策略介面
type SortStrategy interface {
    Sort(data []int) []int
    Name() string
}

// 泡沫排序
type BubbleSort struct{}

func (b BubbleSort) Sort(data []int) []int {
    result := make([]int, len(data))
    copy(result, data)
    n := len(result)
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-i-1; j++ {
            if result[j] > result[j+1] {
                result[j], result[j+1] = result[j+1], result[j]
            }
        }
    }
    return result
}

func (b BubbleSort) Name() string { return "BubbleSort" }

// 標準庫排序
type StdSort struct{}

func (s StdSort) Sort(data []int) []int {
    result := make([]int, len(data))
    copy(result, data)
    sort.Ints(result)
    return result
}

func (s StdSort) Name() string { return "StdSort" }

// 使用策略的排序器
type Sorter struct {
    strategy SortStrategy
}

func (s *Sorter) SetStrategy(strategy SortStrategy) {
    s.strategy = strategy
}

func (s *Sorter) DoSort(data []int) []int {
    fmt.Printf("使用策略: %s\n", s.strategy.Name())
    return s.strategy.Sort(data)
}

func main() {
    data := []int{64, 34, 25, 12, 22, 11, 90}

    sorter := &Sorter{strategy: BubbleSort{}}
    fmt.Println(sorter.DoSort(data))

    sorter.SetStrategy(StdSort{})
    fmt.Println(sorter.DoSort(data))
}
```

### 4.3 State Machine 狀態機

> 物件的行為根據其內部狀態而改變。

**Python — 完整訂單狀態機：**

```python
from abc import ABC, abstractmethod
from enum import Enum, auto

class OrderStatus(Enum):
    PENDING = auto()
    CONFIRMED = auto()
    SHIPPED = auto()
    DELIVERED = auto()
    CANCELLED = auto()

class OrderState(ABC):
    @abstractmethod
    def confirm(self, order: "Order") -> None: pass

    @abstractmethod
    def ship(self, order: "Order") -> None: pass

    @abstractmethod
    def deliver(self, order: "Order") -> None: pass

    @abstractmethod
    def cancel(self, order: "Order") -> None: pass

class PendingState(OrderState):
    def confirm(self, order: "Order") -> None:
        print("訂單已確認")
        order.state = ConfirmedState()
        order.status = OrderStatus.CONFIRMED

    def ship(self, order: "Order") -> None:
        print("錯誤：未確認的訂單無法出貨")

    def deliver(self, order: "Order") -> None:
        print("錯誤：未確認的訂單無法送達")

    def cancel(self, order: "Order") -> None:
        print("訂單已取消")
        order.state = CancelledState()
        order.status = OrderStatus.CANCELLED

class ConfirmedState(OrderState):
    def confirm(self, order: "Order") -> None:
        print("訂單已經確認過了")

    def ship(self, order: "Order") -> None:
        print("訂單已出貨")
        order.state = ShippedState()
        order.status = OrderStatus.SHIPPED

    def deliver(self, order: "Order") -> None:
        print("錯誤：尚未出貨")

    def cancel(self, order: "Order") -> None:
        print("訂單已取消（退款處理中）")
        order.state = CancelledState()
        order.status = OrderStatus.CANCELLED

class ShippedState(OrderState):
    def confirm(self, order: "Order") -> None:
        print("訂單已經確認過了")

    def ship(self, order: "Order") -> None:
        print("訂單已經出貨了")

    def deliver(self, order: "Order") -> None:
        print("訂單已送達")
        order.state = DeliveredState()
        order.status = OrderStatus.DELIVERED

    def cancel(self, order: "Order") -> None:
        print("錯誤：已出貨的訂單無法取消")

class DeliveredState(OrderState):
    def confirm(self, order: "Order") -> None:
        print("訂單已完成")

    def ship(self, order: "Order") -> None:
        print("訂單已完成")

    def deliver(self, order: "Order") -> None:
        print("訂單已經送達了")

    def cancel(self, order: "Order") -> None:
        print("錯誤：已送達的訂單請走退貨流程")

class CancelledState(OrderState):
    def confirm(self, order: "Order") -> None:
        print("錯誤：已取消的訂單無法操作")

    def ship(self, order: "Order") -> None:
        print("錯誤：已取消的訂單無法操作")

    def deliver(self, order: "Order") -> None:
        print("錯誤：已取消的訂單無法操作")

    def cancel(self, order: "Order") -> None:
        print("訂單已經取消了")

class Order:
    def __init__(self, order_id: str):
        self.order_id = order_id
        self.status = OrderStatus.PENDING
        self.state: OrderState = PendingState()

    def confirm(self) -> None:
        self.state.confirm(self)

    def ship(self) -> None:
        self.state.ship(self)

    def deliver(self) -> None:
        self.state.deliver(self)

    def cancel(self) -> None:
        self.state.cancel(self)

# 測試正常流程
order = Order("ORD-001")
print(f"--- 訂單 {order.order_id} ---")
order.confirm()    # 訂單已確認
order.ship()       # 訂單已出貨
order.deliver()    # 訂單已送達
order.cancel()     # 錯誤：已送達的訂單請走退貨流程

print()

# 測試取消流程
order2 = Order("ORD-002")
print(f"--- 訂單 {order2.order_id} ---")
order2.ship()      # 錯誤：未確認的訂單無法出貨
order2.cancel()    # 訂單已取消
order2.confirm()   # 錯誤：已取消的訂單無法操作
```

### 4.4 Command 命令模式

> 將請求封裝成物件，支援 Undo/Redo。

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field

class Command(ABC):
    @abstractmethod
    def execute(self) -> None:
        pass

    @abstractmethod
    def undo(self) -> None:
        pass

class TextEditor:
    def __init__(self):
        self.content: str = ""

    def __repr__(self) -> str:
        return f"TextEditor('{self.content}')"

class InsertTextCommand(Command):
    def __init__(self, editor: TextEditor, text: str, position: int):
        self.editor = editor
        self.text = text
        self.position = position

    def execute(self) -> None:
        self.editor.content = (
            self.editor.content[:self.position]
            + self.text
            + self.editor.content[self.position:]
        )

    def undo(self) -> None:
        self.editor.content = (
            self.editor.content[:self.position]
            + self.editor.content[self.position + len(self.text):]
        )

class DeleteTextCommand(Command):
    def __init__(self, editor: TextEditor, position: int, length: int):
        self.editor = editor
        self.position = position
        self.length = length
        self.deleted_text: str = ""

    def execute(self) -> None:
        self.deleted_text = self.editor.content[self.position:self.position + self.length]
        self.editor.content = (
            self.editor.content[:self.position]
            + self.editor.content[self.position + self.length:]
        )

    def undo(self) -> None:
        self.editor.content = (
            self.editor.content[:self.position]
            + self.deleted_text
            + self.editor.content[self.position:]
        )

class CommandManager:
    """管理命令歷史，支援 Undo/Redo"""
    def __init__(self):
        self._history: list[Command] = []
        self._redo_stack: list[Command] = []

    def execute(self, command: Command) -> None:
        command.execute()
        self._history.append(command)
        self._redo_stack.clear()  # 執行新命令後清空 redo

    def undo(self) -> None:
        if not self._history:
            print("沒有可以撤銷的操作")
            return
        command = self._history.pop()
        command.undo()
        self._redo_stack.append(command)

    def redo(self) -> None:
        if not self._redo_stack:
            print("沒有可以重做的操作")
            return
        command = self._redo_stack.pop()
        command.execute()
        self._history.append(command)

# 測試
editor = TextEditor()
manager = CommandManager()

manager.execute(InsertTextCommand(editor, "Hello", 0))
print(editor)  # TextEditor('Hello')

manager.execute(InsertTextCommand(editor, " World", 5))
print(editor)  # TextEditor('Hello World')

manager.execute(InsertTextCommand(editor, "!", 11))
print(editor)  # TextEditor('Hello World!')

manager.undo()
print(editor)  # TextEditor('Hello World')

manager.undo()
print(editor)  # TextEditor('Hello')

manager.redo()
print(editor)  # TextEditor('Hello World')
```

---

## 5. 架構模式

### 5.1 MVC / MVP / MVVM

```
┌─────────────────────────────────────────────────────────────┐
│                        MVC 模式                              │
│                                                              │
│  ┌──────────┐     ┌──────────────┐     ┌──────────┐        │
│  │   View   │────→│  Controller  │────→│  Model   │        │
│  │  (視圖)   │     │   (控制器)    │     │  (模型)  │        │
│  └──────────┘     └──────────────┘     └──────────┘        │
│       ↑                                      │              │
│       └──────────────────────────────────────┘              │
│                    通知更新                                   │
├─────────────────────────────────────────────────────────────┤
│                        MVP 模式                              │
│                                                              │
│  ┌──────────┐     ┌──────────────┐     ┌──────────┐        │
│  │   View   │←───→│  Presenter   │←───→│  Model   │        │
│  │  (視圖)   │     │   (展示器)    │     │  (模型)  │        │
│  └──────────┘     └──────────────┘     └──────────┘        │
│   View 和 Model 完全隔離，Presenter 雙向溝通                  │
├─────────────────────────────────────────────────────────────┤
│                       MVVM 模式                              │
│                                                              │
│  ┌──────────┐     ┌──────────────┐     ┌──────────┐        │
│  │   View   │←═══→│  ViewModel   │←───→│  Model   │        │
│  │  (視圖)   │雙向  │  (視圖模型)   │     │  (模型)  │        │
│  └──────────┘綁定  └──────────────┘     └──────────┘        │
│   View 和 ViewModel 雙向資料綁定 (Data Binding)               │
└─────────────────────────────────────────────────────────────┘
```

**各框架的選擇：**

| 模式 | 代表框架 | 特點 |
|------|---------|------|
| MVC | Django, Rails, Spring MVC | 傳統伺服器渲染，成熟穩定 |
| MVP | Android (早期), WinForms | View 與邏輯完全分離，易測試 |
| MVVM | Vue.js, Angular, SwiftUI, WPF | 雙向綁定，適合互動豐富的 UI |

### 5.2 微服務 vs 單體

```
單體架構 (Monolith)              微服務架構 (Microservices)

┌─────────────────────┐      ┌────────┐  ┌────────┐  ┌────────┐
│     整個應用程式       │      │ 用戶服務 │  │ 訂單服務 │  │ 支付服務 │
│  ┌─────┐ ┌─────┐   │      │ :3001  │  │ :3002  │  │ :3003  │
│  │用戶  │ │訂單  │   │      └───┬────┘  └───┬────┘  └───┬────┘
│  ├─────┤ ├─────┤   │          │            │            │
│  │支付  │ │通知  │   │      ┌───┴────────────┴────────────┴───┐
│  └─────┘ └─────┘   │      │          API Gateway             │
│    一個部署單元       │      │          (統一入口)               │
└─────────────────────┘      └──────────────────────────────────┘
```

**什麼時候用微服務？**

| 考量 | 單體 | 微服務 |
|------|------|--------|
| 團隊規模 | < 10 人 | > 10 人，多團隊 |
| 部署頻率 | 週/月 | 每天多次 |
| 擴展需求 | 整體擴展 | 個別服務獨立擴展 |
| 技術棧 | 統一 | 各服務可用不同語言 |
| 複雜度 | 低 | 高（網路、監控、除錯） |
| 建議 | MVP、新專案先用單體 | 成長到一定規模再拆分 |

**Docker + API Gateway 基本概念：**

```yaml
# docker-compose.yml — 微服務部署範例
version: "3.8"
services:
  gateway:
    image: nginx:alpine
    ports:
      - "80:80"
    depends_on:
      - user-service
      - order-service

  user-service:
    build: ./services/user
    environment:
      - DB_HOST=user-db
      - PORT=3001

  order-service:
    build: ./services/order
    environment:
      - DB_HOST=order-db
      - PORT=3002

  user-db:
    image: postgres:15
    environment:
      - POSTGRES_DB=users

  order-db:
    image: postgres:15
    environment:
      - POSTGRES_DB=orders
```

### 5.3 Event-Driven Architecture

> 元件之間透過事件（訊息）溝通，鬆散耦合。

```
┌──────────┐    事件     ┌──────────────┐    事件     ┌──────────┐
│  生產者   │───────────→│  訊息佇列     │───────────→│  消費者   │
│ Producer │            │ Message Queue │            │ Consumer │
└──────────┘            └──────────────┘            └──────────┘
                         (RabbitMQ,                    可以有
                          Kafka,                      多個消費者
                          Redis Pub/Sub)
```

**Python 簡易 Pub/Sub 實作：**

```python
import threading
from collections import defaultdict
from queue import Queue
from typing import Any, Callable

class MessageBroker:
    """簡易訊息中介器"""
    def __init__(self):
        self._subscribers: dict[str, list[Queue]] = defaultdict(list)
        self._lock = threading.Lock()

    def subscribe(self, topic: str) -> Queue:
        """訂閱主題，回傳一個 Queue 用於接收訊息"""
        q: Queue = Queue()
        with self._lock:
            self._subscribers[topic].append(q)
        return q

    def publish(self, topic: str, message: Any) -> None:
        """發布訊息到主題"""
        with self._lock:
            subscribers = self._subscribers.get(topic, [])
        for q in subscribers:
            q.put(message)

    def unsubscribe(self, topic: str, q: Queue) -> None:
        """取消訂閱"""
        with self._lock:
            if topic in self._subscribers:
                self._subscribers[topic].remove(q)

# --- 使用範例 ---
broker = MessageBroker()

def consumer_worker(name: str, q: Queue) -> None:
    """消費者：持續監聽佇列"""
    while True:
        message = q.get()
        if message is None:  # 結束信號
            break
        print(f"  [{name}] 收到: {message}")

# 訂閱
order_q1 = broker.subscribe("orders")
order_q2 = broker.subscribe("orders")

# 啟動消費者執行緒
t1 = threading.Thread(target=consumer_worker, args=("庫存服務", order_q1))
t2 = threading.Thread(target=consumer_worker, args=("通知服務", order_q2))
t1.start()
t2.start()

# 發布事件
broker.publish("orders", {"event": "order_created", "id": "ORD-001"})
broker.publish("orders", {"event": "order_paid", "id": "ORD-001"})

# 清理
broker.publish("orders", None)  # 結束信號
broker.publish("orders", None)
t1.join()
t2.join()
```

---

## 6. 函式式程式設計 (Functional Programming)

### 6.1 Pure Function 純函式

> 相同輸入永遠產生相同輸出，且沒有副作用 (side effect)。

```python
# 不純：依賴外部狀態
tax_rate = 0.05
def impure_price(price: float) -> float:
    return price * (1 + tax_rate)  # 依賴外部變數

# 純函式：所有依賴都從參數傳入
def pure_price(price: float, tax_rate: float) -> float:
    return price * (1 + tax_rate)  # 結果只取決於輸入

# 純函式容易測試
assert pure_price(100, 0.05) == 105.0
assert pure_price(100, 0.10) == 110.0
```

### 6.2 Immutability 不可變性

```python
# 可變：直接修改原始資料（危險）
def add_item_mutable(cart: list, item: str) -> list:
    cart.append(item)  # 修改了原始 list
    return cart

# 不可變：回傳新的資料
def add_item_immutable(cart: tuple, item: str) -> tuple:
    return cart + (item,)  # 回傳新 tuple，原始不變

original = ("蘋果", "香蕉")
new_cart = add_item_immutable(original, "橘子")
print(original)   # ('蘋果', '香蕉') — 不變
print(new_cart)    # ('蘋果', '香蕉', '橘子')
```

**JavaScript — 不可變操作：**

```javascript
// 可變（壞）
const arr = [1, 2, 3];
arr.push(4); // 修改原始陣列

// 不可變（好）
const arr2 = [1, 2, 3];
const arr3 = [...arr2, 4]; // 展開運算子，建立新陣列

// 物件不可變
const user = { name: "Alice", age: 25 };
const updatedUser = { ...user, age: 26 }; // 建立新物件
console.log(user.age);        // 25 — 不變
console.log(updatedUser.age); // 26
```

### 6.3 Higher-Order Functions

```python
from typing import Callable

# map: 對每個元素套用函式
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x ** 2, numbers))
print(squared)  # [1, 4, 9, 16, 25]

# filter: 過濾元素
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)  # [2, 4]

# reduce: 累積計算
from functools import reduce
total = reduce(lambda acc, x: acc + x, numbers, 0)
print(total)  # 15

# 自定義高階函式
def create_multiplier(factor: int) -> Callable[[int], int]:
    """回傳一個函式（閉包）"""
    def multiplier(x: int) -> int:
        return x * factor
    return multiplier

double = create_multiplier(2)
triple = create_multiplier(3)
print(double(5))  # 10
print(triple(5))  # 15
```

### 6.4 Function Composition

```python
from typing import Callable, TypeVar

T = TypeVar("T")

def compose(*funcs: Callable) -> Callable:
    """將多個函式組合成一個，從右到左執行"""
    def composed(x):
        result = x
        for f in reversed(funcs):
            result = f(result)
        return result
    return composed

def pipe(*funcs: Callable) -> Callable:
    """將多個函式組合成一個，從左到右執行（更直覺）"""
    def piped(x):
        result = x
        for f in funcs:
            result = f(result)
        return result
    return piped

# 資料處理管線
def strip_whitespace(s: str) -> str:
    return s.strip()

def to_lowercase(s: str) -> str:
    return s.lower()

def replace_spaces(s: str) -> str:
    return s.replace(" ", "-")

# 用 pipe 組合（從左到右，更直覺）
slugify = pipe(strip_whitespace, to_lowercase, replace_spaces)
print(slugify("  Hello World  "))  # hello-world

# Rust 風格的鏈式呼叫（Python 用 list comprehension 模擬）
result = (
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    |> (lambda xs: [x for x in xs if x % 2 == 0])   # Python 尚不支援 |>
    |> (lambda xs: [x ** 2 for x in xs])             # 但概念如此
)
# 實際寫法：
result = [x ** 2 for x in range(1, 11) if x % 2 == 0]
print(result)  # [4, 16, 36, 64, 100]
```

### 6.5 Monad 概念 — 用 Optional/Result 解釋

> Monad 聽起來很嚇人，但核心概念很簡單：
> 「把值包在容器裡，提供 `bind`/`flatMap` 讓你串接操作，自動處理空值或錯誤。」

```python
from typing import TypeVar, Generic, Callable, Optional

T = TypeVar("T")
U = TypeVar("U")

class Maybe(Generic[T]):
    """Optional Monad：優雅處理可能為 None 的值"""
    def __init__(self, value: Optional[T]):
        self._value = value

    @staticmethod
    def of(value: T) -> "Maybe[T]":
        return Maybe(value)

    @staticmethod
    def empty() -> "Maybe[T]":
        return Maybe(None)

    def bind(self, func: Callable[[T], "Maybe[U]"]) -> "Maybe[U]":
        """核心操作：如果有值就執行 func，沒值就直接回傳 empty"""
        if self._value is None:
            return Maybe.empty()
        return func(self._value)

    def map(self, func: Callable[[T], U]) -> "Maybe[U]":
        """對值套用函式"""
        if self._value is None:
            return Maybe.empty()
        return Maybe.of(func(self._value))

    def get_or_else(self, default: T) -> T:
        return self._value if self._value is not None else default

    def __repr__(self) -> str:
        return f"Maybe({self._value})"

# --- 使用範例：安全地查詢嵌套資料 ---
data = {
    "user": {
        "profile": {
            "address": {
                "city": "台北"
            }
        }
    }
}

def safe_get(d: dict, key: str) -> Maybe[any]:
    return Maybe.of(d.get(key))

# 不用 Monad：巢狀 if
city = None
if "user" in data:
    if "profile" in data["user"]:
        if "address" in data["user"]["profile"]:
            city = data["user"]["profile"]["address"].get("city")

# 用 Monad：鏈式呼叫，自動處理 None
city = (
    Maybe.of(data)
    .bind(lambda d: safe_get(d, "user"))
    .bind(lambda d: safe_get(d, "profile"))
    .bind(lambda d: safe_get(d, "address"))
    .bind(lambda d: safe_get(d, "city"))
    .get_or_else("未知城市")
)
print(city)  # 台北
```

**Rust — Result Monad（語言原生支援）：**

```rust
use std::num::ParseIntError;

fn parse_and_double(s: &str) -> Result<i32, ParseIntError> {
    // ? 運算子 = 自動 bind：成功就繼續，失敗就提前回傳
    let n = s.parse::<i32>()?;
    Ok(n * 2)
}

fn main() {
    println!("{:?}", parse_and_double("21"));   // Ok(42)
    println!("{:?}", parse_and_double("abc"));  // Err(ParseIntError)

    // 鏈式呼叫
    let result = "10"
        .parse::<i32>()
        .map(|n| n * 2)
        .map(|n| n + 1)
        .unwrap_or(0);
    println!("{}", result); // 21
}
```

---

## 7. 並發模式 (Concurrency Patterns)

### 7.1 Producer-Consumer

**Python — Queue：**

```python
import threading
import time
from queue import Queue

def producer(q: Queue, items: list[str]) -> None:
    for item in items:
        print(f"[生產者] 生產: {item}")
        q.put(item)
        time.sleep(0.1)
    q.put(None)  # 結束信號

def consumer(q: Queue, name: str) -> None:
    while True:
        item = q.get()
        if item is None:
            q.put(None)  # 傳遞結束信號給其他消費者
            break
        print(f"  [{name}] 消費: {item}")
        time.sleep(0.2)

q: Queue = Queue(maxsize=5)
items = ["任務A", "任務B", "任務C", "任務D", "任務E"]

t_prod = threading.Thread(target=producer, args=(q, items))
t_con1 = threading.Thread(target=consumer, args=(q, "消費者1"))
t_con2 = threading.Thread(target=consumer, args=(q, "消費者2"))

t_prod.start()
t_con1.start()
t_con2.start()

t_prod.join()
t_con1.join()
t_con2.join()
print("全部完成")
```

**Go — Channel：**

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func producer(ch chan<- string, items []string) {
    for _, item := range items {
        fmt.Printf("[生產者] 生產: %s\n", item)
        ch <- item
        time.Sleep(100 * time.Millisecond)
    }
    close(ch) // 關閉 channel 通知消費者
}

func consumer(name string, ch <-chan string, wg *sync.WaitGroup) {
    defer wg.Done()
    for item := range ch {
        fmt.Printf("  [%s] 消費: %s\n", name, item)
        time.Sleep(200 * time.Millisecond)
    }
}

func main() {
    ch := make(chan string, 5) // 帶緩衝的 channel
    items := []string{"任務A", "任務B", "任務C", "任務D", "任務E"}

    var wg sync.WaitGroup

    go producer(ch, items)

    wg.Add(2)
    go consumer("消費者1", ch, &wg)
    go consumer("消費者2", ch, &wg)

    wg.Wait()
    fmt.Println("全部完成")
}
```

### 7.2 Worker Pool

**Python — ThreadPoolExecutor：**

```python
from concurrent.futures import ThreadPoolExecutor, as_completed
import time

def process_task(task_id: int) -> str:
    """模擬耗時任務"""
    print(f"  [Worker] 開始任務 {task_id}")
    time.sleep(0.5)  # 模擬處理
    return f"任務 {task_id} 完成"

# 建立 Worker Pool（最多 3 個 worker）
tasks = list(range(1, 8))

with ThreadPoolExecutor(max_workers=3) as pool:
    # 提交所有任務
    futures = {pool.submit(process_task, t): t for t in tasks}

    # 收集結果（按完成順序）
    for future in as_completed(futures):
        task_id = futures[future]
        try:
            result = future.result()
            print(f"  結果: {result}")
        except Exception as e:
            print(f"  任務 {task_id} 失敗: {e}")
```

**Go — Goroutine Pool：**

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, jobs <-chan int, results chan<- string, wg *sync.WaitGroup) {
    defer wg.Done()
    for job := range jobs {
        fmt.Printf("  [Worker %d] 處理任務 %d\n", id, job)
        time.Sleep(500 * time.Millisecond)
        results <- fmt.Sprintf("任務 %d 由 Worker %d 完成", job, id)
    }
}

func main() {
    const numWorkers = 3
    const numJobs = 7

    jobs := make(chan int, numJobs)
    results := make(chan string, numJobs)

    var wg sync.WaitGroup

    // 啟動 worker pool
    for w := 1; w <= numWorkers; w++ {
        wg.Add(1)
        go worker(w, jobs, results, &wg)
    }

    // 送入任務
    for j := 1; j <= numJobs; j++ {
        jobs <- j
    }
    close(jobs)

    // 等待所有 worker 完成後關閉 results
    go func() {
        wg.Wait()
        close(results)
    }()

    // 收集結果
    for result := range results {
        fmt.Println(result)
    }
}
```

### 7.3 Async/Await 模式

**Python — asyncio：**

```python
import asyncio
import time

async def fetch_url(url: str) -> dict:
    """模擬非同步 HTTP 請求"""
    print(f"  開始請求: {url}")
    await asyncio.sleep(1)  # 模擬網路延遲
    return {"url": url, "status": 200, "data": f"回應自 {url}"}

async def main():
    urls = [
        "https://api.example.com/users",
        "https://api.example.com/orders",
        "https://api.example.com/products",
        "https://api.example.com/payments",
    ]

    start = time.time()

    # 並行請求所有 URL
    tasks = [fetch_url(url) for url in urls]
    results = await asyncio.gather(*tasks)

    elapsed = time.time() - start

    for result in results:
        print(f"  {result['url']} → {result['status']}")

    print(f"\n總耗時: {elapsed:.2f}s（如果序列執行要 {len(urls)}s）")

asyncio.run(main())
```

**JavaScript — async/await：**

```javascript
async function fetchData(url) {
    console.log(`  開始請求: ${url}`);
    // 模擬網路延遲
    await new Promise(resolve => setTimeout(resolve, 1000));
    return { url, status: 200, data: `回應自 ${url}` };
}

async function main() {
    const urls = [
        "https://api.example.com/users",
        "https://api.example.com/orders",
        "https://api.example.com/products",
    ];

    const start = Date.now();

    // Promise.all: 並行執行
    const results = await Promise.all(urls.map(fetchData));

    const elapsed = (Date.now() - start) / 1000;
    results.forEach(r => console.log(`  ${r.url} → ${r.status}`));
    console.log(`\n總耗時: ${elapsed.toFixed(2)}s`);

    // Promise.allSettled: 即使部分失敗也回傳全部結果
    const mixed = await Promise.allSettled([
        fetchData("https://api.example.com/ok"),
        Promise.reject(new Error("網路錯誤")),
        fetchData("https://api.example.com/also-ok"),
    ]);
    mixed.forEach((r, i) => {
        if (r.status === "fulfilled") {
            console.log(`  [${i}] 成功: ${r.value.url}`);
        } else {
            console.log(`  [${i}] 失敗: ${r.reason.message}`);
        }
    });
}

main();
```

---

## 8. 資料結構與演算法精要

### 8.1 時間複雜度

```
操作數量
  ↑
  │                                          O(n²) 每次都翻倍痛苦
  │                                        ╱
  │                                      ╱
  │                              ╱─────╱
  │                   O(n log n)
  │                 ╱
  │        O(n) ──╱──────────────── 線性成長
  │      ╱
  │  O(log n) ─────────────── 幾乎水平
  │ ╱
  │O(1) ──────────────────── 常數，最快
  └──────────────────────────────→ 資料量 n
```

| 複雜度 | 名稱 | 例子 | 100萬筆耗時感受 |
|--------|------|------|----------------|
| O(1) | 常數 | dict 查找、array 索引 | 瞬間 |
| O(log n) | 對數 | 二分搜尋 | 約 20 步 |
| O(n) | 線性 | 遍歷陣列 | 可接受 |
| O(n log n) | 線性對數 | 快速排序、合併排序 | 可接受 |
| O(n²) | 平方 | 巢狀迴圈、泡沫排序 | 很慢，避免 |

### 8.2 Array vs LinkedList vs HashMap

| 操作 | Array (list) | LinkedList | HashMap (dict) |
|------|-------------|------------|----------------|
| 索引存取 | O(1) | O(n) | O(1) |
| 搜尋 | O(n) | O(n) | O(1) |
| 頭部插入 | O(n) | O(1) | N/A |
| 尾部插入 | O(1)* | O(1)** | O(1) |
| 刪除 | O(n) | O(1)*** | O(1) |

> *攤銷(amortized)  **需持有尾部參考  ***需持有節點參考

### 8.3 Stack, Queue, Tree, Graph

```python
# --- Stack (堆疊) — LIFO: 後進先出 ---
stack: list[str] = []
stack.append("A")  # push
stack.append("B")
stack.append("C")
print(stack.pop())  # C — 最後進的最先出
print(stack.pop())  # B

# --- Queue (佇列) — FIFO: 先進先出 ---
from collections import deque
queue: deque[str] = deque()
queue.append("A")   # enqueue
queue.append("B")
queue.append("C")
print(queue.popleft())  # A — 最先進的最先出
print(queue.popleft())  # B

# --- Binary Tree (二元樹) ---
class TreeNode:
    def __init__(self, value: int):
        self.value = value
        self.left: TreeNode | None = None
        self.right: TreeNode | None = None

def inorder(node: TreeNode | None) -> list[int]:
    """中序走訪：左 → 根 → 右"""
    if node is None:
        return []
    return inorder(node.left) + [node.value] + inorder(node.right)

#       4
#      / \
#     2   6
#    / \
#   1   3
root = TreeNode(4)
root.left = TreeNode(2)
root.right = TreeNode(6)
root.left.left = TreeNode(1)
root.left.right = TreeNode(3)
print(inorder(root))  # [1, 2, 3, 4, 6]

# --- Graph (圖) — 鄰接表表示 ---
graph: dict[str, list[str]] = {
    "A": ["B", "C"],
    "B": ["A", "D"],
    "C": ["A", "D"],
    "D": ["B", "C"],
}

def bfs(graph: dict, start: str) -> list[str]:
    """廣度優先搜尋"""
    visited: set[str] = set()
    queue: deque[str] = deque([start])
    order: list[str] = []
    while queue:
        node = queue.popleft()
        if node not in visited:
            visited.add(node)
            order.append(node)
            queue.extend(graph[node])
    return order

print(bfs(graph, "A"))  # ['A', 'B', 'C', 'D']
```

### 8.4 快速排序 (Quick Sort)

```python
def quicksort(arr: list[int]) -> list[int]:
    """快速排序 — 平均 O(n log n)"""
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quicksort(left) + middle + quicksort(right)

data = [38, 27, 43, 3, 9, 82, 10]
print(quicksort(data))  # [3, 9, 10, 27, 38, 43, 82]
```

### 8.5 二分搜尋 (Binary Search)

```python
def binary_search(arr: list[int], target: int) -> int:
    """二分搜尋 — O(log n)，前提：arr 已排序"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1  # 未找到

sorted_data = [3, 9, 10, 27, 38, 43, 82]
print(binary_search(sorted_data, 27))  # 3 (索引)
print(binary_search(sorted_data, 50))  # -1 (未找到)
```

### 8.6 遞迴 vs 迭代

```python
# --- 費氏數列：遞迴版 (直覺但慢) ---
def fib_recursive(n: int) -> int:
    """O(2^n) — 指數級，很慢"""
    if n <= 1:
        return n
    return fib_recursive(n - 1) + fib_recursive(n - 2)

# --- 費氏數列：迭代版 (快) ---
def fib_iterative(n: int) -> int:
    """O(n) — 線性"""
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b

# --- 費氏數列：帶快取的遞迴 (兼顧直覺與效能) ---
from functools import lru_cache

@lru_cache(maxsize=None)
def fib_cached(n: int) -> int:
    """O(n) — 有快取"""
    if n <= 1:
        return n
    return fib_cached(n - 1) + fib_cached(n - 2)

print(fib_iterative(50))  # 12586269025
print(fib_cached(50))     # 12586269025
```

### 8.7 Dynamic Programming 入門

```python
def coin_change(coins: list[int], amount: int) -> int:
    """
    硬幣找零問題：用最少的硬幣湊出 amount
    coins: 可用硬幣面額
    amount: 目標金額
    回傳: 最少硬幣數，如果湊不出回傳 -1
    """
    # dp[i] = 湊出金額 i 所需的最少硬幣數
    dp = [float("inf")] * (amount + 1)
    dp[0] = 0  # 金額 0 需要 0 個硬幣

    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i and dp[i - coin] + 1 < dp[i]:
                dp[i] = dp[i - coin] + 1

    return dp[amount] if dp[amount] != float("inf") else -1

# 測試
coins = [1, 5, 10, 25]
print(coin_change(coins, 36))  # 3 (25 + 10 + 1)
print(coin_change(coins, 0))   # 0
print(coin_change([2], 3))     # -1 (無法湊出)
```

---

## 9. 系統設計入門

### 9.1 典型 Web 架構圖

```
使用者
  │
  ▼
┌──────────┐
│   CDN    │ ← 靜態資源 (圖片, CSS, JS)
└────┬─────┘
     │
     ▼
┌──────────────────┐
│  Load Balancer   │ ← 負載均衡 (Nginx, AWS ALB)
│  (負載均衡器)      │
└───┬─────────┬────┘
    │         │
    ▼         ▼
┌───────┐ ┌───────┐
│ App 1 │ │ App 2 │ ← 應用伺服器 (可水平擴展)
└───┬───┘ └───┬───┘
    │         │
    ▼         ▼
┌──────────────────┐
│     Cache        │ ← Redis / Memcached
│   (快取層)        │
└───────┬──────────┘
        │
        ▼
┌──────────────────┐
│    Database      │ ← 主從架構
│  ┌──────┐        │
│  │Master│→ Write │
│  └──┬───┘        │
│     │  複製       │
│  ┌──▼───┐        │
│  │Slave │→ Read  │
│  └──────┘        │
└──────────────────┘
```

### 9.2 負載均衡 (Load Balancer)

| 策略 | 說明 | 適用場景 |
|------|------|---------|
| Round Robin | 輪流分配 | 伺服器效能相近 |
| Weighted Round Robin | 按權重分配 | 伺服器效能不同 |
| Least Connections | 分配給連線最少的 | 長連線場景 |
| IP Hash | 同 IP 分配到同一台 | 需要 session 粘性 |

### 9.3 快取策略 (Cache)

```python
import time
from typing import Any, Optional

class SimpleCache:
    """簡易快取實作（模擬 Redis 概念）"""
    def __init__(self, default_ttl: int = 300):
        self._store: dict[str, tuple[Any, float]] = {}
        self._default_ttl = default_ttl

    def get(self, key: str) -> Optional[Any]:
        if key in self._store:
            value, expire_at = self._store[key]
            if time.time() < expire_at:
                print(f"  [CACHE HIT] {key}")
                return value
            else:
                del self._store[key]
                print(f"  [CACHE EXPIRED] {key}")
        else:
            print(f"  [CACHE MISS] {key}")
        return None

    def set(self, key: str, value: Any, ttl: Optional[int] = None) -> None:
        expire_at = time.time() + (ttl or self._default_ttl)
        self._store[key] = (value, expire_at)

    def delete(self, key: str) -> None:
        self._store.pop(key, None)

def get_user(user_id: int, cache: SimpleCache) -> dict:
    """Cache-Aside 模式：先查快取，沒有再查資料庫"""
    cache_key = f"user:{user_id}"

    # 1. 先查快取
    cached = cache.get(cache_key)
    if cached is not None:
        return cached

    # 2. 快取未命中，查資料庫
    print(f"  [DB QUERY] SELECT * FROM users WHERE id = {user_id}")
    user = {"id": user_id, "name": f"User_{user_id}", "email": f"user{user_id}@mail.com"}

    # 3. 寫入快取
    cache.set(cache_key, user, ttl=60)
    return user

# 測試
cache = SimpleCache()
user = get_user(42, cache)   # CACHE MISS → DB QUERY
user = get_user(42, cache)   # CACHE HIT
```

### 9.4 Database Scaling

| 策略 | 說明 | 適用 |
|------|------|------|
| 讀寫分離 | Master 負責寫，Slave 負責讀 | 讀多寫少 |
| Sharding | 按規則將資料分散到多個資料庫 | 資料量極大 |
| 垂直分割 | 不同表放不同資料庫 | 業務獨立性高 |

### 9.5 API Rate Limiting

```python
import time
from collections import defaultdict

class RateLimiter:
    """滑動窗口限流器"""
    def __init__(self, max_requests: int, window_seconds: int):
        self.max_requests = max_requests
        self.window = window_seconds
        self._requests: dict[str, list[float]] = defaultdict(list)

    def allow(self, client_id: str) -> bool:
        now = time.time()
        window_start = now - self.window

        # 清除過期的請求紀錄
        self._requests[client_id] = [
            t for t in self._requests[client_id] if t > window_start
        ]

        if len(self._requests[client_id]) < self.max_requests:
            self._requests[client_id].append(now)
            return True
        return False

# 測試：每 10 秒最多 3 次請求
limiter = RateLimiter(max_requests=3, window_seconds=10)

for i in range(5):
    allowed = limiter.allow("user_001")
    status = "允許" if allowed else "拒絕 (429 Too Many Requests)"
    print(f"  請求 {i+1}: {status}")
```

輸出：
```
  請求 1: 允許
  請求 2: 允許
  請求 3: 允許
  請求 4: 拒絕 (429 Too Many Requests)
  請求 5: 拒絕 (429 Too Many Requests)
```

---

## 10. 程式碼品質

### 10.1 Clean Code 原則

| 原則 | 說明 | 範例 |
|------|------|------|
| 有意義的命名 | 變數名要說明用途 | `elapsed_time_in_days` 而非 `d` |
| 函式要短 | 一個函式做一件事 | 控制在 20 行以內 |
| 避免副作用 | 函式不要偷偷改外部狀態 | 明確標示會修改的參數 |
| DRY | Don't Repeat Yourself | 重複邏輯抽成函式 |
| KISS | Keep It Simple, Stupid | 不要過度設計 |
| YAGNI | You Aren't Gonna Need It | 不要預先寫未來才需要的功能 |

### 10.2 命名慣例

| 語言 | 變數/函式 | 類別 | 常數 | 檔案 |
|------|----------|------|------|------|
| Python | snake_case | PascalCase | UPPER_SNAKE | snake_case.py |
| JavaScript/TS | camelCase | PascalCase | UPPER_SNAKE | camelCase.ts |
| Go | camelCase | PascalCase | PascalCase | lowercase.go |
| Rust | snake_case | PascalCase | UPPER_SNAKE | snake_case.rs |
| C++ | snake_case 或 camelCase | PascalCase | kPascalCase | snake_case.cpp |

### 10.3 Code Review 重點

```
Code Review 檢查清單：

功能性
  [ ] 程式碼是否正確實現需求？
  [ ] 邊界條件是否處理？
  [ ] 錯誤處理是否完善？

可讀性
  [ ] 命名是否清楚？
  [ ] 註解是否必要且正確？
  [ ] 函式是否太長？（> 50 行要警覺）

效能
  [ ] 有沒有不必要的 O(n²) 迴圈？
  [ ] 大量資料是否用了適當的資料結構？
  [ ] 有沒有 N+1 查詢問題？

安全性
  [ ] 輸入有沒有驗證？
  [ ] 有沒有 SQL Injection 風險？
  [ ] 敏感資訊有沒有寫死在程式碼裡？

測試
  [ ] 有沒有對應的測試？
  [ ] 測試是否涵蓋邊界條件？
```

### 10.4 技術債 (Technical Debt)

```
                高
  影  ┌──────────────────┐
  響  │  魯莽且故意的     │  魯莽且無意的
  程  │  「我們沒時間     │  「什麼是分層
  度  │    做設計」       │    架構？」
      ├──────────────────┤
      │  謹慎且故意的     │  謹慎且無意的
      │  「先上線，       │  「現在才知道
      │    之後再重構」   │    該怎麼做」
  低  └──────────────────┘
      故意                無意
```

管理策略：定期安排「重構衝刺」，新功能開發前先還舊債，
用 TODO 和 FIXME 標記，在 issue tracker 追蹤。

### 10.5 重構技巧

```python
# --- 重構前：巢狀條件式 ---
def get_shipping_cost_before(order: dict) -> float:
    if order.get("is_member"):
        if order["total"] > 1000:
            return 0
        else:
            return 50
    else:
        if order["total"] > 2000:
            return 0
        else:
            if order["weight"] > 10:
                return 200
            else:
                return 100

# --- 重構後：Guard Clause（提前返回）---
def get_shipping_cost_after(order: dict) -> float:
    is_member = order.get("is_member", False)
    total = order["total"]
    weight = order.get("weight", 0)

    # 會員免運門檻
    if is_member and total > 1000:
        return 0.0

    # 非會員免運門檻
    if not is_member and total > 2000:
        return 0.0

    # 會員基本運費
    if is_member:
        return 50.0

    # 非會員依重量
    return 200.0 if weight > 10 else 100.0
```

---

## 11. 開發者工具箱

### 11.1 IDE: VS Code 必裝插件

| 插件 | 用途 |
|------|------|
| Python (Pylance) | Python 智慧提示、型別檢查 |
| ESLint | JavaScript/TypeScript 程式碼檢查 |
| Prettier | 自動格式化 |
| GitLens | Git 歷史視覺化 |
| Docker | Dockerfile 語法、容器管理 |
| Remote - SSH | 遠端開發 |
| GitHub Copilot | AI 程式碼建議 |
| Error Lens | 行內顯示錯誤訊息 |
| Thunder Client | API 測試（輕量版 Postman） |

### 11.2 Terminal 工具

```bash
# oh-my-zsh — 更強大的 shell
sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"

# 常用插件
# ~/.zshrc
plugins=(git zsh-autosuggestions zsh-syntax-highlighting)

# tmux — 終端多工器
tmux new -s dev        # 新建 session
# Ctrl+b % → 垂直分割
# Ctrl+b " → 水平分割
# Ctrl+b d → 分離 session
tmux attach -t dev     # 重新連線
```

### 11.3 API 測試

```bash
# curl — 命令列 HTTP 用戶端
# GET 請求
curl -s https://api.example.com/users | jq '.'

# POST 請求（帶 JSON body）
curl -X POST https://api.example.com/users \
  -H "Content-Type: application/json" \
  -d '{"name": "Alice", "email": "alice@mail.com"}'

# 帶認證的請求
curl -H "Authorization: Bearer YOUR_TOKEN" \
  https://api.example.com/protected

# httpie — 更友善的 HTTP 用戶端
http GET https://api.example.com/users
http POST https://api.example.com/users name="Alice" email="alice@mail.com"
```

### 11.4 效能分析

```python
# --- Python cProfile ---
import cProfile

def slow_function():
    total = 0
    for i in range(1000000):
        total += i ** 2
    return total

cProfile.run("slow_function()")

# --- 用 line_profiler 逐行分析 ---
# pip install line_profiler
# 在函式上加 @profile，然後跑：
# kernprof -l -v script.py

# --- 簡易計時裝飾器 ---
import time
from functools import wraps

def timer(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        result = func(*args, **kwargs)
        elapsed = time.perf_counter() - start
        print(f"[{func.__name__}] 耗時: {elapsed:.4f}s")
        return result
    return wrapper

@timer
def process_data():
    time.sleep(0.5)
    return sum(range(1000000))

process_data()  # [process_data] 耗時: 0.5xxx s
```

### 11.5 文件工具

| 工具 | 語言 | 說明 |
|------|------|------|
| Swagger / OpenAPI | REST API | API 文件標準，自動生成互動式文件 |
| JSDoc | JavaScript | `/** @param {string} name */` |
| Sphinx | Python | reStructuredText 格式，自動從 docstring 生成 |
| rustdoc | Rust | `/// 文件註解`，`cargo doc` 自動生成 |
| Doxygen | C/C++ | 多語言支援的文件產生器 |

---

## 12. 學習路線圖

### 12.1 通用軟體工程路線

```
初級 (0-6 個月)                    中級 (6-18 個月)
┌─────────────────────┐           ┌─────────────────────┐
│ ✦ 一門語言精通        │           │ ✦ 第二門語言          │
│   (推薦 Python)      │           │ ✦ 資料結構與演算法     │
│ ✦ Git 版本控制        │    ──→    │ ✦ SQL + NoSQL        │
│ ✦ 基本資料結構        │           │ ✦ REST API 設計      │
│ ✦ HTTP 基礎          │           │ ✦ Docker 容器化       │
│ ✦ CLI 基本操作        │           │ ✦ 單元測試 + CI/CD   │
└─────────────────────┘           └─────────┬───────────┘
                                            │
                                            ▼
高級 (18-36 個月)                  專家 (36+ 個月)
┌─────────────────────┐           ┌─────────────────────┐
│ ✦ 設計模式           │           │ ✦ 分散式系統          │
│ ✦ 系統設計           │           │ ✦ 架構決策           │
│ ✦ 微服務架構         │    ──→    │ ✦ 技術領導力          │
│ ✦ 訊息佇列           │           │ ✦ 效能調優           │
│ ✦ 快取策略           │           │ ✦ 開源貢獻           │
│ ✦ Kubernetes        │           │ ✦ 跨領域知識          │
└─────────────────────┘           └─────────────────────┘
```

### 12.2 前端專精路線

```
HTML/CSS/JS 基礎
       │
       ▼
TypeScript（EP04 已涵蓋）
       │
       ▼
React 或 Vue.js（選一精通）
       │
       ▼
狀態管理 (Redux/Pinia) + 路由
       │
       ▼
SSR/SSG (Next.js / Nuxt)
       │
       ▼
測試 (Jest/Vitest) + E2E (Playwright)
       │
       ▼
效能優化 + Web Vitals + PWA
```

### 12.3 後端專精路線

```
Python (Django/FastAPI) 或 Go (Gin/Echo)
       │
       ▼
PostgreSQL + Redis
       │
       ▼
RESTful API + GraphQL
       │
       ▼
Docker + Kubernetes
       │
       ▼
微服務 + gRPC + Message Queue (Kafka/RabbitMQ)
       │
       ▼
監控 (Prometheus/Grafana) + 日誌 (ELK Stack)
       │
       ▼
系統設計 + 高可用架構
```

### 12.4 NVIDIA 特別路線

```
EP01-02: Python 精通
    │
    ▼
EP03: C++ 核心（記憶體管理、指標、模板）
    │
    ▼
CUDA 程式設計
  ├─ GPU 架構基礎 (SM, Warp, Thread Block)
  ├─ CUDA Kernel 撰寫
  ├─ 記憶體層級 (Global, Shared, Register)
  └─ 效能優化 (Coalescing, Bank Conflict)
    │
    ▼
深度學習框架底層
  ├─ PyTorch C++ Extension
  ├─ 自定義 CUDA Operator
  └─ TorchScript / LibTorch
    │
    ▼
TensorRT 推論優化
  ├─ ONNX 模型匯出
  ├─ TensorRT Plugin
  ├─ FP16/INT8 量化
  └─ Dynamic Shape 處理
    │
    ▼
Triton Inference Server
  ├─ 模型部署與管理
  ├─ Dynamic Batching
  ├─ Model Ensemble
  └─ gRPC/HTTP Endpoint
    │
    ▼
進階主題
  ├─ NCCL 多卡通訊
  ├─ CUDA Graph
  ├─ Nsight 效能分析
  └─ CUTLASS (矩陣運算模板)
```

### 12.5 MLOps / AI 工程路線

```
機器學習基礎
  ├─ scikit-learn
  ├─ 特徵工程
  └─ 模型評估
    │
    ▼
深度學習
  ├─ PyTorch（推薦）
  ├─ CNN / RNN / Transformer
  └─ 遷移學習
    │
    ▼
MLOps
  ├─ 實驗追蹤 (MLflow, Weights & Biases)
  ├─ 資料版控 (DVC)
  ├─ 模型版控 (MLflow Model Registry)
  └─ 特徵商店 (Feast)
    │
    ▼
模型部署
  ├─ TensorRT / ONNX Runtime
  ├─ Triton Inference Server
  ├─ FastAPI 模型 API
  └─ Kubernetes + Helm
    │
    ▼
監控與維運
  ├─ 模型飄移偵測
  ├─ A/B 測試
  └─ 自動重訓練管線
```

---

## 總結：EP01–EP10 系列回顧

```
EP01  Python 從入門到專案級別     ← 語言基石
EP02  Python 專案架構             ← 工程化能力
EP03  C++ — NVIDIA 必備語言      ← 系統級語言
EP04  JavaScript/TypeScript      ← 全端開發
EP05  Go — 高效並發程式設計       ← 雲端原生語言
EP06  Rust — 安全系統程式語言     ← 次世代系統語言
EP07–EP09  (工具鏈與領域專題)
EP10  設計模式與進階架構           ← 你在這裡 ★
```

恭喜你完成整個系列！記住：

1. **設計模式不是銀彈** — 不要為了用而用，先理解問題再選擇方案
2. **先讓它能動，再讓它正確，最後讓它快** — Kent Beck
3. **最好的程式碼是不需要寫的程式碼** — 避免過度工程
4. **持續學習** — 技術日新月異，但基礎原理歷久彌新

> 「程式設計不只是告訴電腦怎麼做，更是告訴人類你想做什麼。」— Donald Knuth

---

*EP10 完 — 設計模式與進階架構 | 系列完結*
