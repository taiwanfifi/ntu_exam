# 積體電路設計 題庫與詳解

> **涵蓋範圍**：台大電機系「VLSI設計」與「積體電路設計」核心主題
> **參考教材**：Weste/Harris《CMOS VLSI Design》、Rabaey《Digital Integrated Circuits》、Baker《CMOS Circuit Design, Layout, and Simulation》
> **題數**：60 題（分 6 個 Part，每 Part 10 題）
> **適用對象**：博士資格考、TSMC / MTK / Realtek 面試準備

---

## Part 1：CMOS 基礎與反相器（題目 1–10）

---
### 題目 1：CMOS 製程基礎——N-well 與 Twin-well
**來源**：台大電機 / 經典題型
**難度**：★★☆☆☆
**主題**：CMOS 製程概述

**題目**：
請說明 CMOS 製程中 N-well、P-well 與 Twin-well（雙井）三種方式的差異。繪製 N-well CMOS 的剖面結構示意圖，標示 NMOS 與 PMOS 的位置，並回答：
(a) 為何早期製程偏好 N-well？
(b) 先進製程為何改用 Twin-well？
(c) 在 N-well 製程中，PMOS 的基體（Body）接到哪裡？NMOS 呢？

**詳解**：

**解題思路**：從基板選擇與載子遷移率出發，分析各製程優缺點。

**步驟**：

(a) N-well 製程偏好原因：
- P 型基板（P-substrate）上直接製作 NMOS，再於 N-well 中製作 PMOS
- 電子遷移率（Electron Mobility）約為電洞遷移率的 2–3 倍
- NMOS 直接做在基板上，寄生效應較小，速度較快
- 早期製程以 NMOS 性能為優先考量

```
  N-well CMOS 剖面圖：

       PMOS                    NMOS
  ┌─S──┬─G──┬─D─┐      ┌─S──┬─G──┬─D─┐
  │ p+ │    │ p+ │      │ n+ │    │ n+ │
  ├────┴────┴────┤      ├────┴────┴────┤
  │   N-well     │      │              │
  │  (VDD接n+)   │      │              │
  ├──────────────┴──────┴──────────────┤
  │            P-substrate (GND)       │
  └────────────────────────────────────┘
```

(b) Twin-well 製程優勢：
- 同時具備 N-well 與 P-well，可獨立最佳化 NMOS 與 PMOS 的摻雜濃度
- 閾值電壓（Threshold Voltage, Vth）可分別調整
- 先進製程需要精確控制兩種電晶體特性
- 降低 Latch-up 風險（井隔離更佳）

(c) 基體連接：
- PMOS 的基體（N-well）接到 VDD
- NMOS 的基體（P-substrate）接到 GND
- 確保所有 PN 接面（Junction）維持逆偏（Reverse Bias）

**答案**：N-well 利用 P 基板上的高電子遷移率優化 NMOS；Twin-well 可獨立調整雙方閾值電壓，適合先進製程；PMOS body 接 VDD，NMOS body 接 GND。

**延伸思考**：在 TSMC 先進節點（如 N3/N2），已採用 FinFET 甚至 GAAFET（Gate-All-Around）結構，well 的概念演變為 Fin 結構下的摻雜區設計。面試時常被問及 Bulk CMOS 與 FinFET 的 well 差異。

---
### 題目 2：CMOS 反相器 VTC 曲線五個工作區域
**來源**：台大電機 / 必考經典
**難度**：★★★☆☆
**主題**：CMOS 反相器 VTC 分析

**題目**：
考慮一個 CMOS 反相器，NMOS 參數為 Vtn = 0.4V、kn' = 200 μA/V²、(W/L)n = 2，PMOS 參數為 |Vtp| = 0.4V、kp' = 100 μA/V²、(W/L)p = 4，VDD = 1.8V。
(a) 列出 VTC（Voltage Transfer Characteristic）曲線的五個操作區域，寫出每區域中 NMOS 與 PMOS 的工作狀態。
(b) 計算開關閾值 VM。
(c) 計算 VOH、VOL、VIH、VIL 以及雜訊邊限 NMH、NML。

**詳解**：

**解題思路**：逐一分析五區域的電晶體狀態，利用電流連續條件求解 VM。

**步驟**：

先計算等效參數：
- βn = kn'·(W/L)n = 200 × 2 = 400 μA/V²
- βp = kp'·(W/L)p = 100 × 4 = 400 μA/V²
- βn/βp = 1（對稱設計）

(a) 五個操作區域（Vin 從 0 → VDD）：

| 區域 | Vin 範圍 | NMOS 狀態 | PMOS 狀態 | Vout |
|------|---------|-----------|-----------|------|
| 1 | 0 ≤ Vin < Vtn | 截止(Cutoff) | 線性(Linear) | VOH = VDD |
| 2 | Vtn ≤ Vin < VM | 飽和(Sat) | 線性(Linear) | 高→降 |
| 3 | Vin ≈ VM | 飽和(Sat) | 飽和(Sat) | VM |
| 4 | VM < Vin ≤ VDD+Vtp | 線性(Linear) | 飽和(Sat) | 降→低 |
| 5 | VDD+Vtp < Vin ≤ VDD | 線性(Linear) | 截止(Cutoff) | VOL = 0 |

(b) 計算 VM（開關閾值，Switching Threshold）：

在 VM 點，NMOS 與 PMOS 均飽和，令 Vin = Vout = VM，IDn = IDp：

公式：VM = (VDD + Vtp + Vtn·√(βn/βp)) / (1 + √(βn/βp))

代入 βn/βp = 1：
VM = (1.8 + (-0.4) + 0.4·√1) / (1 + √1)
VM = (1.8 - 0.4 + 0.4) / 2
VM = 1.8 / 2 = **0.9V = VDD/2**

這是對稱設計的結果：當 βn = βp 且 |Vtn| = |Vtp| 時，VM = VDD/2。

(c) 計算雜訊邊限：

VOH = VDD = 1.8V（PMOS 線性區拉至 VDD）
VOL = 0V（NMOS 線性區拉至 GND）

VIL 定義：dVout/dVin = -1 的低端點
VIH 定義：dVout/dVin = -1 的高端點

對於對稱反相器的近似公式：
VIL ≈ (3VDD + 8Vtn) / (3·(1 + √(βn/βp)) + 8) - 修正近似
簡化對稱情形（βn = βp, |Vtn| = |Vtp| = 0.4V）：
VIL ≈ 3/8 · VDD = 3/8 × 1.8 ≈ 0.675V（精確需微分求解）
VIH ≈ 5/8 · VDD = 5/8 × 1.8 ≈ 1.125V

雜訊邊限：
NMH = VOH - VIH = 1.8 - 1.125 = **0.675V**
NML = VIL - VOL = 0.675 - 0 = **0.675V**

對稱反相器有 NMH = NML，雜訊邊限最大化。

**答案**：VM = 0.9V；NMH = NML ≈ 0.675V；對稱設計使開關閾值位於 VDD/2 且雜訊邊限最大。

**延伸思考**：台積電製程中，因 PMOS 遷移率較低，需 (W/L)p ≈ 2–3 倍 (W/L)n 才能達到對稱。面試常問「如何調整 VM？」——改變 βn/βp 比值即可。

---
### 題目 3：CMOS 反相器傳播延遲計算
**來源**：台大電機 / TSMC 面試
**難度**：★★★☆☆
**主題**：CMOS 反相器動態特性

**題目**：
一個 CMOS 反相器驅動負載電容 CL = 50 fF。NMOS 等效電阻 Reqn = 10 kΩ，PMOS 等效電阻 Reqp = 25 kΩ。
(a) 計算下降傳播延遲 tpHL 與上升傳播延遲 tpLH。
(b) 計算平均傳播延遲 tpd。
(c) 若要使 tpHL = tpLH（對稱延遲），PMOS 的 W/L 應為 NMOS 的幾倍？
(d) 若該反相器扇出為 4（FO4），且自身輸入電容 Cin = 12 fF，估算 FO4 延遲。

**詳解**：

**解題思路**：使用一階 RC 模型 tp = 0.69·Req·CL。

**步驟**：

(a) 傳播延遲：
- tpHL = 0.69 · Reqn · CL = 0.69 × 10kΩ × 50fF
  = 0.69 × 10×10³ × 50×10⁻¹⁵ = 0.69 × 500×10⁻¹² = **345 ps**

- tpLH = 0.69 · Reqp · CL = 0.69 × 25kΩ × 50fF
  = 0.69 × 25×10³ × 50×10⁻¹⁵ = 0.69 × 1250×10⁻¹² = **862.5 ps**

(b) 平均傳播延遲：
tpd = (tpHL + tpLH) / 2 = (345 + 862.5) / 2 = **603.75 ps**

(c) 對稱延遲條件：
要求 Reqp = Reqn，因 Req ∝ 1/(μ·Cox·W/L)：
Reqp/Reqn = (μn/μp) · (W/L)n/(W/L)p = 1

現在 Reqp/Reqn = 25/10 = 2.5
所以需要 (W/L)p = 2.5 × (W/L)n

**PMOS 的 W/L 應為 NMOS 的 2.5 倍。**

(d) FO4 延遲估算：
FO4 負載 = 4 × Cin = 4 × 12fF = 48fF（加上自身擴散電容，約 ≈ 50fF，恰好符合）

使用對稱設計（調整後 Reqn = Reqp = 10kΩ）：
tpd(FO4) = 0.69 × 10kΩ × (4 × 12fF + Cself)

更精確：若包含自身寄生 Cself ≈ 2fF：
tpd(FO4) ≈ 0.69 × 10kΩ × 50fF ≈ **345 ps**

實際先進製程中 FO4 延遲是衡量製程速度的關鍵指標：
- 180nm: ~80ps
- 65nm: ~25ps
- 7nm: ~5ps

**答案**：tpHL = 345ps，tpLH = 862.5ps，tpd = 603.75ps；PMOS 需 2.5 倍寬度達到對稱。

**延伸思考**：FO4 delay 是 TSMC 製程開發的核心量度指標。面試常問「為何用 FO4 而非絕對延遲？」——因 FO4 排除了負載效應，能純粹反映製程內在速度。

---
### 題目 4：CMOS 反相器功率消耗完整分析
**來源**：台大電機 / MTK 面試必考
**難度**：★★★☆☆
**主題**：CMOS 功率消耗

**題目**：
一個 CMOS 反相器工作於 VDD = 1.0V，負載電容 CL = 20 fF，工作頻率 f = 1 GHz，切換活動因子（Activity Factor）α = 0.15。已知短路電流峰值 Ipeak = 50 μA，短路持續時間 tsc = 100 ps（上升與下降各一次），漏電流 Ileak = 10 nA。
(a) 計算動態切換功率 Pdyn。
(b) 計算短路功率 Psc。
(c) 計算靜態漏電功率 Pstatic。
(d) 計算總功率與各成份比例。
(e) 若 VDD 由 1.0V 降至 0.7V（其他不變），動態功率減少多少百分比？

**詳解**：

**解題思路**：分別套用三項功率公式，注意各參數單位。

**步驟**：

(a) 動態切換功率：
Pdyn = α · CL · VDD² · f
= 0.15 × 20×10⁻¹⁵ × (1.0)² × 1×10⁹
= 0.15 × 20×10⁻⁶
= **3.0 μW**

(b) 短路功率：
每個週期有兩次切換（上升+下降），每次短路持續 tsc：
Psc ≈ Ipeak_avg · VDD · 2tsc · f（近似三角波取平均 Ipeak/2）
= (50×10⁻⁶ / 2) × 1.0 × 2 × 100×10⁻¹² × 1×10⁹
= 25×10⁻⁶ × 200×10⁻³
= **5.0 μW**

更嚴謹：考慮活動因子 α：
Psc = α × Ipeak_avg × VDD × 2tsc × f = 0.15 × 5.0 = **0.75 μW**

(c) 靜態漏電功率：
Pstatic = Ileak · VDD = 10×10⁻⁹ × 1.0 = **10 nW = 0.01 μW**

(d) 總功率（使用含 α 的短路功率）：
Ptotal = Pdyn + Psc + Pstatic = 3.0 + 0.75 + 0.01 = **3.76 μW**

比例：
- 動態功率：3.0/3.76 ≈ 79.8%（主導）
- 短路功率：0.75/3.76 ≈ 19.9%
- 靜態功率：0.01/3.76 ≈ 0.3%

(e) VDD 由 1.0V 降至 0.7V：
Pdyn(new) / Pdyn(old) = (0.7)² / (1.0)² = 0.49

**動態功率減少 51%。**

這就是電壓縮放（Voltage Scaling）效果強大的原因——功率與 VDD² 成正比。

**答案**：Pdyn = 3.0μW，Psc ≈ 0.75μW，Pstatic = 0.01μW，Ptotal ≈ 3.76μW；降壓至 0.7V 可省 51% 動態功率。

**延伸思考**：在先進節點（7nm 以下），Ileak 大幅增加，Pstatic 可能超過 Pdyn 成為主要功耗來源。TSMC/MTK 面試必問「如何降低漏電？」——答案包括 Multi-Vth、Power Gating、Body Biasing 等技術。

---
### 題目 5：反相器鏈最佳化——邏輯努力法
**來源**：台大電機 / 經典題型
**難度**：★★★★☆
**主題**：邏輯努力（Logical Effort）

**題目**：
一個最小尺寸反相器（輸入電容 Cin = 3fF）需驅動 CL = 192 fF 的負載。
(a) 計算電氣努力（Electrical Effort）F = CL/Cin。
(b) 若使用 N 級反相器鏈，每級的最佳扇出為多少？最佳級數 N 為何？
(c) 計算每級的尺寸（輸入電容）。
(d) 比較直接驅動 vs 最佳化鏈的延遲比。

**詳解**：

**解題思路**：應用 Logical Effort（邏輯努力）理論，反相器的邏輯努力 g = 1，寄生延遲 p = 1。

**步驟**：

(a) 電氣努力：
F = CL / Cin = 192 / 3 = **64**

(b) 最佳扇出與級數：
每級最佳扇出 f_opt ≈ e ≈ 2.72（理論值）
實務上取 f_opt ≈ 3.6（考慮寄生延遲 p = 1 的反相器）

最佳級數：N = ln(F) / ln(f_opt)
= ln(64) / ln(3.6) = 4.16 / 1.28 ≈ 3.25

取 **N = 3** 或 N = 4（取整數，需比較兩者延遲）

N = 3 時：每級扇出 f = F^(1/3) = 64^(1/3) = **4**
N = 4 時：每級扇出 f = 64^(1/4) = 2.83

比較延遲：
- N = 3：D = 3(f + p) = 3(4 + 1) = 15 τ
- N = 4：D = 4(2.83 + 1) = 4(3.83) = 15.32 τ

N = 3 略優，選 **N = 3，每級扇出 f = 4**。

(c) 每級尺寸（輸入電容）：
- 第 1 級：C₁ = Cin = 3 fF
- 第 2 級：C₂ = f · C₁ = 4 × 3 = 12 fF
- 第 3 級：C₃ = f · C₂ = 4 × 12 = 48 fF
- 驗證：C₃ · f = 48 × 4 = 192 fF = CL ✓

(d) 延遲比較：
直接驅動（N = 1）：
D_direct = F + p = 64 + 1 = 65 τ

最佳化鏈（N = 3）：
D_opt = 15 τ

**延遲改善比 = 65/15 ≈ 4.3 倍！**

**答案**：F = 64，最佳 N = 3 級每級扇出 4，尺寸為 3→12→48 fF，延遲改善約 4.3 倍。

**延伸思考**：邏輯努力法是 Sutherland/Sproull/Harris 提出的經典方法，在實際 EDA 工具中用於 buffer tree 合成。TSMC 標準元件庫提供多種驅動強度（X1, X2, X4, X8...）正是為了此目的。

---
### 題目 6：反相器尺寸對 VM 的影響
**來源**：台大電機 / 經典計算
**難度**：★★★☆☆
**主題**：CMOS 反相器開關閾值調整

**題目**：
VDD = 1.8V，Vtn = 0.5V，|Vtp| = 0.5V，μn·Cox = 200 μA/V²，μp·Cox = 80 μA/V²。
(a) 若 (W/L)n = (W/L)p = 1（即未做尺寸調整），計算 VM。
(b) 求使 VM = VDD/2 = 0.9V 所需的 (W/L)p/(W/L)n 比值。
(c) 若設計需求 VM = 0.6·VDD = 1.08V（偏高閾值，適合低雜訊邊限高端應用），求所需比值。

**詳解**：

**解題思路**：使用 VM 公式，逐步代入求解。

**步驟**：

VM 公式：
VM = [VDD + Vtp + Vtn·√(βn/βp)] / [1 + √(βn/βp)]

其中 βn = μn·Cox·(W/L)n，βp = μp·Cox·(W/L)p

(a) (W/L)n = (W/L)p = 1 時：
βn = 200 μA/V²，βp = 80 μA/V²
βn/βp = 200/80 = 2.5
√(βn/βp) = √2.5 = 1.581

VM = [1.8 + (-0.5) + 0.5 × 1.581] / [1 + 1.581]
= [1.8 - 0.5 + 0.7906] / [2.581]
= 2.0906 / 2.581
= **0.810V**

VM < VDD/2 = 0.9V，因為 NMOS 較強導致輸出偏低。

(b) 求 VM = 0.9V 時的尺寸比：
令 r = √(βn/βp)

0.9 = [1.8 - 0.5 + 0.5r] / [1 + r]
0.9(1 + r) = 1.3 + 0.5r
0.9 + 0.9r = 1.3 + 0.5r
0.4r = 0.4
r = 1，即 βn/βp = 1

βn/βp = [μn·Cox·(W/L)n] / [μp·Cox·(W/L)p] = 1
(W/L)p / (W/L)n = μn·Cox / μp·Cox = 200/80 = **2.5**

(c) 求 VM = 1.08V：
1.08 = [1.3 + 0.5r] / [1 + r]
1.08 + 1.08r = 1.3 + 0.5r
0.58r = 0.22
r = 0.3793
βn/βp = r² = 0.1439

(W/L)p / (W/L)n = (μn/μp) / (βn/βp) = 2.5 / 0.1439 = **17.37**

需要非常大的 PMOS 才能將 VM 推高到 1.08V，實務上不太合理。

**答案**：(a) VM = 0.810V；(b) (W/L)p/(W/L)n = 2.5；(c) 比值約 17.4，實務上過大。

**延伸思考**：在標準元件庫設計中，通常取 βn = βp（即 Wp/Wn ≈ 2–3）作為預設。特殊應用如 Schmitt Trigger 會刻意設計不對稱的 VM。

---
### 題目 7：反相器上升/下降時間與延遲的精確分析
**來源**：台大電機 / 經典題型
**難度**：★★★★☆
**主題**：反相器暫態分析

**題目**：
CMOS 反相器參數：VDD = 1.8V，Vtn = |Vtp| = 0.4V，βn = 400 μA/V²，βp = 200 μA/V²，CL = 100 fF。假設輸入為理想階梯波（Step Input）。
(a) 推導輸出從 VDD 下降至 VDD/2 的 tpHL 表達式（需考慮 NMOS 先飽和後線性的兩階段）。
(b) 數值計算 tpHL。
(c) 比較一階 RC 近似與精確值的差異。

**詳解**：

**解題思路**：輸入由 0→VDD 的階梯波，NMOS 開啟放電。分兩階段：飽和區放電（Vout 從 VDD 到 VDD-Vtn）與線性區放電（VDD-Vtn 到 VDD/2）。

**步驟**：

(a) 推導 tpHL：

**階段一**：Vout 從 VDD 下降到 VDD - Vtn（NMOS 飽和）
VGS = VDD，VDS = Vout > VGS - Vtn = VDD - Vtn
IDsat = (βn/2)(VDD - Vtn)²

CL · dVout/dt = -IDsat（恆流放電）

t₁ = CL · ΔV / IDsat = CL · Vtn / [(βn/2)(VDD-Vtn)²]

代入：t₁ = 100fF × 0.4V / [200μA/V² × (1.4)²]
= 40×10⁻¹⁵ / (200×10⁻⁶ × 1.96)
= 40×10⁻¹⁵ / 392×10⁻⁶
= **102.0 ps**

**階段二**：Vout 從 VDD - Vtn 下降到 VDD/2（NMOS 線性區）
VDS = Vout < VGS - Vtn
IDlin = βn[(VDD - Vtn)Vout - Vout²/2]

CL · dVout/dt = -βn[(VDD-Vtn)Vout - Vout²/2]

此微分方程需積分：
t₂ = CL/βn · ∫[VDD/2 to VDD-Vtn] dVout / [(VDD-Vtn)Vout - Vout²/2]

令 a = VDD - Vtn = 1.4V：
t₂ = (CL/βn) · [1/a · ln(2aV - V²)]，從 V = VDD/2 到 V = a

計算後：
t₂ = (CL/βn) · (1/a) · ln[(2a² - a²) / (2a·VDD/2 - (VDD/2)²)]
= (100fF/400μA/V²) · (1/1.4) · ln[a² / (a·VDD - VDD²/4)]
= 250ps · (1/1.4) · ln[1.96 / (1.4×1.8 - 0.81)]
= 178.6ps · ln[1.96 / 1.71]
= 178.6ps × 0.1363
= **24.3 ps**

(b) 數值結果：
tpHL = t₁ + t₂ = 102.0 + 24.3 = **126.3 ps**

(c) 一階 RC 近似比較：
Reqn = VDD / (2·IDsat) ≈ 1.8 / (2 × 392μA) ≈ ...

更常用：Reqn ≈ 3VDD/(4βn(VDD-Vtn)²) ，取平均電阻概念
簡化：Reqn ≈ 1/(βn(VDD-Vtn)) = 1/(400μ × 1.4) = 1.786 kΩ

tpHL(RC) = 0.69 · Reqn · CL = 0.69 × 1.786kΩ × 100fF = **123.2 ps**

精確值 126.3ps vs RC 近似 123.2ps，誤差約 2.5%，RC 模型在此情境相當準確。

**答案**：tpHL ≈ 126.3ps（精確）vs 123.2ps（RC 近似），誤差約 2.5%。

**延伸思考**：精確的暫態分析在高速設計中很重要。SPICE 模擬使用 BSIM 模型可達到更高精確度。面試中通常使用 RC 近似即可，但需知道其推導來源。

---
### 題目 8：反相器功耗延遲積（PDP）與能量延遲積（EDP）
**來源**：台大電機 / 經典題型
**難度**：★★★☆☆
**主題**：功耗延遲最佳化

**題目**：
反相器參數：CL = 30 fF，f = 500 MHz，α = 0.2。比較三種操作條件的 PDP 與 EDP：
| 條件 | VDD | tpd |
|------|-----|-----|
| A | 1.8V | 50ps |
| B | 1.2V | 100ps |
| C | 0.8V | 300ps |

(a) 計算三種條件的動態功率。
(b) 計算 PDP（Power-Delay Product，每次切換的能量）。
(c) 計算 EDP（Energy-Delay Product）。
(d) 哪種條件在 PDP 最佳？哪種在 EDP 最佳？

**詳解**：

**解題思路**：PDP = Pdyn/f = α·CL·VDD²（每次切換能量），EDP = PDP·tpd。

**步驟**：

(a) 動態功率 Pdyn = α·CL·VDD²·f：

| 條件 | Pdyn |
|------|------|
| A | 0.2 × 30fF × (1.8)² × 500MHz = 0.2 × 30e-15 × 3.24 × 5e8 = **9.72 μW** |
| B | 0.2 × 30fF × (1.2)² × 500MHz = 0.2 × 30e-15 × 1.44 × 5e8 = **4.32 μW** |
| C | 0.2 × 30fF × (0.8)² × 500MHz = 0.2 × 30e-15 × 0.64 × 5e8 = **1.92 μW** |

(b) PDP（每次切換能量）= α·CL·VDD²：

| 條件 | PDP |
|------|-----|
| A | 0.2 × 30fF × 3.24 = **19.44 fJ** |
| B | 0.2 × 30fF × 1.44 = **8.64 fJ** |
| C | 0.2 × 30fF × 0.64 = **3.84 fJ** |

(c) EDP = PDP × tpd：

| 條件 | EDP |
|------|-----|
| A | 19.44fJ × 50ps = **972.0 × 10⁻²⁷ J·s** |
| B | 8.64fJ × 100ps = **864.0 × 10⁻²⁷ J·s** |
| C | 3.84fJ × 300ps = **1152.0 × 10⁻²⁷ J·s** |

(d) 分析：
- **PDP 最佳：條件 C**（0.8V），能量最低但速度最慢
- **EDP 最佳：條件 B**（1.2V），在能量與速度間取得最佳平衡

EDP 是更好的效能指標，因為它同時考慮了能量與速度。理論上 EDP 最佳化的 VDD 約為 3Vth 附近。

**答案**：PDP 最佳為低 VDD（條件 C）；EDP 最佳為中等 VDD（條件 B）。EDP 是更全面的效能指標。

**延伸思考**：DVFS（Dynamic Voltage and Frequency Scaling）的核心概念正是在 EDP 曲線上動態選擇最佳工作點。手機 SoC 的 big.LITTLE 架構中，大核心與小核心的 VDD 設定正是基於此原理。

---
### 題目 9：CMOS 反相器寄生電容詳細分析
**來源**：台大電機 / 業界面試
**難度**：★★★★☆
**主題**：寄生電容與延遲

**題目**：
考慮 CMOS 反相器如下圖，NMOS: W = 0.4μm, L = 0.18μm；PMOS: W = 0.8μm, L = 0.18μm。製程參數：
- 閘氧化層電容 Cox = 8.6 fF/μm²
- NMOS 重疊電容 Cov,n = 0.3 fF/μm（每單位寬度）
- PMOS 重疊電容 Cov,p = 0.3 fF/μm
- NMOS 擴散區接面電容 Cj,n = 1.0 fF/μm²（面積）+ Cjsw,n = 0.3 fF/μm（周長）
- PMOS 擴散區接面電容 Cj,p = 1.2 fF/μm²（面積）+ Cjsw,p = 0.35 fF/μm
- 擴散區長度（Source/Drain）= 3λ = 0.27μm

(a) 計算輸入電容 Cin。
(b) 計算內部自載電容（Self-loading，輸出節點的寄生電容）Cint。
(c) 若驅動相同的反相器（FO1），計算總負載電容 CL = Cint + Cin(next)。

**詳解**：

**解題思路**：分別計算閘極電容（輸入端）與擴散區電容（輸出端）。

**步驟**：

(a) 輸入電容 Cin：
輸入端看到 NMOS 與 PMOS 的閘極電容：

Cin = Cgate,n + Cgate,p + Cov（重疊電容在輸入端的分量）

閘極電容：
Cgate,n = Cox × Wn × Ln = 8.6 × 0.4 × 0.18 = 0.619 fF
Cgate,p = Cox × Wp × Lp = 8.6 × 0.8 × 0.18 = 1.238 fF

重疊電容（Gate-Source 與 Gate-Drain 各一）：
Cov_in,n = 2 × Cov,n × Wn = 2 × 0.3 × 0.4 = 0.24 fF
Cov_in,p = 2 × Cov,p × Wp = 2 × 0.3 × 0.8 = 0.48 fF

Cin = 0.619 + 1.238 + 0.24 + 0.48 = **2.577 fF**

(b) 輸出端自載電容 Cint：
輸出端看到 NMOS Drain 與 PMOS Drain 的接面電容，以及重疊電容（Gate-Drain）：

NMOS Drain 擴散區：
- 面積 = Wn × Ldiff = 0.4 × 0.27 = 0.108 μm²
- 周長 = 2(Ldiff) + Wn = 2(0.27) + 0.4 = 0.94 μm（三邊，一邊為通道）
- Cdiff,n = 1.0 × 0.108 + 0.3 × 0.94 = 0.108 + 0.282 = 0.390 fF

PMOS Drain 擴散區：
- 面積 = Wp × Ldiff = 0.8 × 0.27 = 0.216 μm²
- 周長 = 2(0.27) + 0.8 = 1.34 μm
- Cdiff,p = 1.2 × 0.216 + 0.35 × 1.34 = 0.259 + 0.469 = 0.728 fF

重疊電容（Gate-Drain，有 Miller 效應倍增，取 2 倍）：
Cov_out,n = 2 × Cov,n × Wn = 2 × 0.3 × 0.4 = 0.24 fF
Cov_out,p = 2 × Cov,p × Wp = 2 × 0.3 × 0.8 = 0.48 fF

注意：Miller 效應使 Gate-Drain 重疊電容在輸出端等效加倍，但此處已用 2× 近似。

Cint = 0.390 + 0.728 + 0.24 + 0.48 = **1.838 fF**

(c) FO1 總負載：
CL = Cint + Cin(next) = 1.838 + 2.577 = **4.415 fF**

**答案**：Cin ≈ 2.58 fF，Cint ≈ 1.84 fF，FO1 總負載 ≈ 4.42 fF。

**延伸思考**：在實際設計中，寄生參數萃取（Parasitic Extraction, PEX）是驗證流程的關鍵步驟。TSMC 提供的 tech file 包含精確的電容模型。面試常問「Miller 效應如何影響延遲？」——Gate-Drain 重疊電容在切換時等效放大，增加有效負載。

---
### 題目 10：CMOS 反相器雜訊邊限與再生性
**來源**：台大電機 / 經典題型
**難度**：★★★☆☆
**主題**：雜訊邊限與數位穩定性

**題目**：
兩個串聯的 CMOS 反相器，第一級 VM1 = 0.8V（偏移設計），第二級 VM2 = 1.0V。VDD = 1.8V。
(a) 繪製兩級反相器的蝴蝶曲線（Butterfly Curve），說明何謂靜態雜訊邊限（Static Noise Margin, SNM）。
(b) 若 VOH = 1.8V，VOL = 0V，VIL1 = 0.6V，VIH1 = 1.0V（第一級），VIL2 = 0.75V，VIH2 = 1.25V（第二級），計算系統整體的 NMH 與 NML。
(c) 為何說 CMOS 邏輯具有「再生性」（Regenerative Property）？這與增益有何關係？

**詳解**：

**解題思路**：雜訊邊限取決於 VTC 曲線的參數，再生性與轉態區增益相關。

**步驟**：

(a) 蝴蝶曲線（Butterfly Curve）：
將兩個反相器的 VTC 曲線疊在一起（一正一反），兩曲線之間圍成的最大正方形邊長即為 SNM。

```
  Vout2 (反向)
  VDD ┤         ╱──────
      │        ╱
      │  ┌────╱─── 正方形(SNM)
      │  │   ╱│
      │  └──╱─┘
      │    ╱
  0   ┤───╱
      └──────────────── Vout1
      0              VDD
```

SNM 是衡量記憶體單元（如 SRAM）穩定性的核心指標。

(b) 系統雜訊邊限：
在串聯邏輯中，雜訊邊限取最差情況（瓶頸）：

第一級輸出接第二級輸入：
NMH = VOH1 - VIH2 = 1.8 - 1.25 = **0.55V**
NML = VIL2 - VOL1 = 0.75 - 0 = **0.75V**

但也需考慮第一級自身：
NMH1 = VOH - VIH1 = 1.8 - 1.0 = 0.8V
NML1 = VIL1 - VOL = 0.6 - 0 = 0.6V

系統 NMH = min(NMH1, NMH跨級) = min(0.8, 0.55) = **0.55V**
系統 NML = min(NML1, NML跨級) = min(0.6, 0.75) = **0.60V**

(c) CMOS 再生性：
- CMOS 反相器在轉態區的電壓增益 |Av| > 1（通常 >> 1）
- 這意味著小的輸入擾動會被放大，使輸出快速趨向 VDD 或 GND
- 增益 > 1 保證了信號經過多級後不會衰減，反而會被「再生」回到完整的邏輯電平
- 這是 CMOS 優於 Pass Transistor Logic 的核心優勢（後者因 Vth drop 造成信號衰減）

數學上：VTC 曲線斜率在 VIL 和 VIH 處 dVout/dVin = -1，在 VM 處 |增益| >> 1。

**答案**：系統 NMH = 0.55V，NML = 0.60V；CMOS 的再生性源自轉態區增益 |Av| > 1，保證信號完整性。

**延伸思考**：SNM 分析在 SRAM 設計中至關重要（特別是 6T SRAM 的讀穩定性）。TSMC 在每個製程節點都會提供 SNM 的 Monte Carlo 統計分析，確保在 6σ 製程變異下仍能正常運作。

---

## Part 2：CMOS 邏輯設計（題目 11–20）

---
### 題目 11：CMOS NAND 與 NOR 閘電晶體尺寸設計
**來源**：台大電機 / 必考經典
**難度**：★★★☆☆
**主題**：CMOS 邏輯閘設計

**題目**：
設計 2 輸入 CMOS NAND 閘與 2 輸入 CMOS NOR 閘，使其最差情況下的上升與下降延遲與一個參考反相器（NMOS: Wn = 1μm, PMOS: Wp = 2μm, L = 0.18μm）相當。
(a) 畫出 2 輸入 NAND 的電路圖（NMOS 下拉網路 + PMOS 上拉網路），標注電晶體尺寸。
(b) 畫出 2 輸入 NOR 的電路圖，標注電晶體尺寸。
(c) 比較 NAND 與 NOR 的總電晶體面積，說明為何 CMOS 設計偏好 NAND。
(d) 推廣到 N 輸入 NAND 閘的尺寸法則。

**詳解**：

**解題思路**：等效電阻法——串聯電晶體等效電阻加倍，需加倍寬度補償。

**步驟**：

(a) 2 輸入 NAND 閘：

```
      VDD           VDD
       │             │
   ┌───┤         ┌───┤
   │ PMOS(A)     │ PMOS(B)
   │ W=2μm       │ W=2μm      ← 並聯，各維持 Wp
   └───┬─────────┘   │
       ├─────────────┘
       ├──── Out
       │
   ┌───┤
   │ NMOS(A)
   │ W=2μm                    ← 串聯，需 2×Wn = 2μm
   └───┤
   ┌───┤
   │ NMOS(B)
   │ W=2μm                    ← 串聯，需 2×Wn = 2μm
   └───┤
      GND
```

NMOS 串聯：等效電阻 = 2Rn，需 W = 2Wn = 2×1 = 2μm 使 Req 回到 Rn
PMOS 並聯：等效電阻 = Rp/2 ≤ Rp，各 W = Wp = 2μm 即可（最差情況只一個開）

(b) 2 輸入 NOR 閘：

```
      VDD
       │
   ┌───┤
   │ PMOS(A)
   │ W=4μm                    ← 串聯，需 2×Wp = 4μm
   └───┤
   ┌───┤
   │ PMOS(B)
   │ W=4μm                    ← 串聯，需 2×Wp = 4μm
   └───┤
       ├──── Out
       │
   ┌───┼───┐
   │ NMOS(A) │ NMOS(B)
   │ W=1μm   │ W=1μm          ← 並聯，各維持 Wn
   └───┬───┘
      GND
```

(c) 面積比較：

| 閘 | NMOS 總寬度 | PMOS 總寬度 | 總寬度 |
|----|------------|------------|--------|
| NAND | 2×2 = 4μm | 2×2 = 4μm | **8μm** |
| NOR | 2×1 = 2μm | 2×4 = 8μm | **10μm** |
| 參考 INV | 1μm | 2μm | 3μm |

NAND 比 NOR 節省 20% 面積，因為 NAND 的串聯在 NMOS 端（寬度小），而 NOR 的串聯在 PMOS 端（需更大寬度）。

**CMOS 偏好 NAND 的原因**：PMOS 遷移率低 → 原本就需較大寬度 → 串聯再加倍更浪費面積。

(d) N 輸入 NAND 閘法則：
- NMOS：N 個串聯，每個 W = N×Wn
- PMOS：N 個並聯，每個 W = Wp
- 總寬度 = N²·Wn + N·Wp

**答案**：NAND 總寬 8μm，NOR 總寬 10μm；CMOS 偏好 NAND 因串聯在 NMOS 端較經濟。

**延伸思考**：在標準元件庫中，通常只提供到 4 輸入 NAND/NOR，更多輸入用多級實現。扇入太大會造成串聯電晶體過多，延遲急劇增加。

---
### 題目 12：複雜閘 AOI 與 OAI 設計
**來源**：台大電機 / 經典題型
**難度**：★★★☆☆
**主題**：複雜閘（Complex Gate）設計

**題目**：
設計實現邏輯函數 F = ¬[(A·B) + (C·D)] 的 AOI22（AND-OR-INVERT）閘。
(a) 畫出完整的 CMOS 電路圖，標注 PMOS 上拉與 NMOS 下拉網路。
(b) 驗證上拉與下拉網路的互補性（Complementary）。
(c) 若參考反相器 Wn = 0.5μm, Wp = 1μm，設計所有電晶體尺寸使最差情況延遲等效。
(d) 若改為 OAI22，即 G = ¬[(A+B)·(C+D)]，畫出電路並比較面積。

**詳解**：

**解題思路**：NMOS 下拉實現非反相函數，PMOS 上拉為其對偶（Dual）——串聯↔並聯互換。

**步驟**：

(a) AOI22 電路：F = ¬[(A·B) + (C·D)]

NMOS 下拉網路（實現 AB + CD → pull down）：
兩條並聯路徑，每條路徑兩個串聯 NMOS。

PMOS 上拉網路（對偶：並聯↔串聯互換）：
兩組串聯 PMOS（A串B，C串D），兩組再串聯。
等等...更正：對偶應為 (A+B)·(C+D) 的 PMOS 版本。

```
            VDD
             │
         ┌───┤───┐
         │ PA    │ PC
         │       │
         ├───┐   ├───┐
         │ PB│   │ PD│
         └───┼───┘   │
             ├───────┘
             ├──── Out (F)
         ┌───┴───┐
     ┌───┤   ┌───┤
     │ NA│   │ NC│
     └───┤   └───┤
     ┌───┤   ┌───┤
     │ NB│   │ ND│
     └───┤   └───┤
         └───┬───┘
            GND
```

NMOS：(NA 串 NB) 並聯 (NC 串 ND)
PMOS：(PA 並 PB) 串聯 (PC 並 PD)
→ 更正PMOS：A和B各一PMOS串聯形成一條路徑，C和D各一PMOS串聯形成另一條路徑，兩條路徑串聯。

正確 PMOS 上拉：(PA 串 PC) 並聯 (PA 串 PD) 並聯 (PB 串 PC) 並聯 (PB 串 PD)
→ 不對，這樣太多電晶體。

正確的對偶推導：
NMOS pull-down: (A·B) + (C·D)
PMOS pull-up（取對偶）: (A+B) · (C+D)

PMOS 實現 (A+B)·(C+D)：
- (A+B) → PA 並聯 PB
- (C+D) → PC 並聯 PD
- 整體相乘 → 兩組串聯

```
            VDD
             │
         ┌───┴───┐
         │ PA  │ PB     ← PA, PB 並聯（實現 A+B）
         └───┬───┘
         ┌───┴───┐
         │ PC  │ PD     ← PC, PD 並聯（實現 C+D）
         └───┬───┘
             ├──── Out (F)
         ┌───┴───┐
     ┌─NA─┐  ┌─NC─┐
     └──┬──┘  └──┬──┘
     ┌─NB─┐  ┌─ND─┐    ← (NA串NB) 並聯 (NC串ND)
     └──┬──┘  └──┬──┘
         └───┬───┘
            GND
```

(b) 互補性驗證：
- NMOS pull-down ON 條件：AB + CD = 1 → F = 0 ✓
- PMOS pull-up ON 條件：(A+B)(C+D) = 0 → 即 ¬(AB+CD) = 1 → F = 1 ✓
- 兩者互斥且完備，驗證通過。

(c) 電晶體尺寸：
NMOS：2 個串聯 → 每個 W = 2Wn = 2×0.5 = 1μm（共 4 個 NMOS，全部 1μm）
PMOS：2 個串聯 → 每個 W = 2Wp = 2×1 = 2μm（共 4 個 PMOS，全部 2μm）

AOI22 總寬度 = 4×1 + 4×2 = **12μm**

(d) OAI22：G = ¬[(A+B)·(C+D)]
NMOS pull-down：(A+B)·(C+D) → (NA 並 NB) 串 (NC 並 ND)
PMOS pull-up（對偶）：A·B + C·D → (PA 串 PB) 並 (PC 串 PD)

NMOS：2 組並聯再串聯，並聯各 Wn = 0.5μm，但串聯需 ×2 → 各 1μm
PMOS：2 串聯路徑並聯，串聯各需 2Wp = 2μm

OAI22 總寬度 = 4×1 + 4×2 = **12μm**（與 AOI22 相同）

在此對稱結構下面積相同，但若扇入不對稱（如 AOI21 vs OAI21）則會不同。

**答案**：AOI22 與 OAI22 各需 4 NMOS + 4 PMOS 共 8 個電晶體；對稱結構下面積相同。

**延伸思考**：複雜閘在標準元件庫中非常重要，AOI/OAI 可在單級實現多輸入邏輯，比用多個基本閘串聯更快。EDA 工具在 Technology Mapping 階段會大量使用這些單元。

---
### 題目 13：傳輸閘邏輯設計
**來源**：台大電機 / 經典題型
**難度**：★★★☆☆
**主題**：傳輸閘（Transmission Gate）

**題目**：
(a) 解釋為何單一 NMOS 傳輸開關（Pass Transistor）無法傳遞完整的邏輯「1」？定量分析：VDD = 1.8V，Vtn = 0.5V 時，輸出最高電壓為何？
(b) 畫出 CMOS 傳輸閘（TG）的電路，解釋為何能傳遞完整的 rail-to-rail 信號。
(c) 分析傳輸閘的等效電阻如何隨輸入電壓變化。
(d) 用傳輸閘實現一個 2:1 多工器（MUX），畫出電路圖。

**詳解**：

**解題思路**：分析 MOS 作為開關的 VGS 條件。

**步驟**：

(a) NMOS 傳輸開關傳「1」的問題：

```
    Vin = VDD ──┤ NMOS ├── Vout
                  Gate = VDD
```

NMOS 導通條件：VGS > Vtn
VGS = VG - VS = VDD - Vout

當 Vout 上升到接近 VDD 時：
VGS = VDD - Vout → 當 Vout = VDD - Vtn 時，VGS = Vtn，NMOS 即將截止。

因此 Vout(max) = VDD - Vtn = 1.8 - 0.5 = **1.3V**

輸出無法達到完整 VDD，損失一個 Vtn（Threshold Voltage Drop）。

同理，PMOS 無法傳遞完整的「0」，最低只能到 |Vtp|。

(b) CMOS 傳輸閘：

```
         ┌─── S ────── NMOS ────── D ───┐
  In ────┤                               ├──── Out
         └─── S ────── PMOS ────── D ───┘
                 Gate_N = φ    Gate_P = φ̄
```

- 當 φ = 1, φ̄ = 0：兩者均導通
  - 傳「1」時：NMOS 因 Vth drop 變弱，但 PMOS（VGS = 0-VDD = -VDD）仍強導通
  - 傳「0」時：PMOS 因 Vth drop 變弱，但 NMOS（VGS = VDD-0 = VDD）仍強導通
- 互補特性確保 rail-to-rail 傳輸

(c) 等效電阻分析：
- Vin 接近 0V：NMOS 強（大 VGS），PMOS 弱（小 |VGS|）→ Req ≈ Rn
- Vin 接近 VDD/2：兩者均適度導通 → Req 最小
- Vin 接近 VDD：NMOS 弱，PMOS 強 → Req ≈ Rp

等效電阻隨 Vin 變化呈 U 型曲線，但因互補效應，變化幅度遠小於單一電晶體。設計 Wp/Wn 使 Req 近乎恆定。

(d) 2:1 MUX 電路：

```
  A ────┤ TG1 ├──┐
         φ, φ̄    ├──── Out
  B ────┤ TG2 ├──┘
         φ̄, φ

  當 S=1：TG1 導通，Out = A
  當 S=0：TG2 導通，Out = B

  Out = S·A + S̄·B
```

共需 4 個電晶體（2 個 TG）+ 1 個反相器產生 S̄ = 6 個電晶體。
比較：用 NAND/NOR 實現的 MUX 需更多電晶體。

**答案**：NMOS 最高傳 VDD-Vtn = 1.3V；TG 利用 NMOS/PMOS 互補達到 rail-to-rail；TG MUX 僅需 6 個電晶體。

**延伸思考**：傳輸閘在 MUX、XOR、鎖存器中廣泛使用。但 TG 邏輯的缺點是沒有再生性（Non-regenerative），長鏈路需要插入 buffer。

---
### 題目 14：偽 NMOS 邏輯分析
**來源**：台大電機 / 經典題型
**難度**：★★★☆☆
**主題**：偽 NMOS（Pseudo-NMOS）邏輯

**題目**：
考慮 Pseudo-NMOS 反相器：PMOS 閘極直接接地（永遠導通，作為負載），NMOS 作為輸入控制。VDD = 1.8V，Vtn = |Vtp| = 0.5V，βn = 200 μA/V²，βp = 50 μA/V²。
(a) 計算 VOH 與 VOL。
(b) 計算開關閾值 VM。
(c) 計算靜態功耗（當輸出為低時）。
(d) 與互補 CMOS 反相器比較優缺點。

**詳解**：

**解題思路**：PMOS 恆導通提供拉電流，NMOS 下拉；輸出低時存在直流通路。

**步驟**：

```
      VDD
       │
   ┌───┤
   │ PMOS (Gate = GND, 永遠 ON)
   │ βp = 50 μA/V²
   └───┤
       ├──── Out
   ┌───┤
   │ NMOS
   │ βn = 200 μA/V²
   └───┤
      GND
```

(a) VOH 與 VOL：

VOH：Vin = 0V，NMOS 截止，無電流通路
PMOS 將輸出充到 VDD → **VOH = 1.8V**

VOL：Vin = VDD = 1.8V，NMOS 導通
PMOS 飽和（假設 |VGSp| = VDD > |Vtp|，VDSp = -(VDD-VOL)）
在 VOL 很小時：
PMOS 飽和：IDp = (βp/2)(VDD - |Vtp|)² = (50/2)(1.3)² = 42.25 μA
NMOS 線性：IDn = βn[(VDD - Vtn)VOL - VOL²/2]

令 IDp = IDn（穩態）：
42.25 = 200[(1.3)VOL - VOL²/2]

忽略 VOL² 項（VOL 很小）：
42.25 = 200 × 1.3 × VOL = 260 × VOL
VOL = 42.25/260 = **0.163V**

(b) 開關閾值 VM：
在 VM 點，Vin = VM，Vout = VM
NMOS 飽和：IDn = (βn/2)(VM - Vtn)²
PMOS 飽和（假設）：IDp = (βp/2)(VDD - |Vtp|)² = 42.25 μA

令 IDn = IDp：
(200/2)(VM - 0.5)² = 42.25
100(VM - 0.5)² = 42.25
(VM - 0.5)² = 0.4225
VM - 0.5 = 0.65
**VM = 1.15V**

需驗證 PMOS 是否飽和：|VDSp| = VDD - VM = 0.65V，|VGSp| - |Vtp| = 1.3V
|VDSp| < |VGSp| - |Vtp| → PMOS 實際在線性區，需修正。

PMOS 線性：IDp = βp[(VDD - |Vtp|)(VDD - VM) - (VDD - VM)²/2]
= 50[1.3 × 0.65 - 0.65²/2] = 50[0.845 - 0.211] = 50 × 0.634 = 31.7 μA

修正：100(VM - 0.5)² = 31.7
(VM - 0.5)² = 0.317
VM = 0.5 + 0.563 = **1.063V**

（可迭代求解，收斂值約 VM ≈ 1.05V）

(c) 靜態功耗：
當 Vout = VOL = 0.163V 時，有持續直流電流：
IDC = 42.25 μA
**Pstatic = IDC × VDD = 42.25μA × 1.8V = 76.1 μW**

這是 Pseudo-NMOS 最大的缺點——有靜態功耗！

(d) 與互補 CMOS 比較：

| 特性 | 互補 CMOS | Pseudo-NMOS |
|------|----------|-------------|
| 靜態功耗 | 近零 | 有（顯著） |
| VOL | 0V | > 0V（≈ 0.16V） |
| 電晶體數 | 2N | N+1 |
| 面積 | 較大 | 較小 |
| 速度 | 較慢（大 PMOS） | 較快（小負載） |
| 雜訊邊限 | 對稱、較大 | 不對稱、較小 |

**答案**：VOH = 1.8V，VOL ≈ 0.163V，VM ≈ 1.05V，靜態功耗 ≈ 76μW。Pseudo-NMOS 省面積但有靜態功耗與降低的雜訊邊限。

**延伸思考**：Pseudo-NMOS 概念延伸到 ROM 與 PLA 設計中廣泛使用，以及 NOR Flash 的讀取電路。在需要高密度但可容忍靜態功耗的場合仍有價值。

---
### 題目 15：動態邏輯 Domino Logic
**來源**：台大電機 / 經典題型
**難度**：★★★★☆
**主題**：動態邏輯（Dynamic Logic）

**題目**：
考慮以下 Domino Logic 實現 F = A·B + C：

```
      VDD
       │
   ┌───┤
   │ MP (Precharge PMOS)
   │ Gate = CLK
   └───┤
       ├──── Dynamic Node (Dn)──┤INV├── Out (F)
   ┌───┤
   │ NMOS network
   │ (AB + C)
   └───┤
   ┌───┤
   │ MN (Evaluate NMOS)
   │ Gate = CLK
   └───┤
      GND
```

(a) 說明預充（Precharge）與求值（Evaluate）兩個階段的動作。
(b) 為何 Domino Logic 輸出只能做單調轉換（Monotonic Transition）？這有何影響？
(c) Domino Logic 能否直接實現反相（Inverting）函數？如何解決？
(d) 分析 Domino Logic 的電荷分享（Charge Sharing）問題及解決方案。

**詳解**：

**解題思路**：動態邏輯利用電容儲存電荷，分時序兩階段操作。

**步驟**：

(a) 兩階段動作：

**預充階段（CLK = 0）**：
- MP (PMOS) 導通，將 Dynamic Node 預充至 VDD
- MN (NMOS) 截止，截斷下拉路徑
- 輸出反相器：Dn = VDD → Out = 0

**求值階段（CLK = 1）**：
- MP 截止（停止預充）
- MN 導通（開啟求值路徑）
- 若 AB + C = 1：NMOS 網路導通，Dn 放電至 0 → Out = 1
- 若 AB + C = 0：NMOS 網路無通路，Dn 維持 VDD → Out = 0

(b) 單調轉換特性：

在求值階段，Dynamic Node 只能從 VDD 下降到 0（放電），不能上升。
因此輸出 Out 只能從 0 上升到 1（單調 0→1 轉換）。

**影響**：
- 優點：Domino 級聯時，前級的 0→1 轉換不會導致後級誤動作
- 可以多級串聯而不需要每級都加時脈控制
- 這就是「Domino」名稱的由來——像骨牌一樣依序觸發

(c) 反相函數問題：

Domino Logic **無法直接實現反相函數**（如 F = ¬A）。
因為 NMOS 下拉網路只能實現非反相的正邏輯函數。

**解決方案**：
1. **NP-CMOS（NORA）**：交替使用 N-type（NMOS 求值）與 P-type（PMOS 求值）動態閘
2. **雙軌（Dual-Rail）Domino**：同時產生 F 與 F̄，用兩組電路
3. 在關鍵路徑中插入靜態反相器

(d) 電荷分享問題：

```
      VDD
       │
   ┌─MP─┐
       ├──Dn (CL)
   ┌─NA─┐
       ├── Node X (Cx，寄生電容)
   ┌─NB─┐
   ┌─MN─┐
      GND
```

問題：求值前若 Node X 被放電到 0V，求值時 NA 導通但 NB 不導通，CL 的電荷會分享給 Cx：

Dn(final) = CL·VDD / (CL + Cx)

若 Cx 夠大，Dn 可能低於反相器閾值 → 輸出錯誤！

**解決方案**：
1. 增加預充電晶體到內部節點（Secondary Precharge）
2. 增加 Keeper（弱 PMOS 從 VDD 到 Dn，閘極接 Out）維持電荷
3. 增大 CL / 減小 Cx

**答案**：Domino Logic 分預充/求值兩階段，只支援單調 0→1 輸出轉換，無法直接實現反相函數，需注意電荷分享問題。

**延伸思考**：Domino Logic 在高速處理器設計中曾廣泛使用（Intel Pentium 4 大量採用）。但因功耗問題與設計複雜度，現代設計已逐漸回歸靜態 CMOS。面試常問 Domino 的 Keeper sizing 問題。

---
### 題目 16：通過電晶體邏輯設計 XOR
**來源**：台大電機 / 經典題型
**難度**：★★★☆☆
**主題**：通過電晶體邏輯（Pass Transistor Logic）

**題目**：
(a) 用傳輸閘（TG）與反相器設計一個 2 輸入 XOR 閘，要求最少電晶體數。
(b) 用純 NMOS pass transistor 設計 XOR，分析輸出電壓衰減問題。
(c) 比較 TG-XOR、Static CMOS XOR、Mirror XOR 的電晶體數量與性能。

**詳解**：

**解題思路**：XOR = A⊕B = A·B̄ + Ā·B，可用 MUX 概念實現。

**步驟**：

(a) TG-XOR 設計：

XOR 可視為：當 B = 0 時輸出 A；當 B = 1 時輸出 Ā。
即 Out = B̄·A + B·Ā（2:1 MUX，選擇信號為 B）

```
  A  ────┤ TG1 (B̄,B) ├──┐
                          ├──── Out = A⊕B
  Ā  ────┤ TG2 (B,B̄) ├──┘

  需要：1 個 INV 產生 Ā（2 個電晶體）
         2 個 TG（4 個電晶體）
         假設 B̄ 可用（否則再加 1 個 INV）
```

最少電晶體數：**6 個**（2 TG + 1 INV，假設互補信號可用）
若 B̄ 需另外產生：**8 個**

(b) 純 NMOS Pass Transistor XOR：

```
  B̄ ────┤ NMOS(Gate=A) ├──┐
                           ├──── Out
  B  ────┤ NMOS(Gate=Ā) ├──┘
```

僅 2 個 NMOS + 2 個 INV = **6 個電晶體**

問題：NMOS 傳高電平時有 Vth drop
- 當 A=1, B=0：NMOS(A) 導通，傳 B̄ = VDD，但 Out = VDD - Vtn
- 信號衰減！多級串聯後越來越嚴重

(c) 比較：

| 設計 | 電晶體數 | Rail-to-Rail | 速度 | 面積 |
|------|---------|-------------|------|------|
| Static CMOS | 12 | 是 | 中 | 大 |
| TG-XOR | 6-8 | 是 | 快 | 小 |
| Pass Transistor | 6 | 否 | 最快 | 最小 |
| Mirror XOR | 8 | 是 | 中 | 中 |

Mirror XOR（利用對稱性）：

```
      VDD                VDD
       │                  │
   ┌─PA(Ā)┐          ┌─PC(A)─┐
       │                  │
   ┌─PB(B̄)┐  ┌─PD(B)┐ ┌─PE(B̄)┐ ┌─PF(B)┐
       └───┬──┘    └───┬──┘
           ├───────────┤
           Out
       ┌───┴──┐    ┌───┴──┐
   ┌─NA(A)┐ ┌NB(B)┐ ┌NC(Ā)┐ ┌ND(B̄)┐
       │                  │
   └───┴──────────────┘
          GND
```

共 8 個電晶體，完整 CMOS 互補結構。

**答案**：TG-XOR 最經濟（6 個電晶體），純 NMOS 有 Vth drop 問題，Static CMOS 最穩健但最大（12 個）。

**延伸思考**：XOR/XNOR 是算術電路（加法器、比較器、奇偶校驗）的核心。在全加器設計中，XOR 的實現方式直接影響關鍵路徑延遲。

---
### 題目 17：CMOS 邏輯閘的延遲與尺寸最佳化
**來源**：台大電機 / 經典題型
**難度**：★★★★☆
**主題**：邏輯努力在複合閘的應用

**題目**：
計算以下邏輯閘的邏輯努力（Logical Effort, g）與寄生延遲（Parasitic Delay, p）：
(a) 2 輸入 NAND
(b) 2 輸入 NOR
(c) 3 輸入 NAND
(d) 2 輸入 AOI21（F = ¬[A·B + C]）

假設參考反相器 γ = Wp/Wn（通常 γ = 2 表示 μn/μp ≈ 2）。

**詳解**：

**解題思路**：邏輯努力 = 閘的輸入電容 / 等效反相器的輸入電容（在等效驅動能力下）。

**步驟**：

定義：反相器的輸入電容 Cinv = Cn + Cp = 1 + γ = 1 + 2 = 3（歸一化）
反相器 g = 1，p = 1（定義基準）

(a) 2 輸入 NAND（等效延遲匹配設計）：

NMOS 串聯 2 個，各 W = 2 → NMOS 電容 = 2
PMOS 並聯 2 個，各 W = γ = 2 → PMOS 電容 = 2

每個輸入看到：Cin = 2 + 2 = 4

邏輯努力 g = Cin / Cinv = 4/3 ≈ **1.33**

寄生延遲（歸一化至反相器）：
p_NAND2 = (串聯 NMOS 擴散電容 + 並聯 PMOS 擴散電容) / (INV 擴散電容)
p = (2 + 2·γ) / (1 + γ) = (2 + 4) / 3 = **2**

(b) 2 輸入 NOR：

NMOS 並聯 2 個，各 W = 1 → NMOS 電容 = 1
PMOS 串聯 2 個，各 W = 2γ = 4 → PMOS 電容 = 4

每個輸入：Cin = 1 + 4 = 5

g = 5/3 ≈ **1.67**

p = (2·1 + 2γ) / (1 + γ) = (2 + 4) / 3 = **2**

NOR 的邏輯努力 > NAND，再次證明 NAND 是較好的選擇。

(c) 3 輸入 NAND：

NMOS 串聯 3 個，各 W = 3 → NMOS 電容 = 3
PMOS 並聯 3 個，各 W = γ = 2 → PMOS 電容 = 2

每個輸入：Cin = 3 + 2 = 5
g = 5/3 ≈ **1.67**

p = (3 + 3γ)/(1+γ) = (3+6)/3 = **3**

(d) AOI21（F = ¬[A·B + C]）：

NMOS 下拉：A,B 串聯 (各 W=2) 與 C 並聯 (W=1)
PMOS 上拉：(PA 並 PB) 串聯 PC → PA,PB 各 W=2γ=4, PC W=γ=2

輸入 A 或 B：Cin = 2 + 4 = 6，g_AB = 6/3 = **2.0**
輸入 C：Cin = 1 + 2 = 3，g_C = 3/3 = **1.0**

注意：AOI21 不同輸入有不同邏輯努力！

**答案**：

| 閘 | g | p |
|----|---|---|
| INV | 1.00 | 1 |
| NAND2 | 1.33 | 2 |
| NOR2 | 1.67 | 2 |
| NAND3 | 1.67 | 3 |
| AOI21 (A,B) | 2.00 | — |
| AOI21 (C) | 1.00 | — |

**延伸思考**：邏輯努力法在 Synopsys Design Compiler 等工具的 timing optimization 中有理論基礎。設計者透過選擇不同拓撲（NAND-based vs NOR-based decomposition）來最小化路徑延遲。

---
### 題目 18：CMOS 動態邏輯——NP-CMOS（NORA）
**來源**：台大電機 / 經典題型
**難度**：★★★★☆
**主題**：NP-CMOS / NORA 動態邏輯

**題目**：
(a) 說明 NP-CMOS（又稱 NORA）邏輯的架構，畫出 N-type 與 P-type 動態閘各一級。
(b) 與 Domino Logic 比較，NP-CMOS 的最大優勢是什麼？
(c) 分析 NP-CMOS 中的 Race Condition 問題。
(d) 設計一個 NP-CMOS 電路實現 F = ¬(A+B)·C。

**詳解**：

**解題思路**：NP-CMOS 交替使用 N-type 與 P-type 動態閘，實現反相邏輯。

**步驟**：

(a) NP-CMOS 架構：

**N-type 動態閘**（與 Domino 的 N-block 相同）：
```
    VDD
     │
   ┌─Mp─┐ (CLK̄ precharge)
     │
   ──Dn──── Out_N
     │
   [NMOS PDN]
     │
   ┌─Me─┐ (CLK evaluate)
     │
    GND
```
CLK=0: 預充 Dn=VDD；CLK=1: 求值

**P-type 動態閘**：
```
    VDD
     │
   ┌─Me'─┐ (CLK̄ evaluate)
     │
   [PMOS PUN]
     │
   ──Dp──── Out_P
     │
   ┌─Mp'─┐ (CLK precharge)
     │
    GND
```
CLK=0: 預充 Dp=0；CLK=1: 透過 PMOS 上拉求值（若條件滿足則充到 VDD）

等等——更正 P-type 閘的時序：
CLK=1: 預充 Dp=GND（MN 導通）
CLK=0: 求值（PMOS evaluate 導通）

不對，P-type 與 N-type 互補：
N-type：φ=0 預充到 VDD，φ=1 求值（可能放電）
P-type：φ=1 預充到 GND，φ=0 求值（可能充電到 VDD）

(b) NP-CMOS vs Domino 的優勢：

**NP-CMOS 可以實現反相函數！**

Domino 只能做 non-inverting（因為輸出端有固定的反相器），所以只能實現 AND/OR 的組合。
NP-CMOS 透過 N-type 和 P-type 交替，可以交替實現 inverting 和 non-inverting 函數，不需要額外的靜態反相器。

(c) Race Condition 問題：
- N-type 閘求值時產生的輸出變化，可能影響同時在預充的 P-type 閘
- 若前級輸出在後級預充完成前就改變，會導致錯誤
- 需仔細控制時脈重疊（Clock Overlap）與延遲匹配

(d) 設計 F = ¬(A+B)·C = (Ā·B̄)·C = C·Ā·B̄：

第一級（N-type）：實現 G = ¬(A+B)
NMOS PDN：NA 並聯 NB（實現 A+B）
預充 Dn = VDD，求值時若 A+B=1 則 Dn→0
輸出 G = Dn = ¬(A+B)（不加反相器）

第二級（P-type）：實現 F = G·C = ¬(A+B)·C
改寫：F 需要一個 P-type 閘使 F=1 when G=1 and C=1
P-type PDN：Ḡ 並 C̄ 下拉（互補設計）

實務上更直接的做法：
N-type 閘實現 (A+B) 取反得 ¬(A+B)
P-type 閘以 ¬(A+B) 和 C 為輸入，實現 AND

**答案**：NP-CMOS 交替使用 N/P 型動態閘，可實現反相函數（Domino 不行），但需注意 Race Condition。

**延伸思考**：NP-CMOS 在 1990 年代的高速處理器中有應用，現已較少使用。面試中更常問 Domino Logic 及其 Keeper 設計。

---
### 題目 19：電晶體尺寸設計——等延遲法
**來源**：台大電機 / 業界面試
**難度**：★★★★☆
**主題**：複雜路徑延遲最佳化

**題目**：
考慮以下邏輯路徑，需驅動 CL = 500 fF：

```
  In → [NAND3] → [NOR2] → [INV] → [INV] → Out (CL = 500fF)
```

最小反相器輸入電容 Cinv = 3 fF。
(a) 計算路徑的邏輯努力（Path Logical Effort, G）。
(b) 計算路徑的電氣努力（Path Electrical Effort, H）。
(c) 計算最佳每級努力（Stage Effort, f̂）與最小路徑延遲。
(d) 反推每級的電晶體尺寸。

**詳解**：

**解題思路**：應用多級邏輯努力理論。

**步驟**：

已知邏輯努力（γ = 2）：
- NAND3: g₁ = 5/3
- NOR2: g₂ = 5/3（修正：使用標準值）

更精確：以 γ = 2 為例
- NAND3: g = 5/3 ≈ 1.67
- NOR2: g = 5/3 ≈ 1.67
- INV: g = 1
- INV: g = 1

(a) 路徑邏輯努力：
G = g₁ · g₂ · g₃ · g₄ = (5/3)(5/3)(1)(1) = 25/9 ≈ **2.78**

(b) 路徑電氣努力：
假設輸入來自最小反相器：Cin = Cinv = 3 fF
H = CL / Cin = 500/3 ≈ **166.7**

分支努力（Branching Effort）B = 1（假設無分支）

(c) 路徑努力：
F = G · B · H = 2.78 × 1 × 166.7 = **463.3**

N = 4 級
最佳每級努力：f̂ = F^(1/N) = 463.3^(1/4) = (463.3)^0.25

463.3^0.5 = 21.52
21.52^0.5 = 4.64

f̂ ≈ **4.64**

最小路徑延遲：
D = N · f̂ + P = 4 × 4.64 + (p₁ + p₂ + p₃ + p₄)
P = p_NAND3 + p_NOR2 + p_INV + p_INV = 3 + 2 + 1 + 1 = 7

D = 18.56 + 7 = **25.56 τ**（歸一化延遲單位）

(d) 反推尺寸：

每級的電氣努力 hᵢ = f̂ / gᵢ：
- 級 1（NAND3）：h₁ = 4.64 / (5/3) = 4.64 × 3/5 = 2.784
- 級 2（NOR2）：h₂ = 4.64 / (5/3) = 2.784
- 級 3（INV）：h₃ = 4.64 / 1 = 4.64
- 級 4（INV）：h₄ = 4.64 / 1 = 4.64

從輸出端反推（CL = 500 fF）：
C_in4 = CL / h₄ = 500 / 4.64 = 107.8 fF
C_in3 = C_in4 / h₃ = 107.8 / 4.64 = 23.2 fF
C_in2 = C_in3 / h₂ = 23.2 / 2.784 = 8.33 fF
C_in1 = C_in2 / h₁ = 8.33 / 2.784 = 2.99 fF ≈ 3 fF ✓（與輸入一致）

**答案**：G = 2.78，H = 166.7，f̂ ≈ 4.64，D_min ≈ 25.56τ；尺寸為 3→8.3→23.2→107.8 fF。

**延伸思考**：此方法在實際 EDA flow 中用於 timing-driven sizing。Synopsys/Cadence 工具在 gate sizing 最佳化時使用類似理論。注意：實務中尺寸需為標準元件庫中可用的離散值。

---
### 題目 20：靜態 CMOS 複雜閘的 Euler Path 佈局
**來源**：台大電機 / 經典題型
**難度**：★★★☆☆
**主題**：佈局最佳化（Euler Path）

**題目**：
考慮邏輯函數 F = ¬[(A·B) + (C·(D+E))]：
(a) 畫出 NMOS 下拉網路與 PMOS 上拉網路。
(b) 找出 NMOS 與 PMOS 網路的共同 Euler Path（歐拉路徑），使佈局中擴散區（Diffusion）不間斷。
(c) 畫出緊湊的 Stick Diagram。
(d) 計算所需電晶體總數。

**詳解**：

**解題思路**：先導出互補網路，再找共同歐拉路徑以最佳化佈局。

**步驟**：

(a) 網路拓撲：

NMOS 下拉（實現 AB + C(D+E)）：
- 路徑 1：NA 串 NB
- 路徑 2：NC 串 (ND 並 NE)
- 兩路徑並聯

PMOS 上拉（對偶：(A+B) · (C + D·E)）：
- (PA 並 PB) 串 (PC 並 (PD 串 PE))

```
NMOS 下拉：
  Out─┬──NA──NB──┐
      │           │
      └──NC──┬ND┬─┘
              └NE┘
              GND

PMOS 上拉：
  VDD─┬─PA─┬──┬─PC──────┐
      └─PB─┘  ├─PD─PE─┐ ├── Out
               └───────┘─┘
```

(b) Euler Path：

NMOS 圖的邊：A-B, C-D, C-E（從 Out 到 GND 的連接）
PMOS 圖的邊：A‖B, C‖D-E（從 VDD 到 Out 的連接）

尋找共同輸入順序的歐拉路徑：
嘗試順序 **A-B-C-D-E**：

NMOS：Out → A → (A-B間) → B → (B到junction) → C → (C-D間) → D → GND
       同時 C → E → GND（E 與 D 並聯需分支）

修正嘗試 **A-B-C-E-D**：
NMOS：Out-A-B-GND 或 Out-C-E-GND 或 Out-C-D-GND

更系統化：
NMOS 連接圖（節點：Out, n1, n2, GND）：
- Out-n1: A, Out-n2: C
- n1-GND: B
- n2-GND: D, n2-GND: E

Euler path (NMOS): B-A-C-D（或 B-A-C-E），E 需另接

PMOS 連接圖：
- VDD-m1: A, VDD-m1: B
- m1-Out: C
- m1-m2: D, m2-Out: E

Euler path (PMOS): A-C-E-D-B（或類似）

共同 Euler Path：**B-A-C-D-E** 或其變體。

選擇 **B-A-C-D-E** 作為共同路徑，使 NMOS 和 PMOS 的閘極輸入按同一順序排列，擴散區可以不間斷。

(c) Stick Diagram（示意）：

```
  VDD rail ═══════════════════════
  P-diff    ──PB──PA──PC──PD──PE──
  Gate       B    A    C    D    E
  N-diff    ──NB──NA──NC──ND──NE──
  GND rail ═══════════════════════

  Metal 連線實現所需的拓撲連接
```

(d) 電晶體總數：
NMOS：5 個（NA, NB, NC, ND, NE）
PMOS：5 個（PA, PB, PC, PD, PE）
**總計 10 個電晶體**

**答案**：共需 10 個電晶體；Euler Path B-A-C-D-E 使 N/P 擴散區不間斷，佈局最緊湊。

**延伸思考**：Euler Path 方法是 Standard Cell 設計的基礎。TSMC 標準元件庫的每個 cell 都經過精心的 Euler Path 最佳化以最小化面積。Place-and-Route 工具假設 cell 高度固定，寬度取決於此最佳化。

---

## Part 3：時序電路與時脈（題目 21–30）

---
### 題目 21：CMOS D 鎖存器與 D 正反器實現
**來源**：台大電機 / 必考經典
**難度**：★★★☆☆
**主題**：鎖存器與正反器

**題目**：
(a) 用傳輸閘設計一個正準位觸發的 D 鎖存器（D-Latch），畫出電路圖並說明動作。
(b) 用兩個 D 鎖存器串聯成一個正緣觸發的主從式 D 正反器（Master-Slave D Flip-Flop），畫出完整電路。
(c) 計算此正反器的電晶體數量。
(d) 說明 Setup Time、Hold Time 與 Clock-to-Q Delay 的物理意義。

**詳解**：

**解題思路**：鎖存器 = 傳輸閘 + 反相器回授；正反器 = 主從兩級鎖存器。

**步驟**：

(a) TG D-Latch（正準位透明）：

```
         CLK  CLK̄
          │    │
  D ──┤ TG1 ├──┬──┤INV1├──┬── Q
                │          │
                └──┤INV2├──┘
                    ↑
              CLK̄  CLK
               │    │
            ┌─┤ TG2 ├─┐
            └──────────┘
```

動作：
- CLK = 1（透明）：TG1 導通，D 信號通過 → Q 跟隨 D
- CLK = 0（鎖存）：TG1 截止，TG2 導通形成回授環 → Q 維持先前值

元件數：2 TG + 2 INV = 4 + 4 = 8 個電晶體

(b) 主從式 D 正反器（Positive Edge-Triggered）：

```
  Master (CLK̄ 透明)          Slave (CLK 透明)
  ┌─────────────────┐    ┌─────────────────┐
  │  CLK̄  CLK       │    │  CLK  CLK̄       │
  │   │    │        │    │   │    │        │
D─┤ TG1 ├─┬─INV1─┬─│──┤ TG3 ├─┬─INV3─┬── Q
  │        │      │ │    │       │      │
  │        └─INV2─┘ │    │       └─INV4─┘
  │   CLK  CLK̄      │    │  CLK̄  CLK      │
  │    │    │       │    │   │    │       │
  │  ┌┤ TG2 ├┐     │    │ ┌┤ TG4 ├┐     │
  └─────────────────┘    └─────────────────┘
```

動作（正緣觸發）：
- CLK = 0：Master 透明（TG1 通），Slave 鎖存（TG3 斷）
  → D 傳入 Master 內部節點
- CLK 0→1 上升緣：Master 鎖存（TG1 斷），Slave 透明（TG3 通）
  → Master 鎖住的值傳到 Q
- 結果：Q 在 CLK 上升緣取樣 D 值

(c) 電晶體數量：
每個 Latch = 8 個電晶體
主從式 FF = 2 × 8 = **16 個電晶體**
加上產生 CLK̄ 的反相器 = 2 個
**總計 18 個電晶體**

(d) 時序參數物理意義：

**Setup Time (tsetup)**：D 必須在 CLK 上升緣之前穩定的最小時間。
- 物理原因：D 需要足夠時間通過 Master 的 TG1 和 INV1 建立穩定電壓
- 若違反：Master 內部節點可能處於中間電壓（Metastability）

**Hold Time (thold)**：D 必須在 CLK 上升緣之後維持穩定的最小時間。
- 物理原因：CLK 上升緣後 TG1 需要有限時間完全關斷，D 若過早改變會影響鎖存值

**Clock-to-Q Delay (tcq)**：CLK 上升緣後到 Q 穩定輸出的時間。
- 物理原因：信號需通過 Slave 的 TG3 → INV3 的延遲

**答案**：主從式 D-FF 需 16-18 個電晶體；tsetup 保證取樣正確，thold 保證鎖存穩定，tcq 是輸出響應延遲。

**延伸思考**：在先進製程中，正反器是面積與功耗的大戶（占數位電路 30-50%）。TSMC 標準元件庫提供多種 FF 變體（帶 Reset、Set、Scan、Clock Enable 等），面試常問各種 FF 的面積/速度/功耗比較。

---
### 題目 22：TSPC 正反器
**來源**：台大電機 / 經典題型
**難度**：★★★★☆
**主題**：TSPC（True Single Phase Clock）正反器

**題目**：
(a) 畫出 TSPC D 正反器的電路圖（Yuan-Svensson 架構），標注所有電晶體。
(b) 分析預充與求值階段的動作（CLK = 0 與 CLK = 1）。
(c) TSPC 相比傳統主從式 FF 的優勢與劣勢。
(d) 計算 TSPC FF 的電晶體數量並與主從式 TG FF 比較。

**詳解**：

**解題思路**：TSPC 僅使用單相時脈（不需 CLK̄），透過動態節點儲存資訊。

**步驟**：

(a) TSPC D-FF（正緣觸發，Yuan-Svensson）：

```
  Stage 1          Stage 2          Stage 3
  (P-type)         (N-type)         (P-type output)

    VDD              VDD              VDD
     │                │                │
  ┌─P1(CLK)─┐     ┌─P3(X)──┐      ┌─P5(CLK)─┐
     │                │                │
  ┌─P2(D)──┐         │             ┌─P6(Y)──┐
     │             ┌─N3(CLK)┐         │
     X                │             ── Q
     │             ┌─N2(X)──┐         │
  ┌─N1(CLK)─┐        │             ┌─N4(CLK)─┐
     │                Y                │
    GND              GND              GND
```

共 6-9 個電晶體（依變體而定）。

核心版本（9 電晶體）：

Stage 1（CLK = 0 時預充）：
- P1(CLK=0 導通) + P2(D) 控制節點 X
- N1(CLK=0 截止) 截斷放電路徑

Stage 2（CLK = 1 時求值）：
- N3(CLK=1 導通) 開啟求值
- N2(X) 根據 X 的值決定是否放電 Y

Stage 3（輸出級）：
- 根據 Y 值產生 Q

(b) 動作分析：

**CLK = 0（預充）**：
- Stage 1：若 D=0，P2 導通，X 充到 VDD；若 D=1，P2 截止，X 維持低
  （更正：P1 由 CLK 控制，CLK=0 時 P1 導通）
  X = D̄（取反，因 PMOS pull-up + NMOS 截止）
- Stage 2：N3 截止，Y 維持（被 Stage 2 的 P3 預充）
- Stage 3：P5(CLK=0) 導通，根據 Y 預充 Q

**CLK = 1（求值）**：
- Stage 1：N1 導通，若 D=1 則 X 放電到 0
- Stage 2：N3 導通，若 X=0（D=1）則 N2 截止，Y 維持 VDD → Q = 0 再反相 → Q = 1
- Stage 3：N4 導通，根據 Y 進行求值

本質上實現了正緣觸發取樣 D 的功能。

(c) TSPC vs 主從式 TG FF：

| 特性 | TSPC | 主從式 TG |
|------|------|----------|
| 時脈相數 | 單相（僅 CLK） | 雙相（CLK + CLK̄） |
| 電晶體數 | 9-11 | 16-18 |
| 時脈負載 | 較小（3-4 個 Gate） | 較大（4-6 個 Gate） |
| 速度 | 快（動態） | 中 |
| 功耗 | 有時脈饋通問題 | 較乾淨 |
| 雜訊容忍 | 較差（動態節點） | 較好 |
| 時脈偏移容忍 | 較差 | 較好 |

(d) 電晶體數量：
TSPC：**9 個電晶體**
主從 TG：**18 個電晶體**
TSPC 節省 **50%** 電晶體！

**答案**：TSPC FF 僅需 9 個電晶體與單相時脈，比主從式省 50% 面積，但雜訊容忍度較低。

**延伸思考**：TSPC 在高速低功耗設計中很受歡迎，特別是在預除頻器（Prescaler）等高頻電路中。但在先進節點因漏電增加，動態節點的穩定性受挑戰。

---
### 題目 23：時序約束——最大頻率與 Hold Time Violation
**來源**：台大電機 / TSMC 面試必考
**難度**：★★★★☆
**主題**：時序約束分析

**題目**：
一個同步數位系統中，兩個正緣觸發 D-FF 之間有組合邏輯：

```
  CLK ──┬── FF1 ── [Combinational Logic] ── FF2 ──
        │                                    │
        └────────────────────────────────────┘
```

FF1 參數：tcq = 150ps，thold = 50ps
FF2 參數：tsetup = 100ps，thold = 60ps
組合邏輯延遲：tlogic(max) = 800ps，tlogic(min) = 200ps
時脈偏移：tskew = FF2 時脈比 FF1 延遲 30ps

(a) 推導最大工作頻率。
(b) 檢查是否有 Hold Time Violation。
(c) 若需操作在 1 GHz，tlogic(max) 最多允許多少？
(d) 若存在 Hold Violation，如何修復？

**詳解**：

**解題思路**：Setup 約束決定最大頻率，Hold 約束決定最小延遲。

**步驟**：

(a) Setup Time 約束（最大頻率）：

信號路徑：CLK1 → FF1(tcq) → Logic(tlogic) → FF2(tsetup)
需在下一個 CLK2 上升緣前穩定。

考慮 Clock Skew（FF2 時脈延遲 tskew）：
Tclk + tskew ≥ tcq + tlogic(max) + tsetup

注意：正偏移（FF2 晚到）有利於 setup，等效增加了可用時間：
Tclk ≥ tcq + tlogic(max) + tsetup - tskew
Tclk ≥ 150 + 800 + 100 - 30 = **1020 ps**

fmax = 1/Tclk = 1/1020ps = **980.4 MHz**

(b) Hold Time 約束：

FF1 輸出的最快信號不能在 FF2 的 Hold 時間窗口內改變：
tcq + tlogic(min) ≥ thold(FF2) + tskew

注意：正偏移（FF2 晚到）對 hold 不利，信號提前到但 FF2 的 hold window 延後：
150 + 200 ≥ 60 + 30
350 ≥ 90 → **350 ≥ 90 ✓ 無 Hold Violation**

餘裕（Slack）= 350 - 90 = 260ps（正值，安全）

(c) 1 GHz 操作需求（Tclk = 1000ps）：
1000 ≥ 150 + tlogic(max) + 100 - 30
tlogic(max) ≤ 1000 - 150 - 100 + 30 = **780 ps**

需要將組合邏輯從 800ps 優化到 780ps（減少 20ps）。

(d) Hold Violation 修復方法（若存在）：
1. **插入延遲緩衝器（Delay Buffer）**：在快速路徑上加入 buffer 增加 tlogic(min)
2. **使用較慢的邏輯閘**：替換高速元件為標準速度元件
3. **調整時脈偏移**：修改時脈樹使 tskew 減小或反向
4. **注意**：Hold Violation 無法靠降頻解決！（與頻率無關）

**答案**：fmax = 980.4 MHz；無 Hold Violation（餘裕 260ps）；1 GHz 需 tlogic ≤ 780ps。Hold Violation 與頻率無關，必須修改路徑延遲或時脈偏移。

**延伸思考**：Hold Violation 是 TSMC/MTK 面試的必考題。關鍵觀念：Setup 可靠降頻解決，Hold 不行。實際 STA（Static Timing Analysis）工具如 Synopsys PrimeTime 會自動檢查所有路徑的 Setup/Hold 約束。

---
### 題目 24：時脈偏移與時脈抖動分析
**來源**：台大電機 / 業界面試
**難度**：★★★☆☆
**主題**：Clock Skew 與 Clock Jitter

**題目**：
(a) 定義 Clock Skew 與 Clock Jitter 的差異。
(b) 在 Setup 約束中，分別加入 Skew 和 Jitter 的影響，寫出完整的時序約束公式。
(c) 一個系統 tcq = 100ps, tsetup = 80ps, tlogic = 600ps, tskew = ±50ps, tjitter = ±20ps。計算最大頻率。
(d) 何謂有益偏移（Useful Skew）？如何利用？

**詳解**：

**解題思路**：Skew 是確定性偏差（可正可負），Jitter 是隨機不確定性。

**步驟**：

(a) 定義差異：

**Clock Skew**：由於時脈分佈網路的路徑長度差異，導致不同暫存器看到的時脈上升緣有固定時間差。
- 確定性（Deterministic）
- 取決於佈局
- 可透過時脈樹合成（CTS）最小化

**Clock Jitter**：時脈邊緣的隨機時間變化，源自 PLL/DLL 的雜訊、電源雜訊等。
- 隨機性（Random）
- 不可完全消除
- 通常以 peak-to-peak 或 RMS 表示

(b) 完整時序約束：

**Setup 約束**（取最差情況）：
Tclk ≥ tcq + tlogic(max) + tsetup + tskew(worst) + tjitter

其中 tskew(worst) = |tskew_max|（取最大偏移量對 setup 最不利的方向）

更精確：
Tclk - tskew - tjitter ≥ tcq + tlogic + tsetup

即考慮目標 FF 的時脈可能提前到：
Tclk ≥ tcq + tlogic + tsetup + tskew + 2·tjitter

（2·tjitter 因為來源端和目標端各可能有 jitter）

**Hold 約束**：
tcq + tlogic(min) ≥ thold + tskew(worst) + tjitter

(c) 數值計算：
最差情況 setup：
Tclk ≥ tcq + tlogic + tsetup + tskew_max + 2·tjitter_max
= 100 + 600 + 80 + 50 + 2×20
= **870 ps**

fmax = 1/870ps = **1.149 GHz**

若不考慮 jitter：Tclk = 830ps → f = 1.205 GHz
Jitter 造成約 4.6% 的頻率損失。

(d) 有益偏移（Useful Skew）：

若目標 FF 的時脈延遲（正 skew），等效增加了可用的組合邏輯時間：

```
  FF1 ─── [Long path: 900ps] ─── FF2 (CLK delayed 100ps)
  FF1 ─── [Short path: 300ps] ─── FF3 (CLK early)
```

刻意讓 FF2 的時脈延遲 100ps，使長路徑滿足 setup：
Tclk_effective = Tclk + 100ps（對 FF2）

但必須確保 hold 約束不被破壞！

**時脈偏移調度（Clock Skew Scheduling）**就是利用 useful skew 平衡各路徑延遲的技術。

**答案**：Skew 是確定性的時脈偏差，Jitter 是隨機變化；fmax = 1.149 GHz；Useful Skew 可借時間給關鍵路徑。

**延伸思考**：在 TSMC 先進節點，CTS（Clock Tree Synthesis）是後端設計的核心步驟。有益偏移的概念在 Synopsys ICC2 / Cadence Innovus 中以 useful skew optimization 功能實現。

---
### 題目 25：C²MOS 鎖存器
**來源**：台大電機 / 經典題型
**難度**：★★★☆☆
**主題**：C²MOS（Clocked CMOS）

**題目**：
(a) 畫出 C²MOS 反相鎖存器電路圖並說明動作原理。
(b) 與 TG-based 鎖存器比較，C²MOS 的優缺點。
(c) 為何 C²MOS 主從式 FF 可以避免時脈重疊（Clock Overlap）問題？
(d) 分析 C²MOS 的時脈負載。

**詳解**：

**解題思路**：C²MOS 是在 CMOS 反相器上加入時脈控制電晶體。

**步驟**：

(a) C²MOS 反相鎖存器：

```
       VDD
        │
    ┌─P1(D̄)─┐         VDD
        │                │
    ┌─P2(CLK̄)┐      ┌─P3─┐ (回授)
        │                │
        ├──── Q ─────────┤
        │                │
    ┌─N2(CLK)─┐     ┌─N3─┐ (回授)
        │                │
    ┌─N1(D)──┐          GND
        │
       GND
```

更正確的架構：

主要路徑（Clocked Inverter）：
```
    VDD
     │
  ┌─Pp(D)──┐       ← PMOS, 閘接 D
     │
  ┌─Pc(CLK̄)─┐     ← 時脈 PMOS
     │
     ├── Q
     │
  ┌─Nc(CLK)─┐     ← 時脈 NMOS
     │
  ┌─Nn(D)──┐       ← NMOS, 閘接 D
     │
    GND
```

回授路徑（另一個 Clocked Inverter，反相時脈）：Q → 經 CLK/CLK̄ 控制 → 回到 Q

動作：
- CLK = 1：主路徑導通（Pc, Nc ON），D 的反相傳到 Q
- CLK = 0：主路徑關閉，回授路徑導通，Q 值被鎖存

(b) C²MOS vs TG Latch：

| 特性 | C²MOS | TG Latch |
|------|-------|----------|
| 電晶體數 | 8（4 主 + 4 回授） | 8（2TG + 2INV） |
| 驅動能力 | 好（有主動驅動） | 弱（TG 是被動開關） |
| 雜訊容忍 | 較好 | 中 |
| 功能 | 反相輸出 | 非反相輸出 |
| 時脈饋通 | 較小 | 可能較大 |

(c) 避免時脈重疊問題：
在主從式 FF 中，若 CLK 和 CLK̄ 同時為 1（重疊），TG 式會導致主從兩級同時透明 → 輸入直接穿透到輸出。

C²MOS 不會有此問題，因為每個 Clocked Inverter 需要 CLK 和 CLK̄ 分別接到 NMOS 和 PMOS。即使有短暫重疊，串聯的時脈電晶體提供了足夠的隔離。

具體地：若 CLK 有有限的上升/下降時間，C²MOS 的主從隔離比 TG 式更穩固。

(d) 時脈負載分析：
每個 C²MOS latch 有 2 個時脈電晶體（Nc 和 Pc）
主從式 FF 共 4 個時脈電晶體
CLK 負載 = 2 × (Wn + Wp) × Cox × L（兩個 latch 各一個 N 和一個 P）

**答案**：C²MOS 使用帶時脈的反相器，具有主動驅動能力與較好的時脈重疊容忍度，但輸出為反相。

**延伸思考**：C²MOS 鎖存器在動態邏輯的管線化（Pipelining）中常見。在 TSMC 元件庫中，某些高速 FF 變體採用 C²MOS 架構。

---
### 題目 26：管線化設計與吞吐量
**來源**：台大電機 / 經典題型
**難度**：★★★☆☆
**主題**：管線化（Pipelining）

**題目**：
一個組合邏輯電路總延遲為 Tlogic = 4 ns，需插入管線暫存器以提高吞吐量。每個 FF 的 tcq = 100ps，tsetup = 80ps。
(a) 無管線化時的最大吞吐量（Throughput）。
(b) 插入 3 級管線（4 等分），計算新的最大吞吐量與加速比。
(c) 管線化對延遲（Latency）的影響。
(d) 非等分管線的影響：若四級延遲分別為 0.8ns, 1.2ns, 1.0ns, 1.0ns，最大吞吐量為何？

**詳解**：

**解題思路**：管線化用 FF 切割邏輯，吞吐量由最慢級決定。

**步驟**：

(a) 無管線化：
Tclk ≥ Tlogic + tcq + tsetup = 4000 + 100 + 80 = 4180 ps
fmax = 1/4.18ns = **239.2 MHz**
吞吐量 = **239.2 M operations/sec**

(b) 4 等分管線：
每級邏輯延遲 = 4ns / 4 = 1ns
Tclk ≥ 1000 + 100 + 80 = 1180 ps
fmax = 1/1.18ns = **847.5 MHz**

加速比 = 847.5 / 239.2 = **3.54 倍**
（理想 4 倍，因 FF 開銷而打折）

FF 開銷導致的效率損失：
理想加速 = 4×
實際加速 = 3.54×
效率 = 3.54/4 = 88.5%

(c) 延遲（Latency）影響：
無管線：Latency = 4.18 ns（一個運算的完成時間）
4 級管線：Latency = 4 × 1.18 = 4.72 ns

**管線化增加了延遲！**（增加了 0.54ns = 3 個 FF 的 tcq + tsetup 開銷）

管線化是以延遲換吞吐量的典型 trade-off。

(d) 非等分管線：
Tclk 由最慢級決定：
Tclk ≥ max(0.8, 1.2, 1.0, 1.0) ns + tcq + tsetup
= 1200 + 100 + 80 = **1380 ps**

fmax = 1/1.38ns = **724.6 MHz**

比等分管線的 847.5 MHz 慢了 14.5%！
**管線化的關鍵是平衡各級延遲。**

較快級的多餘時間被浪費（idle time），降低了整體效率。

**答案**：等分 4 級管線加速 3.54 倍至 847.5 MHz；非等分管線僅 724.6 MHz；管線化增加延遲但提高吞吐量。

**延伸思考**：管線化是處理器設計的核心概念。Intel/AMD 的 CPU 管線深度可達 15-20 級。但過深的管線有分支預測錯誤懲罰問題。在 ASIC 設計中，Synopsys 的 pipeline retiming 功能可自動調整 FF 位置以平衡管線。

---
### 題目 27：時脈分佈網路設計
**來源**：台大電機 / 業界面試
**難度**：★★★★☆
**主題**：時脈分佈（Clock Distribution）

**題目**：
一個晶片有 100,000 個暫存器需要時脈信號，晶片面積 10mm × 10mm。
(a) 說明 H-tree 時脈分佈的架構與工作原理。
(b) 若 H-tree 有 5 級，計算每級的線段長度。
(c) 比較 H-tree、Clock Mesh 與 Clock Spine 三種架構的優缺點。
(d) 計算 5 級 H-tree 的時脈負載（假設每級驅動下一級 + 局部暫存器）。

**詳解**：

**解題思路**：時脈分佈的核心目標是最小化 skew 且保證驅動能力。

**步驟**：

(a) H-tree 架構：

```
        Level 0
    ┌──────┴──────┐      Level 1
    │             │
  ┌─┴─┐       ┌─┴─┐     Level 2
  │   │       │   │
 ┌┴┐ ┌┴┐   ┌┴┐ ┌┴┐     Level 3
 ││ ││   ││ ││
```

- 從中心點出發，每級分支為 2（二叉樹）
- 每級的線段長度遞減為上一級的 1/√2
- 所有末端到根節點的路徑長度完全相同 → 零偏移（理想情況）

(b) 線段長度計算：
晶片邊長 = 10mm
Level 0 線段（從中心到第一分支）：L₀ = 10/(2√2) ≈ 3.536 mm
Level 1：L₁ = L₀/√2 = 3.536/1.414 ≈ 2.5 mm
Level 2：L₂ = L₁/√2 ≈ 1.768 mm
Level 3：L₃ ≈ 1.25 mm
Level 4：L₄ ≈ 0.884 mm

更簡化的計算：
5 級 H-tree 覆蓋 2⁵ = 32 個端點（每維度 √32 ≈ 5.66 個分區）

每級長度 = 晶片邊長 / (2^(k+1)/2)，k 為層級

驗證：總覆蓋 = 能到達所有 32 個分區中心

(c) 三種架構比較：

| 特性 | H-tree | Clock Mesh | Clock Spine |
|------|--------|-----------|-------------|
| Skew | 很小（等長） | 最小（短路均化） | 中等 |
| 功耗 | 中 | 高（大量金屬） | 低 |
| 面積 | 中 | 高（佔金屬層） | 低 |
| Jitter | 中 | 低（均化） | 高 |
| 設計複雜度 | 高 | 中 | 低 |
| 適用場景 | 高速處理器 | 高性能 SoC | 低功耗設計 |

Clock Mesh 在頂層金屬形成網格，所有交叉點短路 → 電阻性平均化減少 skew。
Clock Spine 是簡單的主幹+分支結構。

(d) 時脈負載估算：
5 級 H-tree 有 2⁵ = 32 個末端
每個末端驅動 100000/32 ≈ 3125 個 FF

假設每個 FF 時脈輸入電容 = 5 fF：
末端負載 = 3125 × 5fF = 15.6 pF
加上互連電容，每個末端驅動 ≈ 20-30 pF

從根到末端的總負載 = 32 × 20pF + 互連電容 ≈ 640 pF + 數百 pF 互連
**總時脈負載約 1-2 nF 級別**

需要強大的時脈驅動器（Clock Driver）！

**答案**：H-tree 通過等長路徑最小化 skew；Clock Mesh 以功耗換取最低 skew；5 級 H-tree 有 32 端點，總負載約 nF 級。

**延伸思考**：在 TSMC 先進節點，CTS（Clock Tree Synthesis）是 EDA 自動完成的。但高性能處理器（如 Apple M 系列晶片）的 clock mesh 仍需大量人工設計。面試常問 CTS 的 target skew 設定。

---
### 題目 28：時脈閘控省電
**來源**：MTK 面試 / 低功耗設計
**難度**：★★★☆☆
**主題**：Clock Gating

**題目**：
(a) 畫出基本的 AND-based Clock Gating 電路，說明為何直接用 AND 閘會產生毛刺（Glitch）。
(b) 畫出 ICG（Integrated Clock Gating）cell 的正確實現（Latch-based），解釋動作。
(c) 一個模組有 1000 個 FF，時脈頻率 500 MHz，每個 FF 時脈電容 10 fF，VDD = 0.9V。若 Clock Gating 使 60% 的時間時脈被關閉，節省多少功率？
(d) Clock Gating 的面積開銷與使用條件。

**詳解**：

**解題思路**：Clock Gating 在不需要時脈的週期關閉時脈分佈，消除切換功耗。

**步驟**：

(a) AND-based Clock Gating 的問題：

```
  EN ──────┐
            AND ──── GCLK
  CLK ─────┘
```

問題：若 EN 在 CLK = 1 時改變，AND 閘輸出會產生毛刺！
例如 CLK = 1 時 EN 從 1→0，GCLK 會產生一個短暫的下降脈衝 → FF 可能誤觸發。

(b) ICG（Latch-based）正確實現：

```
          ┌────────┐
  EN ─────┤ D-Latch ├─── EN_latched ──┐
          │ CLK̄    │                   AND ── GCLK
          └────────┘                   │
  CLK ────────────────────────────────┘
```

動作：
- CLK = 0 時：Latch 透明，EN 值被取樣
- CLK = 1 時：Latch 鎖存，EN_latched 穩定不變
- AND 閘：GCLK = CLK · EN_latched

因為 EN_latched 在 CLK = 1 時不會改變 → 不會產生毛刺！

時序：EN 必須在 CLK 上升緣前穩定（滿足 Latch 的 setup time）。

(c) 功率節省計算：

時脈樹功率（切換功耗）：
Pclk = CL_total · VDD² · f

CL_total = 1000 × 10fF = 10 pF（僅 FF 端）
加上時脈樹互連估計 ×2 → CL ≈ 20 pF

Pclk = 20pF × (0.9V)² × 500MHz = 20×10⁻¹² × 0.81 × 5×10⁸
= **8.1 mW**

Clock Gating 60% 時間關閉：
節省功率 = 0.6 × 8.1 = **4.86 mW**

每年在手機 SoC 中，這樣的節省累積起來非常可觀。

(d) 面積開銷與使用條件：
ICG cell 面積 ≈ 1 個 Latch + 1 個 AND ≈ 12-16 個電晶體
- 面積開銷 ≈ 等效 2 個 FF
- 一般規則：若 Clock Gating 控制的 FF 數量 ≥ 3-4 個，就值得使用
- EDA 工具（如 Synopsys Power Compiler）可自動插入 ICG

使用條件：
- FF group 有共同的 enable 信號
- Enable 信號在 CLK 低電平時穩定
- 不適用於時脈頻率極高且 gating 比例低的情況

**答案**：ICG 使用 Latch + AND 避免毛刺；60% gating 節省 4.86mW；一般控制 ≥ 3 個 FF 即值得使用。

**延伸思考**：Clock Gating 是 TSMC/MTK 低功耗設計的基本功。在 SoC 中，Clock Gating 可節省 20-40% 的動態功耗。面試必問「ICG 為何用 Latch 而非 FF？」——因為 Latch 在 CLK 低時透明，恰好讓 EN 在 CLK 高之前穩定。

---
### 題目 29：亞穩態與同步器設計
**來源**：台大電機 / 業界面試
**難度**：★★★★☆
**主題**：亞穩態（Metastability）

**題目**：
(a) 解釋正反器的亞穩態（Metastability）現象，畫出 VTC 圖說明三個穩定點。
(b) 推導亞穩態解析時間 tresolution 與 MTBF（Mean Time Between Failures）的關係。
(c) 設計一個雙級同步器（Two-Flop Synchronizer）處理跨時脈域信號，計算其 MTBF。
(d) 何時需要三級同步器？

**詳解**：

**解題思路**：亞穩態是數位系統的根本物理限制，同步器用概率方式降低失敗率。

**步驟**：

(a) 亞穩態現象：

正反器的回授環路有三個平衡點：

```
  Vout
  VDD ┤──────●           ← 穩定點 1 (Logic 1)
      │     ╱╲
      │    ╱  ╲
      │ ──●────          ← 亞穩態點 (Metastable, VM)
      │  ╱    ╲
      │ ╱      ╲
  0   ●─────────         ← 穩定點 0 (Logic 0)
      └─────────── Vin
```

當 D 在 Setup/Hold 窗口內變化，FF 內部可能停在中間電壓（VM 附近）。
這個亞穩態點是不穩定的——任何微小擾動最終會使輸出偏向 0 或 1。
但解析時間不確定，可能很長。

(b) MTBF 推導：

亞穩態機率隨等待時間指數衰減：
P(unresolved at time t) = T₀ · f_data · f_clk · e^(-t/τ)

其中：
- T₀：亞穩態時間常數（Setup/Hold 窗口，~ps 級）
- τ：解析時間常數（與 FF 的增益-頻寬積相關，~ps 級）
- f_data：數據切換頻率
- f_clk：取樣時脈頻率

MTBF = 1 / (T₀ · f_data · f_clk · e^(-t_resolve/τ))

(c) 雙級同步器：

```
  Async_in → [FF1] → [FF2] → Sync_out
               CLK     CLK
```

FF1 可能進入亞穩態，但有一整個時脈週期（Tclk - tsetup）讓它解析。
FF2 看到的是已經（大概率）解析完的信號。

t_resolve = Tclk - tsetup

MTBF = 1 / (T₀ · f_data · f_clk · e^(-(Tclk - tsetup)/τ))

典型數值：T₀ = 0.04, τ = 20ps, f_data = 100MHz, f_clk = 500MHz, Tclk = 2ns, tsetup = 80ps

MTBF = 1 / (0.04 × 10⁸ × 5×10⁸ × e^(-(2000-80)/20))
= 1 / (2×10¹⁵ × e^(-96))
= 1 / (2×10¹⁵ × 1.07×10⁻⁴²)
= 1 / (2.14×10⁻²⁷)
≈ **4.67 × 10²⁶ 秒** ≈ **10¹⁹ 年**

遠大於宇宙壽命，非常安全！

(d) 三級同步器使用情境：
- 在非常高速的設計中（Tclk 很短），解析時間不足
- 若 MTBF < 目標壽命（如 10 年 × 安全係數 1000 = 10000 年）
- 三級同步器增加一個 Tclk 的額外解析時間
- 代價：增加一個時脈週期的延遲

**答案**：亞穩態是不可避免的物理現象；雙級同步器 MTBF 可達 10¹⁹ 年（非常安全）；高速或安全關鍵系統可用三級。

**延伸思考**：跨時脈域（CDC, Clock Domain Crossing）設計是 ASIC 驗證的重點。Synopsys CDC 工具（如 SpyGlass CDC）可自動檢測缺少同步器的跨域信號。TSMC/MTK 面試常問 CDC 的處理方法。

---
### 題目 30：掃描鏈設計與可測試性
**來源**：台大電機 / 業界面試
**難度**：★★★☆☆
**主題**：掃描鏈（Scan Chain）基礎

**題目**：
(a) 畫出 Scan D Flip-Flop（SFF）的結構，說明正常模式與掃描模式的切換。
(b) 一個設計有 10,000 個 FF，分成 10 條掃描鏈，時脈頻率 100 MHz。計算一個完整的掃描測試向量（Scan Pattern）所需的時脈週期數與時間。
(c) 掃描鏈對面積與時序的影響。
(d) 說明 Scan Compression 的概念。

**詳解**：

**解題思路**：Scan Design 將所有 FF 串聯，可從外部控制和觀察內部狀態。

**步驟**：

(a) Scan D Flip-Flop：

```
  D  ──┐
       MUX ──── D_FF ──── Q
  SI ──┘  │      │
          SE     CLK

  SE = 0 (Normal)：D_FF 取樣 D（正常功能模式）
  SE = 1 (Scan)：D_FF 取樣 SI（掃描輸入，來自前一個 SFF 的 Q）
```

正常模式（SE = 0）：電路正常運作
掃描模式（SE = 1）：所有 FF 串成移位暫存器（Shift Register）

測試流程：
1. SE = 1：Shift In（將測試向量串入所有 FF）
2. SE = 0：Capture（施加一個正常時脈，捕獲電路響應）
3. SE = 1：Shift Out（將結果串出，同時串入下一個測試向量）

(b) 時脈週期計算：
10,000 個 FF / 10 條鏈 = 每條鏈 1,000 個 FF

一個完整的 Scan Pattern：
- Shift In：1,000 個時脈週期（串入 1000 位元）
- Capture：1 個時脈週期
- Shift Out：1,000 個時脈週期（可與下一次 Shift In 重疊）

不重疊：2,001 個週期/pattern
重疊：1,001 個週期/pattern（Shift Out 與下一個 Shift In 同時進行）

時間（重疊）= 1001 × (1/100MHz) = 1001 × 10ns = **10.01 μs/pattern**

若需 500 個 patterns：
總測試時間 = 500 × 10.01μs = **5.005 ms**

(c) 面積與時序影響：
面積：每個 FF 增加一個 2:1 MUX（約 4-6 個電晶體）
→ 面積增加 ≈ 15-20%

時序：MUX 在 D 輸入端增加延遲
→ tsetup 增加約 50-100ps
→ 可能影響關鍵路徑（需 timing-aware scan insertion）

(d) Scan Compression：
問題：大量 FF 導致掃描測試時間過長
解決：在 Scan In 端加入解壓器（Decompressor），Scan Out 端加入壓縮器（Compressor）

```
  少量 Scan In → [Decompressor] → 多條內部 Scan Chain → [Compressor] → 少量 Scan Out
```

壓縮比：通常 10:1 到 100:1
例如：100 條內部鏈，但只需 10 個 Scan I/O pin
測試時間降為 1/10！

典型工具：Synopsys DFTMAX, Cadence Modus

**答案**：SFF = MUX + DFF；10,000 FF / 10 鏈需 ~10μs/pattern；面積增 15-20%；Scan Compression 可壓縮 10-100 倍。

**延伸思考**：DFT（Design for Testability）是 IC 設計流程不可或缺的一環。TSMC 在封裝測試中依賴掃描測試來篩選良品。面試常問「Scan 與 ATPG（Automatic Test Pattern Generation）的關係」以及「如何處理 Scan 對時序的影響」。

---

## Part 4：互連與佈局（題目 31–40）

---
### 題目 31：互連電阻與電容模型
**來源**：台大電機 / 經典題型
**難度**：★★★☆☆
**主題**：互連（Interconnect）建模

**題目**：
一條鋁互連線（Metal 3）參數如下：長度 L = 1mm，寬度 W = 0.5μm，厚度 t = 0.6μm，電阻率 ρ = 2.7 μΩ·cm。介電層（ILD）厚度 H = 0.8μm，相對介電常數 εr = 3.9（SiO₂）。
(a) 計算總電阻。
(b) 計算平行板電容（上下接地面之間）。
(c) 估算邊緣電容（Fringing Capacitance）的影響。
(d) 若改用銅（ρ_Cu = 1.7 μΩ·cm），電阻改善多少？

**詳解**：

**解題思路**：使用基本的電阻與電容公式，注意單位換算。

**步驟**：

(a) 互連電阻：
R = ρ · L / (W · t)
= 2.7×10⁻⁶ Ω·cm × 0.1cm / (0.5×10⁻⁴cm × 0.6×10⁻⁴cm)
= 2.7×10⁻⁷ / (3×10⁻⁹)
= **90 Ω**

也可用方塊電阻（Sheet Resistance）：
R□ = ρ/t = 2.7×10⁻⁶ / (0.6×10⁻⁴) = 0.045 Ω/□
方塊數 = L/W = 1000μm / 0.5μm = 2000 □
R = R□ × N□ = 0.045 × 2000 = **90 Ω** ✓

(b) 平行板電容（假設上下各一個接地面）：
Cpp = ε₀ · εr · W · L / H（單面）
= 8.854×10⁻¹² × 3.9 × 0.5×10⁻⁶ × 1×10⁻³ / (0.8×10⁻⁶)
= 8.854×10⁻¹² × 3.9 × 0.625×10⁻³
= **21.6 fF**（單面）

雙面（上下各一個接地面）：
Cpp_total = 2 × 21.6 = **43.2 fF**

(c) 邊緣電容估算：
經驗公式（對於 W/H ≈ 0.625）：
Cfringe ≈ 2 × ε₀ · εr · L × [0.77 + 1.06(W/H)^0.25 + 1.06(t/H)^0.5] / π

簡化估算：當 W 與 H 同量級時，邊緣電容可達平行板電容的 50-100%。

Cfringe ≈ 0.7 × Cpp_total ≈ 30 fF

總電容：Ctotal ≈ 43.2 + 30 = **73.2 fF**

在先進製程中（W < H），邊緣電容甚至可能超過平行板電容，成為主導！

(d) 銅互連改善：
R_Cu = R_Al × (ρ_Cu/ρ_Al) = 90 × (1.7/2.7) = **56.7 Ω**

改善 = (90 - 56.7)/90 = **37% 降低**

這就是為何 180nm 以後的製程都採用銅互連（Copper Interconnect, 大馬士革製程）。

**答案**：R = 90Ω（鋁），Ctotal ≈ 73fF（含邊緣電容）；銅互連電阻降 37%。

**延伸思考**：在 TSMC 5nm 以下，互連延遲已超過閘延遲成為主要瓶頸。低介電常數（Low-k）材料（εr < 3.0）與氣隙（Air Gap）技術是解決方案。面試常問「為何先進節點的互連 RC 增加？」

---
### 題目 32：Elmore Delay 模型
**來源**：台大電機 / 必考經典
**難度**：★★★★☆
**主題**：Elmore Delay

**題目**：
考慮一條 RC 互連線被分為 N 段的集總模型（Lumped Model），每段 r = R/N，c = C/N。
(a) 推導 Elmore Delay 公式 τ_Elmore = Σᵢ Rᵢ · Cᵢ 的一般形式。
(b) 對於均勻 RC 線，證明 τ_Elmore = RC/2（集總 π 模型）或更精確的 0.69RC/2 = 0.345RC（50% 延遲）。
(c) 一條互連線 R = 100Ω，C = 50fF，驅動端有驅動電阻 Rd = 200Ω。計算從驅動端到遠端的 Elmore Delay。
(d) 比較集總（Lumped）、π 型與分佈式（Distributed）RC 模型的精確度。

**詳解**：

**解題思路**：Elmore Delay 是 RC 樹（RC Tree）延遲的一階近似。

**步驟**：

(a) Elmore Delay 一般公式：

對於 RC 樹中從根節點到目標節點 j 的延遲：

τ_D(j) = Σᵢ (所有電容 Cᵢ) × R(共同路徑_ij)

其中 R(共同路徑_ij) 是從根到 Cᵢ 的路徑與從根到 j 的路徑的共同部分的電阻。

更直觀地：每個電容 Cᵢ 對延遲的貢獻 = Cᵢ × (從根到 Cᵢ 的路徑中與到 j 共享的電阻)。

(b) 均勻 RC 線證明：

將線分為 N 段，每段 r = R/N，c = C/N。

到遠端（第 N 段）的 Elmore Delay：
τ = Σᵢ₌₁ᴺ (i·r) · c = c·r · Σᵢ₌₁ᴺ i = c·r · N(N+1)/2

= (C/N)(R/N) · N(N+1)/2 = RC · (N+1)/(2N)

當 N → ∞：τ_Elmore = RC · 1/2 = **RC/2**

50% 延遲（一階 RC 的 50% 點）：
t50% = 0.69 · τ_Elmore = 0.69 · RC/2 = **0.345RC**

更精確的分佈式 RC 線延遲：t50% = 0.377RC

Elmore 在此情況誤差約 8.5%。

(c) 有驅動電阻的 Elmore Delay：

```
  Vdd ── Rd ──┤── r ── r ── ... ── r ──┤
              c    c              c     (遠端)
```

將互連分佈為集總（取 π 模型：R_wire 集中，C_wire/2 在兩端）：

τ = Rd · C_wire + R_wire · C_wire/2
= 200 × 50fF + 100 × 50fF/2
= 10000fF·Ω + 2500fF·Ω
= 10ps + 2.5ps
= **12.5 ps**（Elmore Delay）

50% 傳播延遲：
t50% = 0.69 × 12.5 = **8.625 ps**

更精確（考慮分佈式）：
τ = Rd · C + RC/2 = 200×50f + 100×50f/2 = 12.5 ps
t50% = 0.69 × (Rd·C + RC/2) = **8.625 ps**

(d) 模型精確度比較：

| 模型 | 延遲公式 | 精確度 | 計算量 |
|------|---------|--------|--------|
| 集總（Lumped） | 0.69·(R_total)·C | 最粗略 | O(1) |
| π 模型 | 0.69·(Rd·C + RC/2) | 中等（~10%誤差） | O(1) |
| Elmore (N段) | 精確求和 | 良好（~5%誤差） | O(N) |
| 分佈式精確 | 0.377RC（無 Rd） | 精確 | 需解 PDE |

**答案**：均勻 RC 線 Elmore Delay = RC/2；含驅動電阻 τ = Rd·C + RC/2 = 12.5ps；50% 延遲 ≈ 8.6ps。

**延伸思考**：Elmore Delay 是所有 EDA timing 工具（如 Synopsys PrimeTime）的基礎近似。在精確度需求高的場合，工具會使用 AWE（Asymptotic Waveform Evaluation）多極點模型。

---
### 題目 33：緩衝器插入最佳化
**來源**：台大電機 / 業界面試
**難度**：★★★★☆
**主題**：Buffer Insertion

**題目**：
一條長互連線總電阻 R_wire = 1kΩ，總電容 C_wire = 500fF。驅動端為最小反相器（Rd = 5kΩ, Cin = 3fF），負載 CL = 100fF。
(a) 無緩衝器時的延遲。
(b) 推導最佳緩衝器插入數量 k_opt 與最小延遲。
(c) 若緩衝器可調大小（尺寸因子 s），聯合最佳化 k 和 s。
(d) 數值計算最佳化結果。

**詳解**：

**解題思路**：緩衝器將長線切段，每段的 RC 延遲大幅降低（RC ∝ L²）。

**步驟**：

(a) 無緩衝器延遲：
τ = 0.69 × [Rd · (C_wire + CL) + R_wire · C_wire/2 + R_wire · CL]
= 0.69 × [5k×600f + 1k×250f + 1k×100f]
= 0.69 × [3000p + 250p + 100p]
= 0.69 × 3350p
= **2311.5 ps ≈ 2.31 ns**

(b) 插入 k 個等間距緩衝器：

每段：R_seg = R_wire/(k+1)，C_seg = C_wire/(k+1)
每個緩衝器（尺寸 1x）：Rd_buf = 5kΩ，Cin_buf = 3fF

每段延遲（不含最後負載）：
τ_seg = 0.69 × [Rd_buf · (C_seg + Cin_buf) + R_seg · C_seg/2]

總延遲：
τ_total = (k+1) × τ_seg + 0.69 × Rd_buf · CL（最後一段到 CL）

簡化（忽略 Cin_buf 相對 C_seg 很小的情況）：
τ ≈ 0.69 × [(k+1)·Rd·C_wire/(k+1) + (k+1)·R_wire·C_wire/(2(k+1)²)]
+ 0.69 × (k+1)·Rd·Cin + ...

更系統化：
τ = 0.69 × {(k+1)[Rd·Cw/(k+1) + Rw·Cw/(2(k+1)²)] + k·Rd·Cin + Rd·CL}

= 0.69 × {Rd·Cw + Rw·Cw/(2(k+1)) + k·Rd·Cin + Rd·CL}

對 k 微分令 dτ/dk = 0：
0 = -Rw·Cw/(2(k+1)²) + Rd·Cin

k_opt + 1 = √(Rw·Cw / (2·Rd·Cin))

代入數值：
k_opt + 1 = √(1000×500f / (2×5000×3f))
= √(500000f / 30000f)
= √16.67 = 4.08

**k_opt ≈ 3 個緩衝器**（4 段）

(c) 聯合最佳化（緩衝器尺寸 s）：
尺寸 s 的緩衝器：Rd(s) = Rd/s，Cin(s) = s·Cin

τ ∝ Rd·Cw/s + Rw·Cw/(2(k+1)) + k·(Rd/s)·(s·Cin) + (Rd/s)·CL

對 s 微分：最佳 s 使驅動延遲與負載延遲平衡。

(d) 數值計算（k = 3, 尺寸 1x）：
τ = 0.69 × {5k×500f/(1) + 1k×500f/(2×4) + 3×5k×3f + 5k×100f}

修正：
每段 R_seg = 1k/4 = 250Ω, C_seg = 500f/4 = 125fF
每段延遲 = 0.69 × [5k×(125f+3f) + 250×125f/2]
= 0.69 × [640p + 15.625p] = 0.69 × 655.6p = 452.4ps

最末段到 CL：0.69 × 5k × 100f = 345ps

4 段 + 末端：4 × 452.4 + 345 = **2154.6 ps**

嗯，改善不大。讓我重新計算，考慮無 buffer 的 R² 效應：

重點是 R_wire · C_wire/2 項：
無 buffer：Rw·Cw/2 = 1k×500f/2 = 250ps
有 4 段：4 × (Rw/4)·(Cw/4)/2 = 4 × 250×125f/2 = 4×15.6 = 62.5ps

**RC 互連延遲從 250ps 降至 62.5ps（改善 4 倍）！**

但增加了 3 個 buffer 的固有延遲。總體仍有改善。

**答案**：最佳插入 k ≈ 3 個 buffer；RC 互連延遲因分段而降至 1/(k+1) 倍。

**延伸思考**：Buffer Insertion 是 Cadence Innovus / Synopsys IC Compiler 中 routing 後最佳化的核心功能。Van Ginneken 演算法是最經典的 buffer insertion 演算法。

---
### 題目 34：串擾分析
**來源**：台大電機 / 業界面試
**難度**：★★★★☆
**主題**：串擾（Crosstalk）

**題目**：
兩條平行互連線相距 S，長度 L = 2mm，耦合電容 Cc = 80fF，受害線（Victim）自身電容 Cv = 50fF，驅動電阻 Rd = 500Ω。
(a) 攻擊線（Aggressor）快速切換時，受害線的耦合雜訊峰值 ΔV 為何？（VDD = 1.0V）
(b) 同向切換（Same Direction Switching）時，等效電容如何變化？反向切換呢？
(c) 串擾對時序的影響：加速效應與減速效應。
(d) 如何降低串擾？列出至少四種方法。

**詳解**：

**解題思路**：串擾透過耦合電容傳遞，受害線上產生電壓擾動。

**步驟**：

(a) 耦合雜訊峰值：

受害線靜止（被 hold），攻擊線切換 VDD：
ΔV = Cc / (Cc + Cv) × VDD

分壓效應：
ΔV = 80fF / (80fF + 50fF) × 1.0V
= 80/130 × 1.0
= **0.615V**

這是非常大的耦合雜訊（超過 VDD/2）！可能導致邏輯錯誤。

考慮驅動端的衰減（受害線有驅動器 hold 住）：
若受害線驅動器等效電阻 Rd = 500Ω：
ΔV_peak = Cc · VDD / (Cc + Cv) × e^(-t_rise/(Rd·(Cc+Cv)))（暫態分析）

更簡化：靜態最差情況為 0.615V。

(b) Miller 效應與等效電容：

**同向切換**（兩線同時 0→1 或 1→0）：
ΔV 跨 Cc 不變 → Cc 不充放電 → 等效 Cc = 0
有效電容 Ceff = Cv（減少！）
→ **加速效應**：信號傳播更快

**反向切換**（一線 0→1，另一線 1→0）：
ΔV 跨 Cc = 2·VDD → Cc 充放電加倍 → 等效 Cc = 2·Cc
有效電容 Ceff = Cv + 2Cc = 50 + 160 = 210fF（增加 4.2 倍！）
→ **減速效應**：信號傳播大幅變慢

總結（Miller Coupling Factor）：
| 切換方向 | Miller Factor | 等效 Cc |
|---------|--------------|---------|
| 同向 | 0 | 0 |
| 靜止 | 1 | Cc |
| 反向 | 2 | 2Cc |

(c) 時序影響：

功能性串擾（Functional Crosstalk）：
- 受害線靜止時被注入雜訊 → 可能翻轉邏輯值 → **功能錯誤**

時序串擾（Timing Crosstalk）：
- 同向：加速（setup 改善但 hold 惡化）
- 反向：減速（setup 惡化但 hold 改善）
- STA 工具需考慮最差情況的串擾組合

(d) 降低串擾的方法：

1. **增加間距（Spacing）**：Cc ∝ 1/S，加大 S 有效降低耦合
2. **插入屏蔽線（Shielding）**：在敏感信號旁放 VDD/GND 屏蔽線
3. **交錯佈線層（Alternating Routing）**：相鄰信號走不同金屬層（正交）
4. **降低驅動電阻**：使用較大的驅動器更快「壓住」耦合雜訊
5. **縮短平行走線長度**：減少耦合電容
6. **使用差分信號（Differential Signaling）**：自然抵消共模耦合

**答案**：耦合雜訊峰值 ≈ 0.615V；反向切換 Miller Factor = 2（延遲大增）；同向切換 Miller Factor = 0（加速）。

**延伸思考**：在 TSMC 先進節點，金屬線間距極小，串擾已成為 timing closure 的主要挑戰。Synopsys PrimeTime SI（Signal Integrity）模組專門處理串擾對 STA 的影響。

---
### 題目 35：電源完整性分析
**來源**：業界面試 / 經典題型
**難度**：★★★★☆
**主題**：電源完整性（Power Integrity）

**題目**：
一個晶片核心區域有 10⁶ 個邏輯閘同時切換，每次切換的平均電流脈衝 Ipulse = 100μA，持續 100ps。電源網路從 pad 到核心的等效電阻 R = 50mΩ，等效電感 L = 1nH。VDD = 0.9V。
(a) 計算 IR Drop。
(b) 計算 L·di/dt 雜訊。
(c) 總電壓降佔 VDD 的百分比，是否可接受？
(d) 去耦電容（Decoupling Capacitor）的作用與設計。

**詳解**：

**解題思路**：電源完整性考慮電阻壓降與電感雜訊。

**步驟**：

(a) IR Drop：
總切換電流：I_total = 10⁶ × 100μA = 100A（峰值！）

等等——10⁶ 個閘不會同時在同一瞬間切換。
假設同時切換比例（Switching Factor）= 10%：
I_peak = 0.1 × 10⁶ × 100μA = 10A

IR Drop = I_peak × R = 10A × 50mΩ = **0.5V**（太大了！）

這顯示 R = 50mΩ 的假設對 10A 電流不合理。實際設計中電源網路電阻更低。

修正假設：R = 5mΩ（合理的電源網路）
IR Drop = 10A × 5mΩ = **50 mV**

(b) L·di/dt 雜訊：
di/dt = I_peak / t_rise = 10A / 100ps = 10A / 100×10⁻¹² = 10¹¹ A/s

ΔV_L = L × di/dt = 1×10⁻⁹ × 10¹¹ = **100 mV**

(c) 總電壓降：
ΔV_total = IR + L·di/dt = 50 + 100 = **150 mV**
佔 VDD 比例 = 150/900 = **16.7%**

一般設計要求 ΔV < 10% VDD = 90mV → **不可接受！**

需要改善電源網路或增加去耦電容。

(d) 去耦電容（Decoupling Capacitor, Decap）：

作用：在突然的電流需求時提供局部電荷儲備，減少 L·di/dt 雜訊。

```
  VDD_pad ──L──R── VDD_core
                     │
                   [Cdecap]
                     │
  GND_pad ──────── GND_core
```

所需去耦電容：
Cdecap > I_peak × Δt / ΔV_allowed
= 10A × 100ps / 90mV
= 1000×10⁻¹² / 90×10⁻³
= **11.1 nF**

來源：
1. 晶片上（On-chip）：利用閘氧化層電容（MOS cap），通常 1-10 nF/mm²
2. 封裝上（Package）：離散電容器，10-100 nF
3. PCB 上：μF 級電容

多層級去耦（Frequency Domain）：
- On-chip Decap：響應 GHz 級快速雜訊
- Package Decap：響應 100MHz-GHz
- PCB Decap：響應 < 100MHz

**答案**：IR Drop = 50mV，L·di/dt = 100mV，總 150mV（16.7% VDD，超標）；需 ≥ 11nF 去耦電容。

**延伸思考**：電源完整性是 TSMC 先進節點設計的重大挑戰。Synopsys RedHawk / Cadence Voltus 是專門的電源完整性分析工具。面試常問「IR Drop 如何影響 timing？」——本地 VDD 降低 → 閘延遲增加 → 可能 timing violation。

---
### 題目 36：Latch-up 成因與防治
**來源**：台大電機 / TSMC 面試
**難度**：★★★★☆
**主題**：Latch-up

**題目**：
(a) 解釋 CMOS 中 Latch-up 的成因，畫出寄生 PNPN 結構（等效 SCR）。
(b) 列出觸發 Latch-up 的條件。
(c) 說明保護環（Guard Ring）的工作原理。
(d) 除了 Guard Ring 外，還有哪些防止 Latch-up 的方法？

**詳解**：

**解題思路**：CMOS 結構中固有的寄生 BJT 形成正回授 SCR。

**步驟**：

(a) CMOS 寄生 PNPN 結構：

```
  VDD                              GND
   │                                │
   │   ┌─── PMOS ───┐              │
   │   │ p+  N-well  p+ │          │
   ├───┘              │             │
   │                  │   ┌── NMOS ──┐
   │                  │   │ n+ P-sub n+ │
   │                  └───┤           │
   │                      └───────────┤
   │                                  │

  寄生結構：
  VDD ── p+(PMOS S) ── N-well ── P-sub ── n+(NMOS S) ── GND

  等效 SCR（矽控整流器）：
       VDD
        │
    ┌─Q1(PNP)─┐     Q1: p+(PMOS) / N-well / P-sub
        │      │
       Rwell   │
        │      │
        │   ┌─Q2(NPN)─┐  Q2: N-well / P-sub / n+(NMOS)
        │   │      │
        │  Rsub    │
        │   │      │
        │   └──────┘
        │          │
       GND        GND
```

正回授：Q1 集極電流流過 Rsub → Q2 基極電壓升高 → Q2 導通 → Q2 集極電流流過 Rwell → Q1 基極電壓降低 → Q1 更導通 → ... → 鎖定（Latch）

結果：VDD 到 GND 形成低電阻通路 → 大電流 → 晶片燒毀！

(b) 觸發條件：
- **注入少數載子**：I/O pad 電壓超過 VDD 或低於 GND（ESD 事件、輸入過衝）
- **大電流擾動**：電源雜訊造成基板或 N-well 電位浮動
- **高溫**：BJT 增益 β 隨溫度增加
- **快速切換**：位移電流（Displacement Current）注入基板

觸發條件的量化：
β_pnp × β_npn × (Rsub + Rwell) × gm > 1
即寄生環路增益 > 1 時 Latch-up 被觸發。

(c) Guard Ring 工作原理：

```
  ┌─ p+ Guard Ring (接 GND) ─┐
  │                           │
  │  ┌─── NMOS ───┐          │
  │  │ n+  P-sub  n+ │       │
  │  └───────────────┘        │
  │                           │
  └───────────────────────────┘

  ┌─ n+ Guard Ring (接 VDD) ─┐
  │                           │
  │  ┌─── PMOS ───┐          │
  │  │ p+  N-well  p+ │      │
  │  └───────────────┘        │
  │                           │
  └───────────────────────────┘
```

原理：
- p+ Guard Ring 圍繞 NMOS：收集基板中的少數載子（電子），降低 Rsub
- n+ Guard Ring 圍繞 PMOS：固定 N-well 電位，降低 Rwell
- 降低 Rsub 和 Rwell → 環路增益 < 1 → 無法觸發 Latch-up

(d) 其他防治方法：
1. **增加 Well/Substrate Contact 密度**：每隔固定間距放置 Tap Cell
2. **使用 SOI（Silicon-on-Insulator）基板**：埋氧層完全隔離 → 無寄生 SCR
3. **Retrograde Well**：深層高摻雜降低 well 電阻
4. **EPI 基板（Epitaxial Substrate）**：薄的低摻雜磊晶層在高摻雜基板上 → 低 Rsub
5. **限制 I/O 電壓範圍**：ESD 保護電路箝位輸入電壓
6. **佈局規則（DRC）**：強制 N-well 到 NMOS 的最小間距

**答案**：Latch-up 因寄生 PNPN SCR 的正回授；Guard Ring 降低 Rsub/Rwell 使環路增益 < 1；SOI 基板可完全消除。

**延伸思考**：TSMC 的 DRC（Design Rule Check）中有專門的 Latch-up 規則，要求 well contact 密度與間距。面試常問「SOI 為何無 Latch-up？」——埋氧層切斷了寄生 BJT 的集極-基極路徑。

---
### 題目 37：佈局設計規則
**來源**：台大電機 / 經典題型
**難度**：★★★☆☆
**主題**：佈局規則（Design Rules）

**題目**：
(a) 說明 λ-based（Lambda-based）設計規則的概念與優點。
(b) 列出以下關鍵設計規則的典型值（以 λ 為單位）並解釋物理意義：
   - Minimum Metal Width
   - Minimum Metal Spacing
   - Contact/Via Size
   - Poly-to-Diffusion Overlap（Gate Extension）
   - Metal Enclosure of Via
(c) 在 180nm 製程中若 λ = 90nm，計算上述規則的實際尺寸。
(d) 為何先進節點放棄 λ-based 規則？

**詳解**：

**解題思路**：設計規則反映製程的物理限制，保證良率。

**步驟**：

(a) λ-based 設計規則：
- λ 定義為製程的最小特徵半尺寸（通常 = L_min/2）
- 所有佈局尺寸以 λ 的整數倍表示
- **優點**：
  - 製程獨立（Process-Independent）：同一佈局可用於不同製程
  - 簡化教學與初期設計
  - 容易縮放（Scaling）

(b) 典型設計規則：

| 規則 | 典型值 | 物理意義 |
|------|--------|---------|
| Min Metal Width | 3λ | 確保金屬線不斷裂（Electromigration、製程能力） |
| Min Metal Spacing | 3λ | 防止金屬短路（Lithography Resolution） |
| Contact/Via Size | 2λ × 2λ | 確保接觸面積足夠低電阻 |
| Poly-Diff Overlap | 2λ | Gate 延伸超出 Diffusion，防止邊緣漏電 |
| Metal Enclosure of Via | 1λ | 確保 Via 完全被金屬包覆（對準容差） |
| Min Diffusion Width | 3λ | 確保 Source/Drain 面積足夠 |
| Well Overlap of Diff | 3λ | 確保電晶體完全在 Well 內 |

(c) 180nm 製程（λ = 90nm）的實際尺寸：

| 規則 | λ值 | 實際尺寸 |
|------|-----|---------|
| Min Metal Width | 3λ | 270nm |
| Min Metal Spacing | 3λ | 270nm |
| Contact Size | 2λ × 2λ | 180nm × 180nm |
| Poly-Diff Overlap | 2λ | 180nm |
| Metal Enclosure | 1λ | 90nm |

(d) 先進節點放棄 λ-based 的原因：
1. **非等比縮放**：不同層的縮放比例不同（如 Metal Pitch 縮放慢於 Gate Length）
2. **複雜的 OPC/RET 規則**：光學鄰近修正需要非整數倍的精確規則
3. **多重圖案化（Multi-Patterning）**：SADP/SAQP 有特殊的色彩分配規則
4. **EUV 特有規則**：隨機缺陷（Stochastic Defect）需要特殊間距
5. **FinFET 量化**：Fin Pitch 是固定的，寬度只能是 Fin 數量的整數倍

現代製程使用精確的絕對尺寸（nm）規則，由 TSMC 提供的 Technology File 定義。

**答案**：λ-based 規則以 λ 為基本單位簡化設計；先進節點因非等比縮放與 Multi-Patterning 而改用絕對尺寸規則。

**延伸思考**：在 TSMC N3/N2 製程中，設計規則文件可達數千頁。佈局工程師需要深入理解每條規則背後的物理原因。DRC（Design Rule Check）使用 Synopsys IC Validator 或 Siemens Calibre 工具。

---
### 題目 38：寄生效應萃取
**來源**：業界面試 / 經典題型
**難度**：★★★☆☆
**主題**：寄生萃取（Parasitic Extraction, PEX）

**題目**：
(a) 解釋寄生萃取（PEX）在 IC 設計流程中的角色與位置。
(b) PEX 萃取哪些寄生元件？各自的物理來源為何？
(c) 比較 R-only、RC、RCC（含耦合電容）三種萃取模式。
(d) 一個 net 萃取出 R = 50Ω, C_gnd = 20fF, C_couple = 15fF，估算其對延遲的影響。

**詳解**：

**解題思路**：PEX 將佈局的物理結構轉為電路模型中的寄生 RCL 元件。

**步驟**：

(a) PEX 在設計流程中的位置：

```
RTL → Synthesis → P&R → DRC/LVS → PEX → STA/Simulation → Signoff
                                     ↑
                              Post-layout 驗證的關鍵
```

PEX 在佈局完成（Post-layout）後執行，將實際的金屬走線、Via、接觸等轉換為寄生 R、C、L 網路（SPEF 或 DSPF 格式），供後續的 STA 和 SPICE simulation 使用。

(b) 寄生元件與物理來源：

| 寄生元件 | 物理來源 |
|---------|---------|
| R（電阻） | 金屬線、Via、Contact 的有限電導率 |
| Cground（接地電容） | 金屬線對基板/接地面的平行板 + 邊緣電容 |
| Ccouple（耦合電容） | 相鄰金屬線間的側向電容 |
| L（電感） | 電流迴路面積（高頻/電源網路時重要） |
| Cgate（閘極電容） | 電晶體的 Gate 氧化層電容 |
| Cjunction（接面電容） | Source/Drain 到基板的 PN 接面電容 |

(c) 三種萃取模式比較：

| 模式 | 包含 | 精確度 | 檔案大小 | 適用場景 |
|------|------|--------|---------|---------|
| R-only | 僅電阻 | 低 | 小 | IR Drop 分析 |
| RC | R + Cground | 中 | 中 | 一般 STA |
| RCC（RC + Cc） | R + Cground + Ccouple | 高 | 大 | Signal Integrity / SI-aware STA |
| RCL | 含電感 | 最高 | 最大 | 高速 I/O、電源網路 |

(d) 延遲影響估算：
原始（無寄生）閘延遲假設 = 100ps
加上寄生效應：

考慮驅動電阻 Rd = 500Ω（驅動閘的等效電阻）：

延遲增加 = 0.69 × [Rd × (Cgnd + Ccouple) + R × (Cgnd + Ccouple)/2]
= 0.69 × [500 × 35fF + 50 × 35fF/2]
= 0.69 × [17500fF·Ω + 875fF·Ω]
= 0.69 × 18375 × 10⁻¹⁵ × 10³
= 0.69 × 18.375ps
= **12.7 ps 額外延遲**

相對原始 100ps 增加了 12.7% → 寄生效應顯著！

**答案**：PEX 萃取 R/C/Cc/L 寄生元件；RCC 模式最適合 SI-aware STA；寄生延遲可增加 10-30% 的閘延遲。

**延伸思考**：Synopsys StarRC 和 Siemens Calibre xRC 是業界主流 PEX 工具。在 TSMC N3 製程中，寄生電容主導延遲，RC 萃取精確度直接影響 timing signoff 品質。

---
### 題目 39：電遷移與可靠度
**來源**：業界面試 / 經典題型
**難度**：★★★☆☆
**主題**：電遷移（Electromigration, EM）

**題目**：
(a) 解釋電遷移現象的物理機制。
(b) Black's Equation：MTTF = A·J⁻ⁿ·exp(Ea/kT)，各參數意義為何？
(c) 一條金屬線寬 W = 0.2μm，厚 t = 0.3μm，最大允許電流密度 Jmax = 2 MA/cm²。計算最大直流電流。
(d) 為何 AC 電流的 EM 限制比 DC 寬鬆？

**詳解**：

**解題思路**：電遷移是金屬原子在電流作用下遷移的現象，導致斷路或短路。

**步驟**：

(a) 電遷移物理機制：

電子流（Electron Wind）碰撞金屬原子，將動量傳遞給原子：
- 在高電流密度處，電子「風力」推動金屬原子沿電子流方向遷移
- 原子離開處形成空洞（Void）→ 最終**斷路**（Open）
- 原子堆積處形成小丘（Hillock）→ 最終**短路**（Short）

主要遷移路徑：
- 晶粒邊界（Grain Boundary）擴散：低溫主導
- 表面（Surface/Interface）擴散：銅互連的主要機制
- 體擴散（Bulk Diffusion）：高溫主導

銅比鋁更耐 EM 的原因：銅的活化能更高（Ea_Cu ≈ 0.9eV vs Ea_Al ≈ 0.5eV）。

(b) Black's Equation 參數：

MTTF = A · J⁻ⁿ · exp(Ea / kT)

| 參數 | 意義 | 典型值 |
|------|------|--------|
| MTTF | 平均失效時間（Mean Time To Failure） | 要求 > 10 年 |
| A | 常數（與材料/幾何相關） | 製程相關 |
| J | 電流密度（A/cm²） | 設計變數 |
| n | 電流密度指數 | 1-2（銅通常 n ≈ 1-2） |
| Ea | 活化能（Activation Energy） | Cu: 0.7-1.0eV, Al: 0.5-0.7eV |
| k | Boltzmann 常數 | 8.617×10⁻⁵ eV/K |
| T | 絕對溫度 | 設計條件（如 105°C = 378K） |

(c) 最大直流電流：
截面積 A_cross = W × t = 0.2μm × 0.3μm = 0.06 μm² = 6×10⁻¹¹ cm²

Imax = Jmax × A_cross = 2×10⁶ A/cm² × 6×10⁻¹¹ cm²
= **120 μA = 0.12 mA**

這是很小的電流！寬度僅 0.2μm 的金屬線承載能力有限。

(d) AC 電流 EM 限制較寬鬆的原因：
- AC 電流的金屬原子遷移方向交替反轉
- 正半週遷移的空洞在負半週被「回填」
- 淨遷移接近零（Self-healing Effect）
- 一般規則：AC EM 限制 ≈ DC 的 2-10 倍（取決於波形的 duty cycle）

信號線（Signal Net）：近似 AC → 限制寬鬆
電源線（Power Net）：近似 DC → 限制嚴格 → 需更寬的金屬線

**答案**：EM 由電子風推動原子遷移；Imax = 120μA（W=0.2μm）；AC 因自修復效應限制較寬鬆。

**延伸思考**：EM 檢查是 TSMC signoff 的必要項目。Synopsys IC Compiler / Cadence Innovus 在電源網路設計時會自動檢查 EM 限制。面試常問「如何修復 EM violation？」——加寬金屬線或使用較高金屬層。

---
### 題目 40：天線效應
**來源**：台大電機 / 業界面試
**難度**：★★★☆☆
**主題**：天線效應（Antenna Effect）

**題目**：
(a) 解釋製程中天線效應的成因——為何長金屬線會損壞閘氧化層？
(b) 定義天線比（Antenna Ratio），典型的限制值為何？
(c) 列出三種常用的天線效應修復方法。
(d) EDA 工具如何自動處理天線效應？

**詳解**：

**解題思路**：天線效應發生在製程中（非運作中），因電漿蝕刻的電荷累積。

**步驟**：

(a) 天線效應成因：

在金屬蝕刻過程中使用電漿（Plasma）：
1. 電漿中的帶電粒子（離子）撞擊暴露的金屬表面
2. 金屬線收集電荷（像天線一樣）
3. 電荷通過金屬線流向連接的閘氧化層
4. 若金屬面積（天線）遠大於閘氧化層面積，累積電壓可能超過氧化層擊穿電壓
5. **閘氧化層被擊穿或退化** → 晶片失效

```
  ┌──────────────────────────────┐
  │      長金屬線（天線）         │ ← 電漿離子轟擊，收集電荷
  └──────────┬───────────────────┘
             │
         ┌───┴───┐
         │ Gate  │ ← 電荷灌入薄閘氧化層
         │ Oxide │    → 可能擊穿！
         └───────┘
```

關鍵：此問題發生在**製程中**，而非晶片運作時。

(b) 天線比（Antenna Ratio）：

AR = 金屬面積 / 閘氧化層面積

或更精確：AR = 累積金屬層面積 / 連接的閘面積

典型限制（TSMC 製程相關）：
- Metal 天線比限制：AR < 400-1000（依層而定）
- Via 天線比限制：較寬鬆
- 低層金屬（M1-M3）限制較嚴（先製作，閘極暴露時間長）

(c) 三種修復方法：

1. **跳線（Metal Hopping / Layer Change）**：
   將長金屬線在中間跳到更高層再跳回，打斷連續天線面積。

2. **插入天線二極體（Antenna Diode）**：
   在金屬線與閘極之間加入反偏二極體，提供電荷洩放路徑。

```
   Metal ──┬── Gate
           │
        [Diode] → 正常運作時反偏（不影響功能）
           │      製程中提供洩放路徑
          GND
```

3. **增大閘面積**：
   若可行，增加連接的閘氧化層面積以降低 AR。（通常不實用）

(d) EDA 工具處理：
1. **P&R 工具**（如 Cadence Innovus）在佈線後自動檢查天線比
2. 違規的 net 自動插入天線二極體或進行 layer hopping
3. **DRC 工具**（如 Calibre/IC Validator）檢查最終佈局的天線比
4. 標準元件庫中通常預留天線二極體的空間

流程：
Route → Antenna Check → Fix (Diode/Layer hop) → Re-check → Signoff

**答案**：天線效應因電漿蝕刻的電荷累積損壞閘氧化層；修復方法為跳線、插二極體、增加閘面積；EDA 工具自動檢測與修復。

**延伸思考**：在先進節點（如 TSMC N5/N3），閘氧化層極薄（< 2nm），天線效應更嚴重。FinFET 的 Fin 結構也引入了新的天線效應考量。面試常問天線效應與 ESD 保護的區別。

---

## Part 5：記憶體與算術電路（題目 41–50）

---
### 題目 41：6T SRAM 單元設計與分析
**來源**：台大電機 / TSMC 面試必考
**難度**：★★★★☆
**主題**：6T SRAM

**題目**：
考慮 6T SRAM 單元，各電晶體尺寸如下：
- Pull-down NMOS (PD)：W/L = 2/1（歸一化）
- Pass-gate NMOS (PG)：W/L = 1/1
- Pull-up PMOS (PU)：W/L = 1/1

VDD = 1.0V，Vtn = |Vtp| = 0.4V。

(a) 畫出 6T SRAM 電路圖，標注所有電晶體與節點。
(b) 分析讀取操作：當儲存 Q = 0, Q̄ = 1 時，讀取過程中 Q 節點的電壓上升到多少？
(c) 定義並計算讀取 SNM（Static Noise Margin）。
(d) 分析寫入操作：要成功寫入相反值，需要什麼條件？

**詳解**：

**解題思路**：SRAM 的讀取穩定性（Read Stability）與寫入能力（Writability）是核心設計挑戰。

**步驟**：

(a) 6T SRAM 電路：

```
             BL                    BL̄
              │                     │
          ┌─PG1─┐              ┌─PG2─┐
          │(WL) │              │(WL) │
          │     │              │     │
    VDD───PU1   │    VDD───PU2 │
          │     │              │     │
     Q ───┤─────┴──────────────┤───Q̄
          │                    │
    GND───PD1              GND───PD2
```

PD1, PD2：Pull-Down NMOS（交叉耦合反相器）
PU1, PU2：Pull-Up PMOS（交叉耦合反相器）
PG1, PG2：Pass-Gate NMOS（存取電晶體，WL 控制）

交叉耦合：Q 接 PD2/PU2 的閘極，Q̄ 接 PD1/PU1 的閘極。

(b) 讀取操作分析：

初始：Q = 0（PD1 ON, PU1 OFF），Q̄ = 1（PD2 OFF, PU2 ON）
預充：BL = BL̄ = VDD = 1.0V
啟動 WL = 1：PG1 和 PG2 導通

**Q 節點（儲存 0）的電壓上升**：
BL (= VDD) 通過 PG1 向 Q 節點灌電流，同時 PD1 試圖將 Q 拉到 GND。

穩態時 PG1 電流 = PD1 電流：

PG1（線性區，假設 VQ 小）：
I_PG1 = βPG [(VDD - Vtn)(VDD - VQ) - (VDD - VQ)²/2]
近似（VQ << VDD）：I_PG1 ≈ βPG(VDD - Vtn)VQ ... 不對

更精確：PG1 的 VGS = VDD（WL = VDD），VDS = VBL - VQ = VDD - VQ
PG1 飽和條件：VDS > VGS - Vtn → VDD - VQ > VDD - Vtn → VQ < Vtn

當 VQ < Vtn 時，PG1 飽和：
I_PG1 = (βPG/2)(VDD - Vtn)² = (1/2)(0.6)² = 0.18（歸一化）

PD1（線性區，VQ 小）：
I_PD1 = βPD[(VDD - Vtn)VQ - VQ²/2] ≈ βPD(VDD - Vtn)VQ = 2 × 0.6 × VQ = 1.2VQ

令 I_PG1 = I_PD1：
0.18 = 1.2 × VQ
**VQ = 0.15V**

(c) 讀取 SNM：
讀取 SNM 是指 Q 節點的電壓上升量（VQ = 0.15V）不足以翻轉交叉耦合反相器的閾值。

要保持穩定：VQ < VM（反相器開關閾值）

蝴蝶曲線法：在讀取條件下（PG ON），畫出兩個反相器的 VTC 並考慮 PG 效應。

**Cell Ratio (CR)** = βPD/βPG = (W/L)PD / (W/L)PG = 2/1 = 2

CR 越大 → PD1 越強 → VQ 越低 → 讀取 SNM 越高

典型設計要求：CR ≥ 1.5-2

近似 SNM（讀取）：
讀取 SNM ≈ VM - VQ（當 VQ 不翻轉反相器時）

若 VM ≈ 0.4V（由於 PG 的加載效應，有效 VM 下降）：
讀取 SNM ≈ 0.4 - 0.15 = **0.25V**

實際上需用蝴蝶曲線的最大內嵌正方形方法。

(d) 寫入操作分析：

要將 Q 從 0 寫為 1（BL = 1, BL̄ = 0）：
BL̄ = 0 通過 PG2 將 Q̄ 從 1 拉低。
PG2 需要勝過 PU2 將 Q̄ 拉低到使反相器翻轉。

**Pull-up Ratio (PR)** = βPU/βPG = (W/L)PU / (W/L)PG = 1/1 = 1

寫入條件：PG2 的拉低能力 > PU2 的拉高能力
即 βPG > βPU → PR < 1（在我們的設計中 PR = 1，邊界情況）

通常要求 PR ≤ 1.5 以確保可寫入。

**讀寫矛盾**：
- 讀穩定性要求 CR 大（PG 弱，PD 強）
- 寫入能力要求 PR 小（PG 強，PU 弱）
- 但 PG 不能同時又弱又強！

**解決：PD > PG > PU**（尺寸排序）

**答案**：讀取時 VQ ≈ 0.15V；CR = 2 提供足夠讀取穩定性；寫入需 PR ≤ 1.5；PD > PG > PU 解決讀寫矛盾。

**延伸思考**：SRAM 設計是 TSMC 製程開發的 benchmark。在先進節點，SRAM 使用 Assist 電路（Read Assist：降低 WL 電壓；Write Assist：降低 Cell VDD）來改善穩定性。面試必問「如何提高 SRAM 的 Read SNM？」

---
### 題目 42：SRAM 存取時間分析
**來源**：台大電機 / 經典題型
**難度**：★★★★☆
**主題**：SRAM 存取時間

**題目**：
一個 SRAM 陣列：256 行 × 256 列，位元線電容 CBL = 200fF（含所有 cell），字元線電容 CWL = 100fF，感測放大器（Sense Amplifier）需要 ΔV = 100mV 的差分信號才能正確讀取。Cell 中 PG NMOS 的等效電阻 Req_PG = 10kΩ，Cell 儲存電容 CS = 5fF。
(a) 計算位元線差分電壓隨時間的發展 ΔV(t)。
(b) 計算達到 ΔV = 100mV 所需的時間。
(c) 字元線延遲的估算（使用 Elmore Delay）。
(d) 總存取時間的估算。

**詳解**：

**解題思路**：位元線放電模型 + 字元線延遲 + 感測放大器延遲。

**步驟**：

(a) 位元線差分電壓：

預充 BL = BL̄ = VDD = 1.0V
WL 啟動後，儲存 Q = 0 的一側（假設 BL 側）：
Cell 試圖將 BL 放電（Q = 0 → BL 通過 PG 被 PD 拉低）

BL 電壓變化（電荷分享模型）：
ΔV_BL = (VDD - VQ) × CS / (CS + CBL)

忽略 VQ（假設 Cell 很快維持 Q ≈ 0）：
ΔV_BL ≈ VDD × CS / CBL（CS << CBL 時）
= 1.0 × 5fF / 200fF = **25 mV**（靜態最終值）

但實際上是 RC 過程：
τ = Req_PG × (CS × CBL)/(CS + CBL) ≈ Req_PG × CS（因 CS << CBL）
= 10kΩ × 5fF = 50ps

ΔV_BL(t) ≈ (VDD × CS/CBL) × (1 - e^(-t/τ'))

其中 τ' = Req_PG × CBL = 10kΩ × 200fF = 2ns

更精確地，BL 放電：
ΔV_BL(t) = VDD × (CS/(CS + CBL)) × (1 - e^(-t/(Req×(CS||CBL))))

但因 CS << CBL：
ΔV_BL(t) ≈ (VDD/CBL) × ∫₀ᵗ I_cell dt

簡化為一階 RC：
ΔV_BL(t) ≈ VDD × (CS/CBL) × (1 - e^(-t/τ'))
其中 τ' ≈ Req_PG × CBL = **2 ns**

(b) 達到 ΔV = 100mV 的時間：

需要 ΔV_BL = 100mV，但靜態最大值只有 25mV！

這意味著單純的電荷分享不夠——需要 Cell 的主動放電（PD 持續拉電流）。

改用電流模型：
I_cell = βPD/2 × (VDD - Vtn)² = (歸一化為 βPG 的 2 倍) ...

簡化：假設 Cell 持續提供恆流 I_cell：
ΔV_BL(t) = I_cell × t / CBL

I_cell ≈ VDD / (2 × Req_PG) = 1.0 / (2 × 10k) = 50μA

t = ΔV × CBL / I_cell = 0.1 × 200fF / 50μA
= 20 × 10⁻¹⁵ / 50 × 10⁻⁶
= **0.4 ns = 400 ps**

(c) 字元線延遲：
WL 的 RC 延遲（集總模型）：
假設 WL 驅動電阻 RWL_driver = 200Ω
WL 線電阻 RWL = 500Ω（256 cells 的 Poly WL）

τ_WL = 0.69 × (RWL_driver × CWL + RWL × CWL/2)
= 0.69 × (200 × 100fF + 500 × 50fF)
= 0.69 × (20ps + 25ps)
= **31 ps**

(d) 總存取時間：

| 階段 | 延遲 |
|------|------|
| 位址解碼（Address Decode） | ~200 ps |
| 字元線延遲 | 31 ps |
| 位元線發展（BL Development） | 400 ps |
| 感測放大器延遲（SA Delay） | ~100 ps |
| 輸出驅動 | ~100 ps |
| **總計** | **~831 ps** |

**答案**：BL 發展到 100mV 約需 400ps；WL 延遲約 31ps；總存取時間約 0.8-1ns。

**延伸思考**：SRAM 存取時間是 CPU 快取速度的決定因素。L1 Cache 要求 < 1ns 存取時間。TSMC 在每個節點優化 SRAM 的 BL/WL 延遲是核心 IP 開發工作。

---
### 題目 43：DRAM 1T1C 單元
**來源**：台大電機 / 經典題型
**難度**：★★★☆☆
**主題**：DRAM 設計

**題目**：
1T1C DRAM 單元：存取電晶體 NMOS，儲存電容 CS = 25fF，位元線電容 CBL = 200fF，VDD = 1.0V。
(a) 畫出 1T1C DRAM 電路，說明寫入「1」和「0」的操作。
(b) 計算讀取信號電壓 ΔV（讀取「1」與「0」時）。
(c) 為何 DRAM 需要刷新（Refresh）？典型刷新間隔為何？
(d) 比較 SRAM 與 DRAM 的面積、速度、功耗。

**詳解**：

**解題思路**：DRAM 使用電容儲存電荷，讀取為破壞性操作。

**步驟**：

(a) 1T1C DRAM 電路：

```
        BL
         │
     ┌─Access─┐
     │ NMOS   │
     │ (WL)   │
     └────┤
          │
         ═══ CS (Storage Capacitor)
          │
         GND (或 VDD/2 plate)
```

寫入「1」：BL = VDD, WL = VDD + Vtn（Boot電壓）→ CS 充電到 VDD
寫入「0」：BL = 0, WL = VDD + Vtn → CS 放電到 0

讀取：BL 預充至 VDD/2，WL ON → CS 與 CBL 電荷分享

(b) 讀取信號電壓：

預充 BL = VDD/2 = 0.5V

**讀取「1」**（CS 儲存 VDD = 1.0V）：
電荷守恆：CS × VDD + CBL × VDD/2 = (CS + CBL) × VBL_final
25f × 1.0 + 200f × 0.5 = 225f × VBL_final
25 + 100 = 225 × VBL_final
VBL_final = 125/225 = 0.556V

ΔV = VBL_final - VDD/2 = 0.556 - 0.5 = **+55.6 mV**

**讀取「0」**（CS 儲存 0V）：
25f × 0 + 200f × 0.5 = 225f × VBL_final
VBL_final = 100/225 = 0.444V

ΔV = 0.444 - 0.5 = **-55.6 mV**

信號很小（約 VDD/2 × CS/(CS + CBL) ≈ 56mV），需要高靈敏度的感測放大器。

**重要：讀取是破壞性的**——CS 的電壓被改變了，需要在讀取後回寫（Restore）。

(c) 刷新（Refresh）原因：

CS 上的電荷會因以下機制洩漏：
- 接面漏電流（Junction Leakage）
- 次臨界漏電（Subthreshold Leakage）
- GIDL（Gate-Induced Drain Leakage）
- 宇宙射線引起的軟錯誤（Soft Error）

電荷洩漏速率：dQ/dt = -Ileak
信號維持時間：t_retain = CS × ΔV_margin / Ileak

典型刷新間隔：**64 ms**（每 64ms 刷新所有行）

若有 8192 行：每 64ms/8192 ≈ 7.8μs 刷新一行
刷新功耗佔 DRAM 總功耗的 10-30%

(d) SRAM vs DRAM 比較：

| 特性 | SRAM (6T) | DRAM (1T1C) |
|------|-----------|-------------|
| 電晶體數/bit | 6 | 1 |
| 面積/bit | ~100-150 F² | ~6-8 F² |
| 速度 | 快（< 1ns） | 慢（~10ns） |
| 需要刷新 | 不需要 | 需要（64ms） |
| 功耗 | 低漏電 | 刷新功耗 |
| 用途 | Cache, Register File | 主記憶體 |
| 製程 | 邏輯製程 | 專用 DRAM 製程 |
| 密度 | 低 | 高 |

**答案**：讀取 ΔV ≈ ±56mV；需每 64ms 刷新；DRAM 面積比 SRAM 小 15-20 倍但較慢。

**延伸思考**：TSMC 不製造獨立 DRAM（由 Samsung/SK Hynix/Micron 主導），但在 SoC 中整合 eDRAM。面試常問 SRAM vs DRAM 的 trade-off。

---
### 題目 44：漣波進位加法器延遲分析
**來源**：台大電機 / 經典題型
**難度**：★★★☆☆
**主題**：Ripple Carry Adder (RCA)

**題目**：
設計一個 32 位元漣波進位加法器（RCA），每個全加器的延遲為：
- 進位產生延遲：tcarry = 100ps（Cin → Cout）
- 和產生延遲：tsum = 150ps（Cin → Sum）

(a) 計算 32-bit RCA 的最差情況關鍵路徑延遲。
(b) 計算最大工作頻率（假設 tcq = 100ps, tsetup = 80ps）。
(c) 比較鏡像全加器（Mirror Adder）的電晶體數量與延遲。
(d) 此 RCA 是否適合 1 GHz 操作？若不行，建議何種加法器架構？

**詳解**：

**解題思路**：RCA 的關鍵路徑是進位鏈的漣波傳播。

**步驟**：

(a) 關鍵路徑延遲：

進位從 LSB 漣波到 MSB：
- 第 0 位到第 30 位的進位傳播：31 × tcarry = 31 × 100 = 3100ps
- 最後一位的和產生：tsum = 150ps

**關鍵路徑 = 31 × 100 + 150 = 3250 ps = 3.25 ns**

更精確（考慮第 0 位的輸入延遲）：
若輸入 A, B 同時到達第 0 位：
第 0 位產生第一個 Cout 需要 tcarry = 100ps
然後漣波 31 級再加最後 tsum。

(b) 最大頻率：
Tclk ≥ tcq + t_critical + tsetup
= 100 + 3250 + 80 = **3430 ps**

fmax = 1/3.43ns = **291.5 MHz**

(c) 鏡像全加器（Mirror Full Adder）：

```
  鏡像全加器利用 NMOS/PMOS 的互補結構：

  Sum = A ⊕ B ⊕ Cin
  Cout = AB + BCin + ACin = AB + Cin(A+B) = AB + Cin(A⊕B)

  實現 Cout 的鏡像結構：
       VDD
        │
    ┌─PA(Ā)─┐  ┌─PB(Cin_bar)─PC(B̄)─┐
        │       │                     │
        └───────┴──── Cout ───────────┘
        ┌───────┬──── Cout ───────────┐
        │       │                     │
    ┌─NA(A)─┐  ┌─NB(Cin)──NC(B)─────┐
        │       │                     │
       GND     GND
```

電晶體數：
- Cout 部分：6 個電晶體（鏡像結構）
- Sum 部分：另外需要 6-8 個電晶體（XOR3 實現）
- 加上部分互補信號產生：2-4 個
- **總計約 28 個電晶體**

延遲特性：
- Carry 延遲：tcarry ≈ 2-3 個閘延遲（經過鏡像結構的關鍵路徑）
- 比用標準閘（NAND/XOR）實現的 FA 更快

(d) 1 GHz 可行性：
1 GHz → Tclk = 1000ps
需要 t_adder ≤ 1000 - 100 - 80 = 820ps

32-bit RCA 需要 3250ps >> 820ps → **完全不適合！**

建議架構：
1. **Carry Lookahead Adder (CLA)**：O(log N) 延遲
   - 4-bit CLA 單元，4 級 → 32-bit 約 4-5 × 200ps = 800-1000ps
2. **Carry Select Adder**：將 32-bit 分成多個塊，預計算
3. **Kogge-Stone / Brent-Kung 並行前綴加法器**：最快，O(log₂ N) 級
   - 32-bit：5 級 × 100ps = 500ps ✓

**答案**：32-bit RCA 延遲 3.25ns，fmax = 291.5 MHz，不適合 1 GHz；需使用 CLA 或 Parallel-Prefix Adder。

**延伸思考**：加法器是 ALU 的核心。在高性能處理器中，64-bit 加法器通常用 Kogge-Stone（速度優先）或 Brent-Kung（面積優先）實現。TSMC 標準元件庫提供各種位寬的加法器 IP。

---
### 題目 45：先行進位加法器（CLA）
**來源**：台大電機 / 經典題型
**難度**：★★★★☆
**主題**：Carry Lookahead Adder

**題目**：
設計 4-bit CLA 加法器：
(a) 定義 Generate (G) 和 Propagate (P) 信號，推導 C1, C2, C3, C4 的展開式。
(b) 計算 4-bit CLA 的關鍵路徑延遲（假設 AND/OR 閘延遲 = 50ps，XOR = 80ps）。
(c) 以 4-bit CLA 為基本單元，構建 16-bit CLA 加法器（兩級架構），計算延遲。
(d) 比較 16-bit RCA vs 16-bit CLA 的延遲與面積。

**詳解**：

**解題思路**：CLA 的核心是將進位鏈的序列計算轉為並行計算。

**步驟**：

(a) G 和 P 定義與進位展開：

Gi = Ai · Bi（Generate：第 i 位本身產生進位）
Pi = Ai ⊕ Bi（Propagate：第 i 位傳播進位）

進位遞迴：Ci+1 = Gi + Pi · Ci

展開：
C1 = G0 + P0·C0
C2 = G1 + P1·C1 = G1 + P1·G0 + P1·P0·C0
C3 = G2 + P2·C2 = G2 + P2·G1 + P2·P1·G0 + P2·P1·P0·C0
C4 = G3 + P3·G2 + P3·P2·G1 + P3·P2·P1·G0 + P3·P2·P1·P0·C0

**關鍵觀察**：每個 Ci 都直接從 G0...Gi-1, P0...Pi-1, C0 計算，無需等待前一級進位！

(b) 4-bit CLA 延遲：

Level 1：計算所有 Gi, Pi（並行）
- Gi = AND(Ai, Bi)：t_AND = 50ps
- Pi = XOR(Ai, Bi)：t_XOR = 80ps
- → 80ps（取較慢的 XOR）

Level 2：計算所有 Ci（CLA 邏輯）
- C1 需要：1 級 AND + 1 級 OR = 50 + 50 = 100ps
- C4 需要：最多 4 輸入 AND + 5 輸入 OR
  用兩級邏輯：AND (50ps) + OR (50ps) = 100ps
- → 100ps

Level 3：計算所有 Si = Pi ⊕ Ci
- XOR：80ps

**總延遲 = 80 + 100 + 80 = 260ps**

比較：4-bit RCA = 3 × 100 + 150 = 450ps
CLA 快 42%！

(c) 16-bit CLA（兩級架構）：

第一級：4 個 4-bit CLA 單元
第二級：利用群組 G* 和 P* 的 CLA 邏輯產生各塊的進位

群組 Generate/Propagate：
G*[0:3] = G3 + P3·G2 + P3·P2·G1 + P3·P2·P1·G0
P*[0:3] = P3·P2·P1·P0

延遲分析：
1. 計算所有 Gi, Pi：80ps
2. 第一級 CLA 計算 G*, P*：100ps
3. 第二級 CLA 計算塊間進位 C4, C8, C12：100ps
4. 塊內用已知進位計算 sum：第一級 CLA 的 Level 2-3 = 100 + 80 = 180ps

等等，需要更仔細：
1. Gi, Pi：80ps
2. 第一級塊內 G*, P* 和第一塊的所有 Ci：100ps（並行）
3. 第二級 CLA：用 G*, P* 計算 C4, C8, C12：100ps
4. 各塊利用塊間進位計算內部 Ci：100ps（塊內 CLA Level 2）
5. 計算 Si：80ps

**總延遲 = 80 + 100 + 100 + 100 + 80 = 460ps**

(d) 比較：

| 架構 | 16-bit 延遲 | 電晶體數（估計） |
|------|-----------|----------------|
| RCA | 15×100 + 150 = 1650ps | 16 × 28 = 448 |
| 2-level CLA | 460ps | ~600-700 |

**CLA 快 3.6 倍，但面積增加約 50%。**

**答案**：4-bit CLA 延遲 260ps（vs RCA 450ps）；16-bit 兩級 CLA 延遲 460ps（vs RCA 1650ps），加速 3.6 倍。

**延伸思考**：在實際 ASIC 設計中，Synopsys DesignWare 提供各種最佳化的加法器 IP，會根據 timing constraint 自動選擇最適合的架構。

---
### 題目 46：並行前綴加法器——Kogge-Stone vs Brent-Kung
**來源**：台大電機 / 經典題型
**難度**：★★★★★
**主題**：並行前綴加法器（Parallel-Prefix Adder）

**題目**：
(a) 定義前綴運算子（Prefix Operator）● 及其結合律。
(b) 畫出 8-bit Kogge-Stone 加法器的前綴計算圖（PG Tree）。
(c) 畫出 8-bit Brent-Kung 加法器的前綴計算圖。
(d) 比較 Kogge-Stone 與 Brent-Kung 的級數、節點數（面積）、扇出。

**詳解**：

**解題思路**：並行前綴加法器將進位計算轉化為前綴運算的並行化問題。

**步驟**：

(a) 前綴運算子定義：

(G, P) = (Gi:j, Pi:j) 代表第 i 到 j 位的群組 Generate 和 Propagate。

前綴運算子 ●：
(Gi:k, Pi:k) = (Gi:j, Pi:j) ● (Gj-1:k, Pj-1:k)
= (Gi:j + Pi:j · Gj-1:k, Pi:j · Pj-1:k)

**結合律**：(A ● B) ● C = A ● (B ● C)
結合律使得可以用不同的計算順序（樹結構）來計算前綴。

目標：計算所有 (Gi:0, Pi:0) 就能得到所有進位 Ci+1 = Gi:0 + Pi:0 · C0。

(b) 8-bit Kogge-Stone 前綴圖：

```
Level 0:  [7] [6] [5] [4] [3] [2] [1] [0]   ← 初始 (Gi, Pi)
           │   │   │   │   │   │   │   │
Level 1:  7:6 6:5 5:4 4:3 3:2 2:1 1:0  │    ← 跨度 1
           │   │   │   │   │   │   │   │
Level 2:  7:4 6:3 5:2 4:1 3:0 2:0* │   │    ← 跨度 2
           │   │   │   │   │   │   │   │
Level 3:  7:0 6:0 5:0 4:0 │   │   │   │    ← 跨度 4
```

特性：
- **log₂(8) = 3 級**（最少級數）
- 每級有 N-1 個運算節點
- 總節點數 = N·log₂(N) - N + 1 = 8×3 - 7 = **17 個**
- 最大扇出 = 2

(c) 8-bit Brent-Kung 前綴圖：

```
Level 0:   [7] [6] [5] [4] [3] [2] [1] [0]
            │   │   │   │   │   │   │   │
Level 1:   7:6  │  5:4  │  3:2  │  1:0  │     ← 偶數位計算
            │   │   │   │   │   │   │   │
Level 2:   7:4  │   │   │  3:0  │   │   │     ← 跨度 4
            │   │   │   │   │   │   │   │
Level 3:   7:0  │   │   │   │   │   │   │     ← 跨度 8
            │   │   │   │   │   │   │   │
Level 4:    │  6:0  │  4:0  │  2:0  │   │     ← 逆向展開
            │   │   │   │   │   │   │   │
Level 5:    │   │  5:0  │   │   │   │   │     ← 逆向展開
```

特性：
- **2·log₂(8) - 1 = 5 級**（較多級數）
- 總節點數 = 2N - 2 - log₂(N) = 16 - 2 - 3 = **11 個**
- 較少的佈線交叉

(d) 比較：

| 特性 | Kogge-Stone | Brent-Kung |
|------|------------|------------|
| 級數（Depth） | log₂N = 3 | 2log₂N - 1 = 5 |
| 節點數（Area） | N·log₂N - N+1 = 17 | 2N - 2 - log₂N = 11 |
| 最大扇出 | 2 | log₂N = 3 |
| 佈線複雜度 | 高（大量交叉） | 低 |
| 速度 | **最快** | 中等 |
| 面積 | **最大** | **最小** |

**Kogge-Stone**：速度優先（用於高性能處理器 ALU）
**Brent-Kung**：面積優先（用於面積受限設計）
**混合型**（如 Han-Carlson）：介於兩者之間

32-bit 比較：
- Kogge-Stone：5 級，~130 節點
- Brent-Kung：9 級，~57 節點

**答案**：Kogge-Stone 最快（log₂N 級）但面積最大；Brent-Kung 面積最小（2N-2 節點）但較慢（2log₂N-1 級）。

**延伸思考**：在實際 CPU 設計中，Intel/AMD 的 ALU 加法器通常使用 Kogge-Stone 或其變體。TSMC 標準元件庫的 DesignWare 加法器 IP 可根據 timing/area constraint 自動選擇最佳架構。

---
### 題目 47：乘法器——Booth 編碼與 Wallace Tree
**來源**：台大電機 / 經典題型
**難度**：★★★★☆
**主題**：乘法器設計

**題目**：
設計一個 8×8 位元乘法器：
(a) 解釋 Radix-4 Modified Booth Encoding 如何將部分積（Partial Product）數量減半。
(b) 對乘數 B = 10110110₂ 進行 Modified Booth Encoding。
(c) 畫出 Wallace Tree 壓縮器的結構（4 個部分積的情況）。
(d) 比較 Array Multiplier、Wallace Tree、Booth-Wallace 的延遲與面積。

**詳解**：

**解題思路**：Booth 編碼減少部分積數量，Wallace Tree 加速部分積的加法。

**步驟**：

(a) Radix-4 Modified Booth Encoding：

標準乘法：8-bit × 8-bit 產生 8 個部分積（每位乘數一個）
Modified Booth：每 2 位一組，產生 4 個部分積（減半！）

編碼規則（考慮 3 位：bi+1, bi, bi-1）：

| bi+1 | bi | bi-1 | 編碼值 | 操作 |
|------|-----|------|--------|------|
| 0 | 0 | 0 | 0 | +0 |
| 0 | 0 | 1 | +1 | +A |
| 0 | 1 | 0 | +1 | +A |
| 0 | 1 | 1 | +2 | +2A |
| 1 | 0 | 0 | -2 | -2A |
| 1 | 0 | 1 | -1 | -A |
| 1 | 1 | 0 | -1 | -A |
| 1 | 1 | 1 | 0 | +0 |

操作只需：0, ±A, ±2A（2A 只是左移一位）

(b) B = 10110110₂ 的 Booth 編碼：

補 b₋₁ = 0：
B = 1 0 1 1 0 1 1 0 (0)
     ↑       ↑       ↑
分組（從 LSB 開始，每 2 位一組）：

| 組 | bi+1 bi bi-1 | 值 |
|------|-----------|-----|
| 0 | 1 1 0 (0) → 1,1,0 | -1 → **-A** |
| 1 | 0 1 (1) 1 → 0,1,1 | +2 → **+2A** |
| 2 | 1 0 (0) → 1,0,1 | -1 → **-A** |
| 3 | (0) 1 (1) → 1,0,1... |  |

重新分組（正確方式，從 b₋₁ = 0 開始）：
位置：b7 b6 b5 b4 b3 b2 b1 b0 | b₋₁
      1   0   1   1   0   1   1   0  |  0

組 0：(b1, b0, b₋₁) = (1, 0, 0) → -2 → **-2A**
組 1：(b3, b2, b1) = (0, 1, 1) → +2 → **+2A**
組 2：(b5, b4, b3) = (1, 1, 0) → -1 → **-A** (左移 4)
組 3：(b7, b6, b5) = (1, 0, 1) → -1 → **-A** (左移 6)

驗證：-2 + 2×4 - 16 - 64 = -2 + 8 - 16 - 64 = -74
B = 10110110 = -128 + 32 + 16 + 4 + 2 = -74 ✓（補數表示）

4 個部分積（vs 原本 8 個），減半！

(c) Wallace Tree 壓縮（4 個部分積）：

使用 3:2 壓縮器（Full Adder）和 2:2 壓縮器（Half Adder）：

```
Level 0:  PP0  PP1  PP2  PP3     ← 4 個部分積
Level 1:  [3:2 CSA] → S1, C1    ← PP0+PP1+PP2 壓縮為 2 行
          + PP3                   ← 剩餘 1 行
          共 3 行 →
Level 2:  [3:2 CSA] → S2, C2    ← 3 行壓縮為 2 行
Level 3:  [CPA] → Final Sum      ← 2 行用快速加法器相加
```

Wallace Tree 的壓縮級數 = ⌈log₃/₂(N)⌉
4 個部分積：⌈log₁.₅(4)⌉ = ⌈3.41⌉ = 4 → 但實際只需 2 級 CSA + 1 級 CPA

(d) 比較（8×8 乘法器）：

| 架構 | 延遲 | 面積 | 規律性 |
|------|------|------|--------|
| Array Multiplier | O(N) ~16 級 FA | O(N²) | 高（適合 layout） |
| Wallace Tree | O(log N) CSA + O(log N) CPA ≈ 8 級 | O(N²) | 低（佈線亂） |
| Booth-Wallace | O(log N/2) CSA + CPA ≈ 6 級 | O(N²/2) | 中 |

Booth-Wallace 結合兩者優勢：最快且部分積最少。

**答案**：Booth 編碼將 8 個部分積減為 4 個；Wallace Tree 用 CSA 在 O(log N) 級壓縮；Booth-Wallace 是高性能乘法器的首選。

**延伸思考**：乘法器在 DSP 和 GPU 中是核心運算單元。TSMC 的 ARM 核心中使用高度最佳化的 Booth-Wallace 乘法器，延遲僅 1-2 個時脈週期。

---
### 題目 48：桶形移位器設計
**來源**：台大電機 / 經典題型
**難度**：★★★☆☆
**主題**：Barrel Shifter

**題目**：
設計一個 8-bit 桶形移位器（Barrel Shifter），支援左移 0-7 位。
(a) 畫出基於 MUX 的 Barrel Shifter 架構。
(b) 計算所需的 MUX 級數與每級的 MUX 類型。
(c) 計算總延遲（假設 2:1 MUX 延遲 = 60ps）。
(d) 比較 Barrel Shifter vs 逐位移位的延遲。

**詳解**：

**解題思路**：Barrel Shifter 用 log₂(N) 級 MUX 實現任意位數的移位。

**步驟**：

(a) 8-bit Barrel Shifter 架構：

移位量 S = S₂S₁S₀（3 位元控制 0-7 移位）

分解為三級：
- Level 0 (S₀)：移位 0 或 1 位
- Level 1 (S₁)：移位 0 或 2 位
- Level 2 (S₂)：移位 0 或 4 位

```
  Input:  D7  D6  D5  D4  D3  D2  D1  D0

  Level 0 (S₀ = shift by 1?):
  每個輸出位 = 2:1 MUX(S₀, Dᵢ, Dᵢ₋₁)

  Level 1 (S₁ = shift by 2?):
  每個輸出位 = 2:1 MUX(S₁, 前級ᵢ, 前級ᵢ₋₂)

  Level 2 (S₂ = shift by 4?):
  每個輸出位 = 2:1 MUX(S₂, 前級ᵢ, 前級ᵢ₋₄)

  Output: Y7  Y6  Y5  Y4  Y3  Y2  Y1  Y0
```

例如：S = 011（左移 3 位）
Level 0 (S₀=1)：移位 1
Level 1 (S₁=1)：再移位 2
Level 2 (S₂=0)：不移位
→ 總移位 = 1 + 2 = 3 ✓

(b) MUX 級數與類型：

級數 = log₂(N) = log₂(8) = **3 級**

每級需要 N 個 2:1 MUX（每個輸出位一個）
- Level 0：8 個 2:1 MUX
- Level 1：8 個 2:1 MUX
- Level 2：8 個 2:1 MUX

**總計 24 個 2:1 MUX**

每個 2:1 MUX 用 TG 實現需 6 個電晶體：
總電晶體 = 24 × 6 = **144 個**

(c) 總延遲：
3 級 MUX 串聯：
t_barrel = 3 × t_MUX = 3 × 60ps = **180 ps**

對於 N-bit Barrel Shifter：
t = log₂(N) × t_MUX

(d) 比較逐位移位：

逐位移位器（Sequential Shifter）：
- 每次只移 1 位，需 k 個時脈週期移 k 位
- 最差情況（移 7 位）：7 個週期
- 每週期延遲 = 60ps（一級 MUX）
- 最差延遲 = 7 × 60ps = 420ps

| 方式 | 延遲（最差） | 面積 |
|------|-----------|------|
| Barrel Shifter | 180ps（固定） | 144 FET |
| 逐位移位 | 420ps（可變） | 48 FET |
| 比較 | **2.3x 快** | **3x 大** |

Barrel Shifter 是經典的速度換面積（Time-Area Tradeoff）。

**答案**：8-bit Barrel Shifter 需 3 級 × 8 個 2:1 MUX = 24 MUX；延遲 180ps（固定，不隨移位量變化）；比逐位移位快 2.3 倍。

**延伸思考**：Barrel Shifter 在 CPU 的 ALU 中廣泛使用，支援 shift/rotate 指令。64-bit 處理器需要 6 級 Barrel Shifter。在 FPGA 中，Barrel Shifter 用 LUT 實現。

---
### 題目 49：ROM 與 Flash 記憶體基礎
**來源**：台大電機 / 經典題型
**難度**：★★★☆☆
**主題**：ROM / Flash

**題目**：
(a) 畫出 NOR-based ROM 的陣列結構（4×4），解釋如何儲存資料。
(b) 比較 NOR Flash 與 NAND Flash 的架構差異。
(c) 解釋 Flash 的浮閘（Floating Gate）寫入機制：FN Tunneling 與 CHE Injection。
(d) Flash 的耐久度（Endurance）與資料保持（Retention）限制。

**詳解**：

**解題思路**：ROM/Flash 基於 MOS 電晶體的閾值電壓控制儲存資訊。

**步驟**：

(a) NOR-based ROM（4×4）：

```
          BL0    BL1    BL2    BL3
           │      │      │      │
  WL0 ──┬─┤──┬───┤──────┤──┬───┤
         │ N  │   N      │  │   N     儲存: 1 0 1 1 → 1011
         │ │  │   │      │  │   │
  WL1 ──┤─┤──┼───┤──┬───┤──┤───┤
         │ │  │   │  N   │  │   │     儲存: 0 0 1 0 → 0010
         │ │  │   │  │   │  │   │
  WL2 ──┤─┤──┬───┤──┤───┬──┤───┤
         │ │  N   │  │   N  │   │     儲存: 0 1 0 1 → 0101
         │ │  │   │  │   │  │   │
  WL3 ──┬─┤──┤───┤──┬───┤──┬───┤
         N │  │   │  N   │  N   │     儲存: 1 0 1 1 → 1011
         │ │  │   │  │   │  │   │
        GND  GND  GND  GND
```

- 有電晶體（N）的位置 = 儲存「0」（WL 啟動時 BL 被拉低）
- 無電晶體的位置 = 儲存「1」（BL 維持高）
- ROM 的內容在製程中（Mask）決定，不可更改

(b) NOR Flash vs NAND Flash：

| 特性 | NOR Flash | NAND Flash |
|------|----------|-----------|
| 單元連接 | 並聯（如 NOR 閘） | 串聯（如 NAND 閘） |
| 隨機存取 | 是（可直接定址） | 否（需序列存取） |
| 讀取速度 | 快（~100ns） | 慢（~25μs 頁讀取） |
| 寫入速度 | 慢（~1ms/word） | 快（~200μs/page） |
| 密度 | 低（每 cell 面積大） | 高（串聯共享接觸） |
| 用途 | 程式碼儲存（XIP） | 資料儲存（SSD） |
| 單元面積 | ~10 F² | ~4-5 F² |

(c) Flash 寫入機制：

**FN Tunneling（Fowler-Nordheim Tunneling）**：
- 在閘極施加高電壓（~20V）
- 電子穿隧通過薄氧化層進入浮閘
- 用於 NAND Flash 的寫入與 NOR Flash 的擦除
- 速度較慢但功耗低

**CHE Injection（Channel Hot Electron）**：
- 在 Drain 施加高電壓，Channel 中電子獲得高能量
- 熱電子躍過氧化層能障進入浮閘
- 用於 NOR Flash 的寫入
- 速度快但功耗高，且需逐位元寫入

浮閘中累積電荷 → Vth 增加 → 讀取時判斷 Vth 高低代表 0 或 1。

(d) 耐久度與保持限制：

**耐久度（Endurance）**：
- 每次寫入/擦除都對氧化層造成微小損傷（陷阱態 Trap）
- SLC（Single Level Cell）：~10⁵ 次
- MLC（Multi Level Cell）：~10⁴ 次
- TLC/QLC：~10³ 次
- 損壞機制：Stress-Induced Leakage Current (SILC)

**資料保持（Retention）**：
- 浮閘電荷隨時間洩漏
- 規格：通常 > 10 年（在室溫）
- 高溫加速洩漏
- 多次 P/E 循環後保持時間縮短

**答案**：NOR ROM 用有/無電晶體代表 0/1；NOR Flash 適合隨機讀取，NAND Flash 適合高密度資料儲存；寫入機制為 FN Tunneling 和 CHE。

**延伸思考**：3D NAND Flash（如 Samsung V-NAND）透過垂直堆疊 100+ 層來提高密度。TSMC 本身不製造 Flash，但在 SoC 中整合 eFlash IP（來自 eMemory 等公司）。

---
### 題目 50：全加器設計比較
**來源**：台大電機 / 經典題型
**難度**：★★★☆☆
**主題**：全加器（Full Adder）電路比較

**題目**：
比較三種全加器電路實現：
(a) 標準 CMOS 全加器（Static CMOS，28 電晶體）
(b) 鏡像全加器（Mirror Adder，28 電晶體）
(c) 傳輸閘全加器（TG Full Adder，16 電晶體）

對每種設計：
- 畫出 Cout 的電路實現
- 計算 Cin → Cout 的關鍵路徑延遲（以閘延遲 τ 為單位）
- 分析驅動能力與 Rail-to-Rail 特性

**詳解**：

**解題思路**：全加器是加法器的基本單元，其設計影響整體性能。

**步驟**：

全加器邏輯：
Sum = A ⊕ B ⊕ Cin
Cout = A·B + Cin·(A ⊕ B) = Majority(A, B, Cin)

(a) 標準 CMOS 全加器：

使用互補 CMOS 實現 Cout：
F = A·B + B·Cin + A·Cin

NMOS 下拉網路（實現 AB + BCin + ACin）：
```
  Cout
   │
   ├──NA──NB──┐
   │          │
   ├──NB'──NCin─┤ → GND
   │          │
   └──NA'──NCin'─┘
```
（3 條並聯路徑，每條 2 個串聯 NMOS = 6 NMOS）
PMOS 上拉為其對偶（6 PMOS）

Cout 部分：12 個電晶體
Sum 部分：另外需要 XOR3 = 16 個電晶體
總計 = **28 個電晶體**

Cin → Cout 延遲：2 級（串聯 NMOS/PMOS）= **2τ**

(b) 鏡像全加器（Mirror Adder）：

利用 Cout 和 Cout̄ 的對稱性：
Cout = A·B + Cin·(A+B)（可直接實現不需 XOR）
Cout̄ = Ā·B̄ + Cin̄·(Ā+B̄)（鏡像結構）

```
        VDD
         │
    ┌──PA(Ā)──┐
    │         │
    ├──PB(B̄)──┤  ┌──PCin(Cin̄)──┐
    │         │  │              │
    │         └──┤              │
    │            │     ┌──PB'(B̄)─┤
    │            │     │         │
    │            └─────┘         │
    │                            │
    ├──────────── Cout ──────────┤
    │                            │
    ├──NA(A)──┐                  │
    │         │                  │
    ├──NB(B)──┤  ┌──NCin(Cin)───┤
    │         │  │              │
    │         └──┤              │
    │            │     ┌──NB'(B)─┤
    │            └─────┘         │
    │                            │
        GND
```

鏡像全加器的 Cout 部分只需 **10 個電晶體**（利用分享中間節點）

Cin → Cout 延遲：**1-2τ**（Cin 只經過一個電晶體到 Cout）

鏡像結構的優勢：Cin 路徑最短（放在最靠近輸出的位置）。

(c) 傳輸閘全加器（TG Full Adder）：

利用 XOR 特性：
XOR1 = A ⊕ B（用 TG 實現）
Cout = XOR1 · Cin + XOR1̄ · A（MUX 結構）
     = Cin when A≠B，A when A=B

```
  A ⊕ B ──┤TG├── Cin ──┐
                         ├── Cout
  A ⊕ B̄ ──┤TG├── A  ──┘
```

Sum = XOR1 ⊕ Cin（另一個 TG XOR）

電晶體數：
- XOR1（A⊕B）：4 TG FET + 2 INV = 6
- Cout MUX：4 TG FET = 4
- Sum：4 TG FET + 2 INV = 6
- **總計 16 個電晶體**（比 CMOS 少 43%！）

Cin → Cout 延遲：**1τ**（只經過一個 TG）

缺點：TG 是被動元件，無再生性。多級串聯時信號衰減。

比較總結：

| 特性 | Standard CMOS | Mirror | TG FA |
|------|-------------|--------|-------|
| 電晶體數 | 28 | 28 | **16** |
| Cin→Cout 延遲 | 2τ | 1.5τ | **1τ** |
| Rail-to-Rail | 是 | 是 | 弱（需 buffer） |
| 驅動能力 | 強 | 強 | 弱 |
| 適合長鏈 | 是 | **最佳** | 需插 buffer |

**答案**：TG FA 電晶體最少（16 個）且 Cin→Cout 最快（1τ）；Mirror Adder 是 RCA 鏈的最佳選擇（好的驅動力+快速進位路徑）；TG FA 需注意信號衰減。

**延伸思考**：在 ASIC 標準元件庫中，全加器有多種變體針對不同需求（速度/面積/功耗）。TSMC 元件庫通常提供 ADDF（Full Adder）和 ADDH（Half Adder）等單元。

---

## Part 6：低功耗與先進設計（題目 51–60）

---
### 題目 51：電壓縮放與功耗分析
**來源**：台大電機 / TSMC 面試必考
**難度**：★★★★☆
**主題**：電壓縮放（Voltage Scaling）

**題目**：
一個處理器核心在 VDD = 1.0V 時的規格：f = 2 GHz，Pdyn = 10W，Pleak = 2W。Vth = 0.3V。
(a) 若降壓至 VDD = 0.7V，計算新的最大頻率（假設延遲 ∝ VDD/(VDD - Vth)²）。
(b) 計算降壓後的動態功率。
(c) 計算降壓後的漏電功率（假設 DIBL 效應使 Vth 隨 VDD 線性變化：ΔVth/ΔVDD = 0.1）。
(d) 計算能量效率的改善（Energy per operation）。

**詳解**：

**解題思路**：電壓縮放是低功耗設計最有效的手段，但速度會下降。

**步驟**：

(a) 新的最大頻率：

延遲模型（Alpha-Power 法）：
td ∝ CL · VDD / I ∝ VDD / (VDD - Vth)^α

使用 α = 2（方塊定律近似）：
td ∝ VDD / (VDD - Vth)²

頻率 f ∝ 1/td ∝ (VDD - Vth)² / VDD

f(0.7) / f(1.0) = [(0.7 - 0.3)² / 0.7] / [(1.0 - 0.3)² / 1.0]
= [0.16 / 0.7] / [0.49 / 1.0]
= 0.2286 / 0.49
= **0.4665**

f(0.7) = 2 GHz × 0.4665 = **0.933 GHz**

頻率降低 53.4%。

(b) 動態功率：
Pdyn = α · CL · VDD² · f（CL 和 α 不變）

Pdyn(0.7) / Pdyn(1.0) = (VDD_new/VDD_old)² × (f_new/f_old)
= (0.7/1.0)² × 0.4665
= 0.49 × 0.4665
= 0.2286

Pdyn(0.7) = 10W × 0.2286 = **2.286W**

動態功率降低 77.1%！

(c) 漏電功率：
Vth(0.7V) = Vth(1.0V) - 0.1 × (1.0 - 0.7) = 0.3 - 0.03 = 0.27V

漏電流 ∝ e^(-Vth/(n·VT))，VT = kT/q ≈ 26mV（室溫）

Ileak(0.7) / Ileak(1.0) = e^(-(0.27 - 0.30)/(1.3 × 0.026))
= e^(0.03/0.0338)
= e^0.888 = 2.43

但 VDD 降低也降低漏電功率：
Pleak(0.7) / Pleak(1.0) = (VDD_new/VDD_old) × (Ileak_new/Ileak_old)
= (0.7/1.0) × 2.43
= 1.70

Pleak(0.7) = 2W × 1.70 = **3.40W**（漏電反而增加！）

原因：雖然 VDD 降低，但 DIBL 效應使 Vth 也降低 → 漏電流大增。

(d) 能量效率：

每次運算能量 E = P / f

E(1.0) = (10 + 2) / (2 × 10⁹) = 6.0 × 10⁻⁹ J = **6.0 nJ/op**
E(0.7) = (2.286 + 3.40) / (0.933 × 10⁹) = 6.09 × 10⁻⁹ J = **6.09 nJ/op**

能量效率幾乎沒有改善！因為漏電功率在低 VDD 時佔比大增。

若不考慮漏電：
E_dyn(1.0) = 10 / 2G = 5.0 nJ/op
E_dyn(0.7) = 2.286 / 0.933G = 2.45 nJ/op → **改善 51%**

**結論**：電壓縮放在先進節點的效果受漏電限制。

**答案**：降壓至 0.7V：f 降至 0.93GHz，Pdyn 降 77%，但 Pleak 增 70%；整體能量效率因漏電而未顯著改善。

**延伸思考**：這就是為何先進節點需要 Multi-Vth + Power Gating 配合 Voltage Scaling。TSMC 提供 HVT/SVT/LVT/ULVT 等多種閾值電壓的元件庫。面試必問「為何不能無限降壓？」

---
### 題目 52：多閾值電壓設計（Multi-Vth）
**來源**：TSMC 面試 / 低功耗設計
**難度**：★★★★☆
**主題**：Multi-Vth 設計

**題目**：
一個設計使用 TSMC 製程提供的三種閾值電壓元件：
- HVT（High Vth = 0.45V）：Ileak = 1nA/μm，延遲 = 1.5τ
- SVT（Standard Vth = 0.35V）：Ileak = 10nA/μm，延遲 = 1.0τ
- LVT（Low Vth = 0.25V）：Ileak = 100nA/μm，延遲 = 0.7τ

設計有 10,000 個邏輯閘，時序約束 Tclk = 1 ns。

(a) 若全用 SVT，計算總漏電流。
(b) 若全用 HVT，是否滿足時序？
(c) 設計最佳 Multi-Vth 分配策略（關鍵路徑用 LVT，其餘用 HVT），計算漏電改善。
(d) EDA 工具如何自動進行 Multi-Vth Optimization？

**詳解**：

**解題思路**：在不影響性能的前提下，盡量使用高 Vth 元件減少漏電。

**步驟**：

(a) 全 SVT 漏電：
假設平均元件寬度 = 1μm：
Ileak_total = 10,000 × 10nA = **100 μA**
Pleak = Ileak × VDD = 100μA × 0.9V = **90 μW**

(b) 全 HVT 時序檢查：
假設關鍵路徑有 20 級邏輯閘（典型數位設計）：
t_critical = 20 × 1.5τ

設 τ = 50ps（SVT 的單位延遲，使得 20 × 1.0τ = 1000ps = Tclk）
全 HVT：t_critical = 20 × 1.5 × 50 = **1500 ps > 1000 ps**

**不滿足時序！** 超過約束 500ps。

(c) Multi-Vth 最佳化策略：

策略：
1. 關鍵路徑（Critical Path）上的閘使用 LVT
2. 近關鍵路徑（Near-Critical）使用 SVT
3. 非關鍵路徑使用 HVT

假設分配：
- 關鍵路徑 20 級用 LVT：t = 20 × 0.7τ = 20 × 35ps = **700ps < 1000ps** ✓
- 餘裕：1000 - 700 = 300ps（可以混合使用）

更最佳化：僅在必要位置使用 LVT
假設 20 級中，10 級用 LVT（0.7τ），10 級用 SVT（1.0τ）：
t = 10 × 35 + 10 × 50 = 350 + 500 = **850ps < 1000ps** ✓

整體分配（典型比例）：
- LVT：5%（500 閘）→ 關鍵路徑
- SVT：15%（1500 閘）→ 近關鍵路徑
- HVT：80%（8000 閘）→ 非關鍵路徑

漏電計算：
Ileak = 500 × 100nA + 1500 × 10nA + 8000 × 1nA
= 50,000 + 15,000 + 8,000
= 73,000 nA = **73 μA**

比較全 SVT 的 100μA：改善 **27%**

若更激進（LVT 僅 2%，HVT 90%）：
Ileak = 200 × 100 + 800 × 10 + 9000 × 1
= 20,000 + 8,000 + 9,000 = 37,000 nA = **37 μA**

改善 **63%！**

(d) EDA 自動化：
Synopsys Design Compiler / IC Compiler 的 Multi-Vth Optimization 流程：

1. **初始映射（Initial Mapping）**：全部使用 SVT
2. **Timing Analysis**：識別關鍵路徑與正 slack 路徑
3. **Vth Swap Down**：關鍵路徑上的閘 → LVT（加速）
4. **Vth Swap Up**：有大正 slack 的閘 → HVT（省漏電）
5. **迭代最佳化**：反覆 swap 直到 timing 恰好滿足且漏電最小

工具命令（Synopsys DC）：
`set_leakage_optimization true`
`set_multi_vth_constraint ...`

**答案**：Multi-Vth 策略可將漏電降低 27-63%；關鍵路徑用 LVT，非關鍵用 HVT；EDA 工具自動進行 Vth Swap 最佳化。

**延伸思考**：TSMC 在每個節點提供 4-5 種 Vth 選擇。在 N3/N2 節點，漏電控制是設計的首要挑戰。面試常問「HVT 和 LVT 的 Vth 差多少？如何選擇？」

---
### 題目 53：電源閘控（Power Gating）
**來源**：MTK 面試 / 低功耗設計
**難度**：★★★★☆
**主題**：Power Gating

**題目**：
(a) 畫出 Header Switch（PMOS Power Gating）和 Footer Switch（NMOS Power Gating）的電路。
(b) 說明 Power Gating 的開啟/關閉序列（Power-up/Power-down Sequence）。
(c) 設計考量：Sleep Transistor 的尺寸、Virtual VDD 的壓降、Rush Current 問題。
(d) Retention Flip-Flop 的作用。

**詳解**：

**解題思路**：Power Gating 在休眠時切斷電源，消除漏電。

**步驟**：

(a) Header 與 Footer Switch：

**Header Switch（PMOS）**：
```
  VDD
   │
  ┌┴┐ PMOS (Sleep̄ control)
  └┬┘
   │
  VVDD (Virtual VDD)
   │
  [Logic Block]
   │
  GND
```

**Footer Switch（NMOS）**：
```
  VDD
   │
  [Logic Block]
   │
  VGND (Virtual GND)
   │
  ┌┴┐ NMOS (Sleep control)
  └┬┘
   │
  GND
```

Header 用 PMOS（Sleep̄ = 0 關閉，1 導通）
Footer 用 NMOS（Sleep = 1 關閉，0 導通）

Footer Switch 較常用，因為 NMOS 驅動力較強（面積較小）。

(b) Power-up/Power-down 序列：

**Power-down（進入休眠）**：
1. 停止時脈（Clock Gating OFF）
2. 將重要狀態存入 Retention FF（或外部記憶體）
3. 隔離輸出（Isolation Cells 啟動）→ 防止浮接信號影響 always-on 區域
4. 關閉 Sleep Transistor（斷電）

**Power-up（喚醒）**：
1. 開啟 Sleep Transistor（上電），使用分段（Daisy-chain）逐步開啟以限制 Rush Current
2. 等待 VVDD 穩定（需時 ~100ns-1μs）
3. 解除隔離
4. 從 Retention FF 恢復狀態
5. 恢復時脈

```
時序圖：
  Sleep     ═══╗         ╔═══
  Isolate   ═══╗       ╔═╝
  Retain    ═══╗     ╔═╝
  CLK_EN    ═══╗   ╔═╝
               ║   ║
            Power Power
            Down   Up
```

順序很重要！錯誤的順序會導致邏輯錯誤或電源雜訊。

(c) 設計考量：

**Sleep Transistor 尺寸**：
- 太小：VVDD 壓降太大（IR drop across sleep FET）
- 太大：面積浪費、漏電增加
- 設計準則：VVDD drop < 10% VDD（通常 < 50-100mV）
- 所需寬度：W_sleep = I_peak / (μCox(VDD-|Vtp|) × ΔV_allowed/VDD)

**Virtual VDD 壓降**：
I_active × Ron(sleep) < ΔV_max
Ron = VDD / (I_on × W_total)

**Rush Current（衝擊電流）**：
- 上電瞬間，所有節點電容需充電 → 大電流尖峰
- 可能造成 IR Drop 影響 Always-on 區域
- 解決：分段開啟（Staggered Wake-up），每次只開一部分 Sleep Transistor

(d) Retention Flip-Flop：

```
  ┌─────────────────────────┐
  │    Standard FF          │
  │   ┌─────┐              │
D─┤MUX├─D FF├──Q           │
  │   └──┬──┘              │    Always-on 供電
  │      │   ┌──────┐      │    ┌──────────┐
  │      └───┤Shadow├──────┤────┤ Retention │
  │   SAVE→  │Latch │ RESTORE  │ Storage   │
  │          └──────┘      │    └──────────┘
  └─────────────────────────┘
```

- 正常運作：Standard FF 工作
- Power-down 前：SAVE 信號將 FF 值存入 Shadow Latch（Always-on 電源）
- Power-up 後：RESTORE 信號將值從 Shadow Latch 恢復到 FF

Retention FF 面積約為標準 FF 的 1.5-2 倍。

**答案**：Power Gating 用 Sleep Transistor 切斷電源消除漏電；需正確的 Power-up/down 序列；Retention FF 保存狀態；Rush Current 需分段開啟控制。

**延伸思考**：Power Gating 在手機 SoC 中廣泛使用（CPU 核心、GPU、DSP 各自獨立 Power Domain）。TSMC 提供 Power Gating 的標準元件（Sleep Cell、Isolation Cell、Retention FF）。面試常問完整的 Power-up Sequence。

---
### 題目 54：DVFS 動態電壓頻率調節
**來源**：MTK 面試 / 業界面試
**難度**：★★★★☆
**主題**：DVFS（Dynamic Voltage and Frequency Scaling）

**題目**：
一個行動處理器支援以下 DVFS 操作點（OPP, Operating Performance Point）：

| OPP | VDD | Frequency | Pdyn | Pleak |
|-----|-----|-----------|------|-------|
| Turbo | 1.1V | 3.0GHz | 15W | 3W |
| Normal | 0.9V | 2.0GHz | 5.4W | 2W |
| Low | 0.7V | 1.0GHz | 1.6W | 1.5W |
| ULP | 0.55V | 0.3GHz | 0.2W | 1.0W |

(a) 驗證各 OPP 的 Pdyn 是否符合 Pdyn ∝ VDD²·f 的關係。
(b) 計算各 OPP 的能量效率（Energy per operation = P/f）。
(c) 一個工作負載需要在 1 秒內完成 10⁹ 次運算。比較使用 Turbo 跑完後休眠 vs 使用 Normal 全程運行的總能耗。
(d) 何時選擇 Race-to-Sleep 策略？何時選擇持續低頻策略？

**詳解**：

**解題思路**：DVFS 的核心是在性能與功耗間動態切換。

**步驟**：

(a) 驗證 Pdyn ∝ VDD²·f：

以 Normal 為基準：Pdyn_norm = k × 0.9² × 2G = k × 1.62G
k = 5.4W / 1.62G = 3.33 × 10⁻⁹

Turbo：k × 1.1² × 3G = 3.33e-9 × 1.21 × 3G = 3.33e-9 × 3.63G = 12.1W
實際 15W → 偏高（因為高壓高頻下短路功率也增加）

Low：k × 0.7² × 1G = 3.33e-9 × 0.49G = 1.63W ≈ 1.6W ✓
ULP：k × 0.55² × 0.3G = 3.33e-9 × 0.3025 × 0.3G = 0.302W ≈ 0.2W
偏高（ULP 下 Vth drop 效應使實際電流更低）

大致符合 VDD²·f 關係，偏差來自二階效應。

(b) 能量效率（每次運算能量）：
E_op = (Pdyn + Pleak) / f

| OPP | E_op |
|-----|------|
| Turbo | (15+3)/3G = **6.0 nJ/op** |
| Normal | (5.4+2)/2G = **3.7 nJ/op** |
| Low | (1.6+1.5)/1G = **3.1 nJ/op** |
| ULP | (0.2+1.0)/0.3G = **4.0 nJ/op** |

**Low OPP 能量效率最佳！**
ULP 反而更差（因漏電佔比太高）。

(c) Race-to-Sleep vs Continuous：

**方案 A：Turbo + Sleep**
運算時間 = 10⁹ / 3×10⁹ = 0.333 s
休眠時間 = 1 - 0.333 = 0.667 s
能耗 = (15+3) × 0.333 + Psleep × 0.667
假設 Psleep = 0.1W（Power Gating 後）：
= 6.0 + 0.067 = **6.07 J**

**方案 B：Normal 全程**
運算時間 = 10⁹ / 2×10⁹ = 0.5 s
剩餘 0.5s 可 idle 或 sleep：
能耗 = (5.4+2) × 0.5 + 0.1 × 0.5 = 3.7 + 0.05 = **3.75 J**

**方案 C：Low 全程**
運算時間 = 10⁹ / 1×10⁹ = 1.0 s
能耗 = (1.6+1.5) × 1.0 = **3.1 J** ← 最佳！

**方案 D：ULP**
運算時間 = 10⁹ / 0.3×10⁹ = 3.33 s > 1s → **無法在 deadline 內完成！**

(d) Race-to-Sleep vs 持續低頻：

**Race-to-Sleep 較佳的情況**：
- Power Gating 能有效降低 Psleep（接近 0）
- 高漏電環境（漏電佔總功耗比例大）
- 需要快速響應的間歇性工作負載

**持續低頻較佳的情況**：
- Power Gating 開銷大（wake-up 時間長、Rush Current 大）
- 漏電比例不高
- 工作負載持續且可預測
- 最佳 VDD 接近 EDP 最小化的 VDD（~3Vth）

**答案**：Low OPP 能量效率最佳（3.1 nJ/op）；在此場景中持續低頻策略最省能（3.1J vs 6.07J）；Race-to-Sleep 在高漏電環境較佳。

**延伸思考**：DVFS 是所有手機 SoC（Apple A 系列、Qualcomm Snapdragon、MTK Dimensity）的核心電源管理技術。Linux 的 CPUFreq governor 實現了不同的 DVFS 策略。面試常問「如何選擇 OPP？」

---
### 題目 55：體偏壓技術（Body Biasing）
**來源**：台大電機 / 業界面試
**難度**：★★★★☆
**主題**：Body Biasing

**題目**：
(a) 解釋 Forward Body Biasing (FBB) 與 Reverse Body Biasing (RBB) 的原理。
(b) 使用體效應公式 Vth = Vth0 + γ(√(2|φF| + |VSB|) - √(2|φF|))，計算 NMOS 的 Vth 變化：
   Vth0 = 0.4V，γ = 0.5V^(1/2)，|2φF| = 0.6V。分別計算 VSB = -0.3V（FBB）和 VSB = +0.5V（RBB）時的 Vth。
(c) FBB/RBB 對性能和漏電的影響。
(d) 為何 FinFET 的 Body Biasing 效果較弱？

**詳解**：

**解題思路**：透過調整基體電壓改變 Vth，動態調節性能與漏電。

**步驟**：

(a) FBB 與 RBB 原理：

**Forward Body Biasing (FBB)**：
- NMOS：VBS > 0（Body 電壓高於 Source）
- 效果：Vth 降低 → 電流增加 → **速度提升**，但漏電增加
- 使用場景：性能不足時暫時加速

**Reverse Body Biasing (RBB)**：
- NMOS：VBS < 0（Body 電壓低於 Source）
- 效果：Vth 升高 → 電流減少 → **漏電降低**，但速度下降
- 使用場景：休眠或低性能需求時降低漏電

```
  FBB: VB > VS     RBB: VB < VS
  ┌───────┐        ┌───────┐
  │ Vth↓  │        │ Vth↑  │
  │ Fast  │        │ Slow  │
  │ Leaky │        │ Low   │
  └───────┘        │ Leak  │
                   └───────┘
```

(b) Vth 計算：

體效應公式：Vth = Vth0 + γ(√(|2φF| + |VSB|) - √(|2φF|))

注意：對 NMOS，VSB = VS - VB，FBB 時 VB > VS → VSB < 0

**FBB（VSB = -0.3V）**：
此時 |VSB| 為負，意味著空乏區變窄。
修正公式（FBB 情況，|2φF + VSB| < |2φF|）：
Vth = Vth0 + γ(√(0.6 + (-0.3)) - √(0.6))
= 0.4 + 0.5(√0.3 - √0.6)
= 0.4 + 0.5(0.5477 - 0.7746)
= 0.4 + 0.5(-0.2269)
= 0.4 - 0.1135
= **0.287V**

Vth 降低了 113mV！

**RBB（VSB = +0.5V）**：
Vth = Vth0 + γ(√(0.6 + 0.5) - √(0.6))
= 0.4 + 0.5(√1.1 - √0.6)
= 0.4 + 0.5(1.0488 - 0.7746)
= 0.4 + 0.5(0.2742)
= 0.4 + 0.1371
= **0.537V**

Vth 升高了 137mV！

(c) FBB/RBB 對性能與漏電的影響：

| 項目 | FBB (Vth=0.287V) | Nominal (Vth=0.4V) | RBB (Vth=0.537V) |
|------|-----------------|-------------------|-----------------|
| 相對速度 | ~1.3× | 1.0× | ~0.7× |
| 相對漏電 | ~50× | 1.0× | ~0.02× |
| 用途 | 性能加速 | 正常 | 休眠省電 |

漏電變化（∝ exp(-Vth/nVT)）：
FBB: exp(-(0.287-0.4)/0.034) = exp(3.32) ≈ 27.7× 增加
RBB: exp(-(0.537-0.4)/0.034) = exp(-4.03) ≈ 0.018× → 降低 55 倍

(d) FinFET 的 Body Biasing 限制：

FinFET 的 Fin 結構非常薄（< 10nm）→ 通道完全空乏（Fully Depleted）：
- 基體對通道的電場控制很弱（Gate 包覆 Fin 三面，主導通道控制）
- Body Biasing 的 Vth 調整效果大幅減弱（γ_FinFET << γ_Bulk）
- 典型 FinFET 的 body bias 效果只有 Bulk CMOS 的 1/5-1/10

替代方案：
- Back-Gate Biasing（FDSOI 技術效果好）
- Adaptive Voltage Scaling 取代 Body Biasing
- TSMC FinFET 主要依靠 Multi-Vth 而非 Body Biasing

**答案**：FBB 使 Vth 從 0.4V 降至 0.287V（加速 30%，漏電增 28×）；RBB 使 Vth 升至 0.537V（漏電降 55×）；FinFET 因全空乏結構，body bias 效果微弱。

**延伸思考**：Body Biasing 在 Bulk CMOS 時代（≥ 28nm）非常有效，但在 FinFET 時代（≤ 16nm）效果有限。GlobalFoundries 的 FDSOI 技術保留了優異的 body bias 特性，這是 FDSOI vs FinFET 的重要差異。

---
### 題目 56：製程-電壓-溫度（PVT）變異
**來源**：台大電機 / TSMC 面試
**難度**：★★★★☆
**主題**：PVT Variation

**題目**：
(a) 解釋 PVT 三種變異來源及其對電路延遲的影響方向。
(b) 定義 Corner 分析中的 FF/TT/SS/FS/SF 五個角落（Corner），各代表什麼？
(c) 一個閘的 TT corner 延遲為 100ps，FF corner 延遲 80ps，SS corner 延遲 130ps。溫度係數 0.1%/°C，電壓係數 -15%/(0.1V change)。計算在最差情況（SS, 125°C, VDD-10%）下的延遲。
(d) 為何先進節點越來越關注「局部變異」（Local Variation / Mismatch）？

**詳解**：

**解題思路**：PVT 是電路設計必須考慮的三大變異來源。

**步驟**：

(a) PVT 變異來源與影響：

**Process（製程變異）**：
- Vth、Tox、W/L 的製造偏差
- 全域（Die-to-die）+ 局部（Within-die）
- Vth 升高 → 延遲增加，Vth 降低 → 延遲減少但漏電增加

**Voltage（電壓變異）**：
- 電源供應的波動（IR Drop、L·di/dt）
- VDD 降低 → 驅動電流減少 → **延遲增加**
- VDD 升高 → 速度加快但功耗增加

**Temperature（溫度變異）**：
- 正常溫度效應（> ~100nm）：溫度升高 → 遷移率降低 → **延遲增加**
- 反轉溫度效應（先進節點 < 28nm）：溫度升高 → Vth 降低 → 可能**延遲減少**
  （當 Vth 降低的補償效應大於遷移率降低時發生）

(b) Corner 定義：

| Corner | NMOS | PMOS | 特性 |
|--------|------|------|------|
| FF | Fast | Fast | 最快速度，最高漏電 |
| TT | Typical | Typical | 標稱值 |
| SS | Slow | Slow | 最慢速度，最低漏電 |
| FS | Fast | Slow | NMOS 快 PMOS 慢 → 影響上升時間 |
| SF | Slow | Fast | NMOS 慢 PMOS 快 → 影響下降時間 |

**Setup Timing**：用 SS corner（最慢，確保最差情況仍滿足）
**Hold Timing**：用 FF corner（最快，確保最快路徑不違反 hold）
**功耗分析**：用 FF corner（最高漏電）

(c) 最差情況延遲計算：

基準：SS corner = 130ps（25°C, nominal VDD）

溫度影響（25°C → 125°C，ΔT = 100°C）：
延遲增加 = 0.1% × 100 = 10%
t_temp = 130 × 1.10 = 143ps

電壓影響（VDD → VDD - 10%）：
VDD 降低 10% = 0.1V（假設 VDD = 1.0V）
延遲增加 = 15%
t_voltage = 143 × 1.15 = 164.5ps

**最差情況延遲 ≈ 165ps**（比 TT/25°C/Nominal 的 100ps 增加 65%！）

這就是為何 STA 必須考慮 PVT corner！

(d) 局部變異（Local Variation）的重要性：

全域變異（Global）：同一晶片上所有元件同方向偏移
局部變異（Local / Mismatch）：相鄰元件之間的隨機差異

先進節點局部變異加劇的原因：
1. **隨機摻雜波動（Random Dopant Fluctuation, RDF）**：
   通道中原子級的摻雜不均勻，影響 Vth
   σ(Vth) ∝ 1/√(W·L)，元件越小 → 變異越大
2. **線邊粗糙度（Line Edge Roughness, LER）**：
   光刻邊緣的隨機波動影響 W
3. **金屬顆粒度（Metal Grain Variation）**：
   影響互連電阻

在 SRAM 設計中，局部變異直接影響 SNM：
6σ Vth mismatch 必須小於 SNM → 這限制了 SRAM 的最小尺寸

**答案**：SS/125°C/VDD-10% 最差延遲 ≈ 165ps（比 TT 增加 65%）；先進節點因 RDF 和 LER 使局部變異成為主要挑戰。

**延伸思考**：TSMC 的 PVT 分析使用 SPICE corner 模型（基於 Monte Carlo 統計）。Synopsys PrimeTime 支援 Multi-corner Multi-mode (MCMM) 分析，同時檢查多個 PVT corner。

---
### 題目 57：靜態時序分析（STA）
**來源**：台大電機 / TSMC 面試
**難度**：★★★★☆
**主題**：靜態時序分析（Static Timing Analysis）

**題目**：
(a) 比較 STA 與動態時序模擬（Dynamic Timing Simulation）的差異與各自優缺點。
(b) 解釋 STA 中的以下概念：Arrival Time、Required Time、Slack、Critical Path。
(c) 給定以下電路的延遲資訊，計算各節點的 Arrival Time 和 Slack，找出 Critical Path：

```
         ┌─ [A: 2ns] ─┐
  IN ────┤             ├── [D: 1ns] ── OUT
         └─ [B: 3ns] ──┤
                        │
         ┌─ [C: 1ns] ──┘
  IN2 ───┘
```

要求：Tclk = 5ns，tcq = 0.5ns，tsetup = 0.3ns
(d) 如何修復 Timing Violation？列出常用方法。

**詳解**：

**解題思路**：STA 是數位設計 Signoff 的核心驗證方法。

**步驟**：

(a) STA vs 動態時序模擬：

| 特性 | STA | 動態模擬 |
|------|-----|---------|
| 速度 | 快（分鐘級） | 慢（小時-天） |
| 覆蓋率 | 完整（所有路徑） | 依賴測試向量 |
| 精確度 | 保守（取最差） | 精確（考慮信號活動） |
| 需要向量 | 不需要 | 需要輸入激勵 |
| 找 Bug | 能找 timing bug | 能找功能 + timing bug |
| 工具 | PrimeTime, Tempus | VCS, Xcelium |

**STA 優勢**：窮盡所有路徑，不遺漏
**STA 劣勢**：可能過度保守（False Path、Multi-cycle Path 需額外約束）

(b) STA 基本概念：

**Arrival Time (AT)**：信號實際到達某節點的時間
- AT = tcq + 路徑上所有閘延遲之和

**Required Time (RT)**：信號必須在此時間前到達（由時序約束決定）
- RT = Tclk - tsetup（對終點 FF）

**Slack**：時序餘裕
- Slack = RT - AT
- Slack ≥ 0：滿足時序 ✓
- Slack < 0：違反時序（Violation）✗

**Critical Path**：Slack 最小（最負或最小正值）的路徑

(c) 計算 AT 和 Slack：

Required Time at OUT：
RT(OUT) = Tclk - tsetup = 5 - 0.3 = **4.7 ns**

Arrival Time 計算（前向傳播）：
AT(IN) = tcq = 0.5 ns
AT(IN2) = tcq = 0.5 ns

路徑 1：IN → A → D → OUT
AT₁ = 0.5 + 2 + 1 = **3.5 ns**

路徑 2：IN → B → D → OUT
AT₂ = 0.5 + 3 + 1 = **4.5 ns**

路徑 3：IN2 → C → D → OUT
AT₃ = 0.5 + 1 + 1 = **2.5 ns**

D 的輸入 AT = max(AT_A, AT_B, AT_C) = max(2.5, 3.5, 1.5) = 3.5 ns
（注意：AT_A = 0.5+2 = 2.5, AT_B = 0.5+3 = 3.5, AT_C = 0.5+1 = 1.5）

AT(OUT) = max(3.5, 4.5, 2.5) = **4.5 ns**

Slack：
Slack(path 1) = 4.7 - 3.5 = **1.2 ns** ✓
Slack(path 2) = 4.7 - 4.5 = **0.2 ns** ✓（最小，關鍵路徑）
Slack(path 3) = 4.7 - 2.5 = **2.2 ns** ✓

**Critical Path = IN → B → D → OUT**（Slack = 0.2ns）

(d) 修復 Timing Violation 的方法：

1. **Gate Sizing**：將關鍵路徑上的閘替換為更大驅動力的版本（如 X2→X4）
2. **Vth Swap**：關鍵路徑上使用 LVT 元件（更快但更漏電）
3. **Buffer Insertion**：在長線上插入 buffer 減少互連延遲
4. **Logic Restructuring**：重新分解邏輯以縮短關鍵路徑
5. **Register Retiming**：移動管線暫存器位置以平衡路徑延遲
6. **Useful Skew**：調整時脈樹借時間給關鍵路徑
7. **降低負載**：減少扇出或佈線電容

**答案**：Critical Path = IN→B→D→OUT，Slack = 0.2ns；STA 能窮盡分析所有路徑；修復方法包括 Gate Sizing、Vth Swap、Buffer Insertion 等。

**延伸思考**：STA 是 TSMC design signoff 的必要步驟。Synopsys PrimeTime 支援 MCMM（Multi-Corner Multi-Mode）分析，一次檢查所有 PVT corner 下的所有功能模式。面試常問 STA 中的 False Path 和 Multi-Cycle Path 概念。

---
### 題目 58：良率分析
**來源**：台大電機 / TSMC 面試
**難度**：★★★☆☆
**主題**：良率（Yield）

**題目**：
(a) 使用 Murphy's Model 計算良率：Y = [(1 - e^(-AD₀)) / (AD₀)]²，其中 A = 晶粒面積，D₀ = 缺陷密度。晶粒面積 A = 100 mm²，D₀ = 0.5 defects/cm²。
(b) 若將晶粒面積減半（A = 50 mm²），良率變化多少？
(c) 一片 300mm 晶圓可以切出多少個 A = 100mm² 的晶粒（考慮邊緣損失）？良品數為何？
(d) 說明冗餘（Redundancy）在記憶體良率中的作用。

**詳解**：

**解題思路**：良率與晶粒面積和缺陷密度的關係，是 IC 經濟學的核心。

**步驟**：

(a) 良率計算：

A = 100 mm² = 1.0 cm²
D₀ = 0.5 /cm²
AD₀ = 1.0 × 0.5 = 0.5

Murphy's Model：
Y = [(1 - e^(-0.5)) / 0.5]²
= [(1 - 0.6065) / 0.5]²
= [0.3935 / 0.5]²
= [0.787]²
= **0.619 = 61.9%**

也可用 Poisson Model 比較：
Y_Poisson = e^(-AD₀) = e^(-0.5) = 0.607 = 60.7%

Murphy 模型比 Poisson 略樂觀（考慮缺陷聚集效應）。

(b) 面積減半（A = 50mm²）：
AD₀ = 0.5 × 0.5 = 0.25

Y = [(1 - e^(-0.25)) / 0.25]²
= [(1 - 0.7788) / 0.25]²
= [0.2212 / 0.25]²
= [0.885]²
= **0.783 = 78.3%**

良率從 61.9% 提升到 78.3%，**改善 16.4 個百分點！**

這就是為何晶粒面積對成本影響巨大——小晶粒不僅每片晶圓切更多，良率也更高。

(c) 晶圓上的晶粒數量：

300mm 晶圓面積 = π × (150mm)² = 70,686 mm²

簡單估算（不考慮邊緣）：
N_gross = 70,686 / 100 = 706 個

考慮邊緣損失（經驗公式）：
N = π × D²/(4A) - π × D/√(2A)
= π × 300²/(4×100) - π × 300/√200
= 70,686/400 - 942.5/14.14
= 706.86 - 66.7
= **640 個**

良品數 = N × Y = 640 × 0.619 = **396 個良品**

(d) 冗餘在記憶體良率中的作用：

記憶體（如 SRAM/DRAM）中加入備用行（Row）和列（Column）：

```
  ┌──────────────────────────────┐
  │  正常陣列                     │
  │  1024 rows × 1024 cols       │
  │  + 8 備用 rows                │
  │  + 8 備用 cols                │
  │                              │
  │  Fuse/Anti-fuse 可程式化      │
  │  切換有缺陷的行/列到備用行/列  │
  └──────────────────────────────┘
```

冗餘修復（Redundancy Repair）流程：
1. 晶圓測試識別有缺陷的行/列
2. 使用雷射燒斷 fuse（或電子 anti-fuse）將缺陷行/列替換為備用
3. 重新測試確認修復成功

效果：
- 無冗餘良率：Y₀ = 50%（假設）
- 加入 8 備用行列後：Y_repair = 90%+
- 良率提升非常顯著！

冗餘分析（統計模型）：
若每行缺陷機率 p，有 R 個備用行：
只要缺陷行數 ≤ R 即可修復
Y = Σₖ₌₀ᴿ C(N,k) × p^k × (1-p)^(N-k)

**答案**：100mm² 晶粒良率 ≈ 62%；面積減半良率升至 78%；640 晶粒中約 396 良品；冗餘可將記憶體良率從 50% 提升到 90%+。

**延伸思考**：良率是 TSMC 的核心商業指標。新製程 ramp-up 期間的良率爬升（Yield Learning）直接影響成本。面試常問「如何估算 IC 成本？」→ 成本 ∝ 晶圓成本/(N × Y)。

---
### 題目 59：先進節點設計挑戰——FinFET 與 GAAFET
**來源**：台大電機 / TSMC 面試
**難度**：★★★★★
**主題**：先進節點設計

**題目**：
(a) 比較 Planar MOSFET、FinFET 與 GAAFET（Gate-All-Around FET）的結構差異與優缺點。
(b) FinFET 設計中的量化效應（Quantization）：為何寬度只能是 Fin 數量的整數倍？
(c) 列出 5nm 以下節點的三個主要設計挑戰。
(d) BSPDN（Backside Power Delivery Network）如何改善先進節點的電源完整性？

**詳解**：

**解題思路**：先進節點的物理限制驅動新的元件結構與設計方法。

**步驟**：

(a) 結構比較：

**Planar MOSFET**（≥ 28nm）：
```
        Gate
    ┌───────────┐
    │  Oxide    │
  ──┴───────────┴── Channel (平面)
    Substrate
```
- 閘極只從頂部控制通道
- 短通道效應嚴重（≤ 22nm 難以控制）

**FinFET**（22nm ~ 3nm）：
```
      ┌─Gate─┐
      │      │
    ┌─┴──────┴─┐
    │   Fin    │  ← Fin 高度 ~40-50nm，寬度 ~5-7nm
    │          │
    └──────────┘
    Substrate
```
- 閘極從三面包覆 Fin（Tri-gate）
- 優異的靜電控制 → DIBL 大幅降低
- 缺點：寬度量化（只能是 nFin × WFin）

**GAAFET / Nanosheet**（≤ 3nm）：
```
    ═══ Gate ═══
    ║ Nanosheet ║
    ═══ Gate ═══
    ║ Nanosheet ║
    ═══ Gate ═══
    ║ Nanosheet ║
    ═══ Gate ═══
```
- 閘極完全包覆通道（四面）→ 最佳靜電控制
- 可調整 Nanosheet 寬度（比 FinFET 靈活）
- TSMC N2 開始採用

| 特性 | Planar | FinFET | GAAFET |
|------|--------|--------|--------|
| 靜電控制 | 弱 | 好 | 最佳 |
| 短通道效應 | 嚴重 | 小 | 最小 |
| 寬度靈活性 | 連續 | 量化 | 半連續 |
| 製程複雜度 | 簡單 | 中等 | 複雜 |
| 寄生電容 | 低 | 中 | 高 |
| 節點範圍 | ≥28nm | 22-3nm | ≤3nm |

(b) FinFET 量化效應：

FinFET 的有效通道寬度 = nFin × (2·HFin + WFin)

例如 TSMC N7：HFin ≈ 40nm，WFin ≈ 7nm，Fin Pitch ≈ 30nm
Weff per Fin ≈ 2×40 + 7 = 87nm

寬度只能是 87nm 的整數倍：87, 174, 261, 348nm...

影響：
- 無法精細調整驅動強度（不能像 Planar 一樣設 W = 任意值）
- 標準元件庫必須適應量化（如 1-fin, 2-fin, 3-fin 版本）
- SRAM 的 Cell Ratio 調整受限
- Analog 設計更具挑戰（電流鏡匹配受 Fin 數量限制）

(c) 5nm 以下的三大設計挑戰：

1. **互連瓶頸（Interconnect Bottleneck）**：
   - 金屬線寬 < 20nm → 電阻率急劇上升（表面散射、晶界散射）
   - RC 延遲超過閘延遲
   - 解決：Ruthenium/Cobalt 替代銅、BSPDN

2. **功耗密度（Power Density）**：
   - 電晶體密度持續增加但散熱不變 → 功耗密度壁
   - 解決：更激進的 Power Gating、DVFS、3D-IC 散熱

3. **設計複雜度與 EDA 挑戰**：
   - 多重圖案化 → 佈線規則極其複雜
   - 製程變異性增加 → 需要更多 guard band
   - 設計規則數量爆炸（數千條規則）
   - 解決：更強大的 EDA 工具、設計技術協同最佳化（DTCO）

(d) BSPDN（Backside Power Delivery Network）：

傳統：電源線和信號線共享正面（Frontside）金屬層
BSPDN：電源線走背面（Backside），信號線獨佔正面

```
  傳統架構：          BSPDN 架構：
  ┌─ Signal ─┐      ┌─ Signal only ─┐  ← 正面
  ├─ Signal ─┤      ├─ Signal only ─┤
  ├─ Power  ─┤      ├─ Signal only ─┤
  ├─ Signal ─┤      ├───────────────┤
  ├─ Power  ─┤      │   Transistor  │
  │ Transistor│      ├───────────────┤
  └───────────┘      ├─ Power only ──┤  ← 背面
                     └───────────────┘
```

BSPDN 優勢：
- 電源網路電阻降低 50-70%（更寬的 Power Rail）
- IR Drop 大幅改善
- 正面金屬層全用於信號 → 佈線資源增加
- 信號互連延遲降低（更少的繞線）

TSMC 計劃在 N2P/A14 引入 BSPDN 技術。

**答案**：GAAFET 提供最佳靜電控制適用於 ≤ 3nm；FinFET 寬度量化限制設計靈活性；先進節點三大挑戰為互連瓶頸、功耗密度、設計複雜度；BSPDN 大幅改善電源完整性。

**延伸思考**：TSMC 的技術路線：N7(FinFET) → N5 → N3 → N2(GAAFET/Nanosheet) → A14(BSPDN)。面試常問「FinFET vs Planar 最大差異？」和「GAAFET 解決了什麼問題？」

---
### 題目 60：SoC 設計流程與方法學
**來源**：台大電機 / MTK 面試
**難度**：★★★★☆
**主題**：系統單晶片（SoC）設計流程

**題目**：
(a) 畫出完整的數位 SoC 設計流程圖（從規格到 GDSII Tape-out），標注每個步驟使用的主要 EDA 工具。
(b) 解釋前端設計（Front-end）與後端設計（Back-end）的分界。
(c) 列出 Signoff 檢查項目（至少 6 項）。
(d) 一個典型的手機 SoC 包含哪些主要 IP 模組？

**詳解**：

**解題思路**：SoC 設計是多團隊協作的系統工程。

**步驟**：

(a) 完整 SoC 設計流程：

```
  ┌──────────────────────────────────────────────┐
  │  1. 系統規格定義 (System Specification)       │
  ├──────────────────────────────────────────────┤
  │  2. 架構設計 (Architecture Design)            │
  │     → SystemC/C++ 建模                        │
  ├──────────────────────────────────────────────┤
  │         ═══ 前端設計 (Front-end) ═══          │
  ├──────────────────────────────────────────────┤
  │  3. RTL 設計 (RTL Coding)                     │
  │     → Verilog/SystemVerilog/VHDL              │
  ├──────────────────────────────────────────────┤
  │  4. 功能驗證 (Functional Verification)        │
  │     → Synopsys VCS / Cadence Xcelium          │
  │     → UVM 方法學                               │
  ├──────────────────────────────────────────────┤
  │  5. 邏輯合成 (Logic Synthesis)                │
  │     → Synopsys Design Compiler (DC)           │
  │     → RTL → Gate-level Netlist                │
  ├──────────────────────────────────────────────┤
  │  6. DFT 插入 (DFT Insertion)                  │
  │     → Synopsys DFT Compiler / DFTMAX          │
  │     → Scan Chain, BIST, JTAG                  │
  ├──────────────────────────────────────────────┤
  │  7. 形式驗證 (Formal Verification)            │
  │     → Synopsys Formality                      │
  │     → RTL vs Netlist 等價性檢查               │
  ├──────────────────────────────────────────────┤
  │         ═══ 後端設計 (Back-end) ═══           │
  ├──────────────────────────────────────────────┤
  │  8. 平面規劃 (Floorplanning)                  │
  │     → Synopsys IC Compiler II (ICC2)          │
  │     → Cadence Innovus                          │
  ├──────────────────────────────────────────────┤
  │  9. 電源規劃 (Power Planning)                 │
  │     → Power Grid, Power Domain                │
  ├──────────────────────────────────────────────┤
  │  10. 佈局 (Placement)                         │
  │      → ICC2 / Innovus                          │
  ├──────────────────────────────────────────────┤
  │  11. 時脈樹合成 (Clock Tree Synthesis, CTS)   │
  │      → ICC2 / Innovus                          │
  ├──────────────────────────────────────────────┤
  │  12. 佈線 (Routing)                           │
  │      → ICC2 / Innovus                          │
  ├──────────────────────────────────────────────┤
  │         ═══ Signoff 驗證 ═══                  │
  ├──────────────────────────────────────────────┤
  │  13. 寄生萃取 (PEX)                           │
  │      → Synopsys StarRC / Siemens Calibre xRC  │
  ├──────────────────────────────────────────────┤
  │  14. 靜態時序分析 (STA)                       │
  │      → Synopsys PrimeTime                     │
  ├──────────────────────────────────────────────┤
  │  15. 物理驗證 (Physical Verification)         │
  │      → DRC: Siemens Calibre / Synopsys ICV    │
  │      → LVS: Calibre / ICV                     │
  │      → ERC: 電氣規則檢查                      │
  ├──────────────────────────────────────────────┤
  │  16. IR Drop / EM 分析                        │
  │      → Synopsys RedHawk / Cadence Voltus      │
  ├──────────────────────────────────────────────┤
  │  17. GDSII Tape-out                           │
  │      → 交付 TSMC 製造                         │
  └──────────────────────────────────────────────┘
```

(b) 前端 vs 後端分界：

**前端設計（Front-end）**：
- 範圍：規格 → 合成後的 Gate-level Netlist
- 重點：功能正確性、時序約束定義
- 產出：RTL code、Synthesis constraints (SDC)、Netlist
- 技能：Verilog/SV 編碼、UVM 驗證、時序約束

**後端設計（Back-end / Physical Design）**：
- 範圍：Netlist → GDSII
- 重點：時序收斂、面積最佳化、電源完整性、物理規則
- 產出：Layout (GDSII)、Timing reports、Physical verification reports
- 技能：Floorplan、P&R、CTS、STA、Physical verification

**分界點**：Logic Synthesis 的輸出（Gate-level Netlist + SDC）

(c) Signoff 檢查項目：

1. **STA（Static Timing Analysis）**：所有 corner 下 Setup/Hold timing clean
2. **DRC（Design Rule Check）**：佈局滿足所有製程規則
3. **LVS（Layout vs Schematic）**：佈局與電路圖一致
4. **ERC（Electrical Rule Check）**：無浮接閘極、無短路
5. **IR Drop Analysis**：靜態/動態 IR drop 在容許範圍內
6. **EM（Electromigration）Check**：所有金屬線電流密度在限制內
7. **Antenna Check**：天線比在允許範圍內
8. **Power Analysis**：功耗在散熱預算內
9. **Formal Verification**：Netlist vs RTL 等價
10. **DFT Coverage**：測試覆蓋率 > 95%

全部 PASS 才能 Tape-out！

(d) 典型手機 SoC IP 模組：

```
  ┌─────────────────────────────────────────┐
  │              Mobile SoC                  │
  │                                         │
  │  ┌─────┐ ┌─────┐ ┌─────┐ ┌──────┐     │
  │  │CPU  │ │GPU  │ │NPU  │ │Modem │     │
  │  │ARM  │ │Mali/│ │(AI  │ │(5G   │     │
  │  │Cortex│ │Adreno││Accel)│ │Base- │     │
  │  │A/X  │ │     │ │     │ │band) │     │
  │  └──┬──┘ └──┬──┘ └──┬──┘ └──┬───┘     │
  │     │       │       │       │          │
  │  ┌──┴───────┴───────┴───────┴──┐       │
  │  │     NoC (Network on Chip)    │       │
  │  └──┬───────┬───────┬───────┬──┘       │
  │     │       │       │       │          │
  │  ┌──┴──┐ ┌──┴──┐ ┌──┴──┐ ┌──┴──┐     │
  │  │LPDDR│ │ISP  │ │Video│ │Disp │     │
  │  │Ctrl │ │(影像│ │Codec│ │(顯示│     │
  │  │     │ │處理)│ │H265 │ │控制)│     │
  │  └─────┘ └─────┘ └─────┘ └─────┘     │
  │                                         │
  │  ┌─────┐ ┌─────┐ ┌─────┐ ┌──────┐     │
  │  │Audio│ │USB  │ │PCIe │ │Security│    │
  │  │DSP  │ │3.0  │ │4.0  │ │(TZ)   │    │
  │  └─────┘ └─────┘ └─────┘ └──────┘     │
  │                                         │
  │  ┌─────┐ ┌─────┐ ┌─────┐              │
  │  │SRAM │ │PLL  │ │PMU  │              │
  │  │Cache│ │/DLL │ │(電源│              │
  │  │     │ │     │ │管理)│              │
  │  └─────┘ └─────┘ └─────┘              │
  └─────────────────────────────────────────┘
```

典型 MTK Dimensity SoC 包含：
- CPU：ARM Cortex-A 系列（big.LITTLE 架構）
- GPU：ARM Mali 或 Imagination
- NPU：自研 AI 加速器（APU）
- Modem：5G NR + 4G LTE 基頻
- ISP：影像信號處理器（相機）
- Video Codec：H.265/AV1 編解碼
- LPDDR Controller：記憶體介面
- NoC：片上網路互連
- PMU：電源管理單元
- Security：TrustZone + 加密引擎
- I/O：USB、PCIe、MIPI、UFS

**答案**：SoC 設計流程從 RTL → Synthesis → P&R → Signoff → GDSII；前後端以 Netlist 為分界；Signoff 需通過 10+ 項檢查；手機 SoC 整合 CPU/GPU/NPU/Modem 等數十個 IP。

**延伸思考**：SoC 設計是團隊工程，TSMC 提供 PDK（Process Design Kit）支援所有 EDA 工具。MTK 的 SoC 設計團隊通常有數百人，分工涵蓋架構、RTL、驗證、合成、P&R、Signoff 等專業。面試常問「描述你在設計流程中的角色與貢獻」。

---

## 附錄：公式速查表

### CMOS 反相器核心公式
| 公式 | 表達式 |
|------|--------|
| 開關閾值 | VM = (VDD + Vtp + Vtn·√(βn/βp)) / (1 + √(βn/βp)) |
| 雜訊邊限 | NMH = VOH - VIH, NML = VIL - VOL |
| 傳播延遲 | tpd = 0.69 · Req · CL |
| 動態功率 | Pdyn = α · CL · VDD² · f |
| 靜態功率 | Pstatic = Ileak · VDD |
| PDP | PDP = α · CL · VDD² |
| EDP | EDP = PDP · tpd |

### 時序約束
| 約束 | 公式 |
|------|------|
| Setup | Tclk ≥ tcq + tlogic + tsetup + tskew |
| Hold | tcq + tlogic(min) ≥ thold + tskew |
| Max Freq | fmax = 1 / (tcq + tlogic + tsetup + tskew) |

### 互連延遲
| 模型 | 公式 |
|------|------|
| Elmore (分佈式) | τ = RC/2 |
| 含驅動電阻 | τ = Rd·C + RC/2 |
| 50% 延遲 | t50% = 0.69·τ |

### SRAM 設計參數
| 參數 | 定義 |
|------|------|
| Cell Ratio (CR) | βPD / βPG（讀穩定性，要 > 1.5） |
| Pull-up Ratio (PR) | βPU / βPG（寫入能力，要 < 1.5） |

### 良率
| 模型 | 公式 |
|------|------|
| Poisson | Y = e^(-AD₀) |
| Murphy | Y = [(1-e^(-AD₀))/(AD₀)]² |

---

> **本題庫完成**：共 60 題，涵蓋 CMOS 基礎、邏輯設計、時序電路、互連佈局、記憶體算術電路、低功耗先進設計六大主題。適用於台大電機博士資格考與 TSMC/MTK/Realtek 面試準備。
